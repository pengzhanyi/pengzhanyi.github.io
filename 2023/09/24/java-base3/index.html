<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>java基础- 基于面向对象的应用_1 | Blog | kaori</title><meta name="author" content="zhanyi peng"><meta name="copyright" content="zhanyi peng"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[TOC] 枚举和注解枚举 基本介绍：  枚举对应英文enumeration,简写enum 枚举是一组常量的集合 可以理解为枚举属于一种特殊的类，里面只包含一组有限的特定的对象   枚举实现方式  1 自定义实现枚举 2 使用enum关键字实现枚举    自定义实现枚举 自定义枚举类特点 构造器私有化 对枚举对象&#x2F;属性使用final + static 共同修饰，实现底层优化 不需要提供类">
<meta property="og:type" content="article">
<meta property="og:title" content="java基础- 基于面向对象的应用_1">
<meta property="og:url" content="https://pengzhanyi.github.io/2023/09/24/java-base3/index.html">
<meta property="og:site_name" content="Blog | kaori">
<meta property="og:description" content="[TOC] 枚举和注解枚举 基本介绍：  枚举对应英文enumeration,简写enum 枚举是一组常量的集合 可以理解为枚举属于一种特殊的类，里面只包含一组有限的特定的对象   枚举实现方式  1 自定义实现枚举 2 使用enum关键字实现枚举    自定义实现枚举 自定义枚举类特点 构造器私有化 对枚举对象&#x2F;属性使用final + static 共同修饰，实现底层优化 不需要提供类">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pengzhanyi.github.io/images/java_base3_03.jpg">
<meta property="article:published_time" content="2023-09-24T08:50:40.000Z">
<meta property="article:modified_time" content="2024-01-17T03:53:04.894Z">
<meta property="article:author" content="zhanyi peng">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pengzhanyi.github.io/images/java_base3_03.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://pengzhanyi.github.io/2023/09/24/java-base3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java基础- 基于面向对象的应用_1',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-17 11:53:04'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Blog | kaori" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head_sculpture.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/java_base3_03.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Blog | kaori"><span class="site-name">Blog | kaori</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java基础- 基于面向对象的应用_1</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-24T08:50:40.000Z" title="发表于 2023-09-24 16:50:40">2023-09-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-17T03:53:04.894Z" title="更新于 2024-01-17 11:53:04">2024-01-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java基础- 基于面向对象的应用_1"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>[TOC]</p>
<h1 id="枚举和注解"><a href="#枚举和注解" class="headerlink" title="枚举和注解"></a>枚举和注解</h1><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><ul>
<li><p>基本介绍：</p>
<ul>
<li>枚举对应英文enumeration,简写enum</li>
<li>枚举是一组常量的集合</li>
<li>可以理解为枚举属于一种特殊的类，<u>里面只包含一组有限的特定的对象</u></li>
</ul>
</li>
<li><p>枚举实现方式</p>
<ul>
<li>1 自定义实现枚举</li>
<li>2 使用enum关键字实现枚举</li>
</ul>
</li>
</ul>
<h3 id="自定义实现枚举"><a href="#自定义实现枚举" class="headerlink" title="自定义实现枚举"></a>自定义实现枚举</h3><ul>
<li>自定义枚举类特点<ul>
<li>构造器私有化</li>
<li>对枚举对象&#x2F;属性使用final + static 共同修饰，实现底层优化</li>
<li>不需要提供类属性的set方法，因为枚举对象值通常为只读,可以提供get方法</li>
<li>对外暴露枚举对象，<u>设置对象为<strong>public static final</strong></u></li>
<li>枚举对象名通常使用全部大写，常量的命名规范</li>
<li>枚举对象根据需要，也可以有多个属性</li>
</ul>
</li>
<li>例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">private</span> String desc ;<span class="comment">//描述</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name , String desc)</span>&#123;</span><br><span class="line">        <span class="comment">//构造器设置为私有化防止外部直接实例化</span></span><br><span class="line">        <span class="built_in">this</span>.name = name ;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//去掉set方法防止属性被修改</span></span><br><span class="line">    <span class="comment">//在类内部直接创建固定的对象，public static final</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span> , <span class="string">&quot;温暖&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span> , <span class="string">&quot;炎热&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span> , <span class="string">&quot;凉爽&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span> , <span class="string">&quot;寒冷&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>


<h3 id="enum关键字实现枚举"><a href="#enum关键字实现枚举" class="headerlink" title="enum关键字实现枚举"></a>enum关键字实现枚举</h3><ul>
<li><p>实现具体过程</p>
<ul>
<li>使用关键字enum来代替class</li>
<li>public static final 对象名 &#x3D; new 枚举类名（参数列表） 定义枚举变量的方式变为直接用  <strong>变量名（参数列表）</strong></li>
<li>如果有多个常量（对象），使用 ， 间隔即可</li>
<li>如果<strong>使用enum来实现枚举，要求必须将定义常量对象写在类的最前面</strong></li>
<li>例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    Season(<span class="string">&quot;春天&quot;</span> , <span class="string">&quot;温暖&quot;</span>) ,SUMMER (<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;炎热&quot;</span>) ,</span><br><span class="line">    AUTUMN (<span class="string">&quot;秋天&quot;</span> , <span class="string">&quot;凉爽&quot;</span>),WINTER  (<span class="string">&quot;冬天&quot;</span> , <span class="string">&quot;寒冷&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">private</span> String desc ;<span class="comment">//描述</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name , String desc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name ;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name + <span class="built_in">this</span>.desc ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>enum关键字实现枚举注意事项     </p>
<ul>
<li>简化的定义枚举类变量的方式： 变量名（参数列表） 形式，这里必须知道它调用的是哪个构造器</li>
<li>当使用无参构造器创建枚举对象，则实参列表和小括号都可以省略</li>
<li>当有多个枚举对象时，使用 , 间隔，最后一个由分号结尾</li>
<li>枚举类对象必须放在枚举类的行首</li>
</ul>
</li>
<li><p>补充</p>
<ul>
<li><p>输出enum的对象时会调用enum的toString方法，返回该枚举对象名，具体内容可查看Enum类源码 </p>
</li>
<li><p>当使用enum关键字定义类时，这个类会默认继承Enum类，所以子类会获得Enum中的各种方法</p>
<ul>
<li><p>因为已经默认Enum类，因为java的单继承机制，故枚举类不能再继承别的类，但可以实现接口</p>
</li>
<li><p>可以用javap反编译.class文件以显示对应源码中隐藏的细节，通过这种方法来证明，枚举类继承Enum类,而且是一个final类</p>
<ul>
<li><img src="/images/java_base3_01.png" alt="img"></li>
</ul>
</li>
<li><p>或在idea中利用Ctrl + Alt + U来查看类的继承关系</p>
<ul>
<li><img src="/images/java_base3_02.png" alt="img"></li>
</ul>
</li>
</ul>
</li>
<li><p>enum类常用方法</p>
<ul>
<li>toString：Enum类已经重写过了，返回当前对象名，子类可以根据需要重写方法</li>
<li>name ： 返回当前对象名（常量名），是final的方法，子类中不能重写</li>
<li>ordinal :返回当前对象的位置号，默认从0开始</li>
<li>values:返回当前枚举类中的所有常量<ul>
<li>隐藏起来了，在反编译中可以查看到，返回类型为该枚举类的数组</li>
</ul>
</li>
<li>valueOf：返回具有指定名称的指定枚举类型的枚举常量，要求字符串必须为已有的常量名，否则报异常<ul>
<li>就是在已有的枚举常量对象中寻找，并不会创建新的枚举对象</li>
</ul>
</li>
<li>compareTo ： 比较两个枚举常量，比较的就是位置号 </li>
<li>例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>) ， SUMMER(<span class="string">&quot;夏天&quot;</span>) ，AUTUMN(<span class="string">&quot;秋天&quot;</span>) ,WINTER(<span class="string">&quot;冬天&quot;</span>);</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showElements</span><span class="params">()</span>&#123;</span><br><span class="line">        Season[] array = Season.values();</span><br><span class="line">        <span class="comment">//使用values方法获得枚举类数组</span></span><br><span class="line">        <span class="keyword">for</span>(Season element : array)&#123;</span><br><span class="line">            System.out.println(element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name + <span class="built_in">this</span>.desc ;</span><br><span class="line">        <span class="comment">//根据需要重写toString方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><ul>
<li><p>注解介绍</p>
<ul>
<li><p>注解（Annotation）也被称为元数据（Metadata），用于修饰解释，包，类，方法，属性，构造器局部变量等数据信息</p>
</li>
<li><p>和注释一样，注解不影响程序逻辑，但注解可以被编译运行，相当于嵌入在代码中的补充信息</p>
</li>
<li><p>在JavaSE中，，注解的使用目的很简单，例如标记过时的功能，忽略警告等。但在javaEE中，注解很重要，例如用来配置应用程序的任何切面，代替javaEE旧版所一流的繁荣代码和XML配置等</p>
</li>
</ul>
</li>
<li><p>基本的Annotation介绍：  </p>
<ul>
<li>在使用注解时要在其前面增加@符号，并把该Annotation当成一个修饰符使用。用于修饰它支持的程序元素.</li>
<li><strong>注解的作用在于编译器会根据注解的内容进行语法校验</strong><ul>
<li>例如若在方法前加上@override，则在编译时，编译器会去检查该方法是否时真的是重写了父类中的函数或实现接口中的函数，若没有，则编译不能通过</li>
</ul>
</li>
</ul>
</li>
<li><p>三种基本注解类型</p>
<ul>
<li><p>@Override : 限定某个方法，表示重写父类方法，该注释只能用于方法</p>
<ul>
<li>@Override表示指定重写父类的方法（从编译层面验证），</li>
<li>若不写@Override注解，而父类有public的同名同返回类型的方法，仍然构成重写</li>
<li>@Override只能修饰方法，不能修饰类，包，属性等</li>
<li>查看@Override的源码为： @Target(ElementType.METHOD)，表示只能修饰方法</li>
<li>@Target是修饰注解的注解，称为元注解</li>
</ul>
</li>
<li><p>@Deprecated: 用于表示某个程序元素（类，方法）已经过时</p>
<ul>
<li>表示该类，方法，元素已过时，不推荐使用，但仍可以使用</li>
<li>可以做到新旧版本的兼容和过度</li>
</ul>
</li>
<li><p>@SuppressWarnings:抑制编译器警告</p>
<ul>
<li>当不希望看到警告时可以用@SuppressWarings</li>
<li>使用方法： @SuppressWarnings({ “ “}),在其中写入希望抑制的警告信息<ul>
<li>例：抑制所有警告 @SuppressWarings( { “ all “ } )</li>
<li>具体的警告类型可以自己查询 ， 例如”unused” , “unchecked”</li>
<li>@SuppressWarings 范围与放置的位置相关，可以放在类前，方法前等</li>
</ul>
</li>
<li>查看源码，该注解类有字符串数组参数String[] value(),用于输入多个警告信息</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>查看Override源码， @interface表示是一个注解，而不是接口</p>
</blockquote>
<ul>
<li><p>元注解<br>JDK的元Annotation用于修饰其他Annotation<br>元注解作用不大，了解即可，可多看源码</p>
<ul>
<li>元注解的种类<ul>
<li><p>Retention &#x2F;&#x2F;指定注解的作用范围，三种 SOURCE，CLASS，RUNTIME</p>
<ul>
<li>例如@Override的作用域在SOURCE，当编译器编译时生效，不会写入.class文件，也不会在Runtime（运行时）生效</li>
</ul>
</li>
<li><p>Target &#x2F;&#x2F;指定注解可以在哪些地方使用</p>
<ul>
<li>@Override的 @Target(ElementType.METHOD)，只能作用于方法</li>
<li>@SuppressWarings 的@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE}) ，可作用方法，变量等</li>
</ul>
</li>
<li><p>Document &#x2F;&#x2F;指定注解是否在javadoc中体现</p>
<ul>
<li>注解中加入@Documented 表示该注解会被保存在javadoc文档中</li>
</ul>
</li>
<li><p>Inherited &#x2F;&#x2F;子类会继承父类注解</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="异常和异常处理"><a href="#异常和异常处理" class="headerlink" title="异常和异常处理"></a>异常和异常处理</h1><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul>
<li><p>基本概念</p>
<ul>
<li>java语言中，将程序执行中发生的不正常情况称为“异常” ，</li>
<li>注意：开发过程中的语法错误和逻辑错误不是异常</li>
</ul>
</li>
<li><p>执行过程中的异常事件主要分为两类</p>
<ul>
<li><p>Error（错误）：java虚拟机无法解决的严重的问题，例如JVM系统内部错误，资源耗尽的严重情况。如StackOverflowError[栈溢出] ，Error是严重错误，程序会崩溃</p>
</li>
<li><p>Exception : 其他因编程错误或偶然外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如NullPointerException[空指针访问] 等</p>
<ul>
<li>Exception可以分为两大类<ul>
<li><p><strong>运行时异常</strong> ，程序运行时发生的异常，</p>
</li>
<li><p><strong>编译时异常</strong> ， 编译时，编译器检查出的异常</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>异常体系图</p>
<ul>
<li><p>下列图中列举一些常见异常的继承关系图</p>
<ul>
<li>注，绿色虚线代表实现接口，蓝色实线代表类的继承</li>
</ul>
</li>
<li><p><img src="/images/java_base3_04.png" alt="img"></p>
</li>
<li><p>总结 ：</p>
<ul>
<li><p>异常分为两大类，运行时异常和编译时异常</p>
</li>
<li><p>运行时异常，编译器不要求强制处理的异常。一般是指编程时的逻辑错误，程序员应该避免其出现的异常。java.lang.RuntimeException类及他的子类都是运行时异常</p>
</li>
<li><p>编译时异常是编译器要求必须处理的异常，Exception中除了RuntimeException和其子类，其余都是编译时异常</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="简单的异常捕获机制try-catch"><a href="#简单的异常捕获机制try-catch" class="headerlink" title="简单的异常捕获机制try-catch"></a>简单的异常捕获机制try-catch</h3><ul>
<li><p>对异常进行捕获，保证程序在遇到异常仍可以继续运行，不会直接崩溃，保证程序健壮性</p>
</li>
<li><p>当程序员认为一段代码可能出现异常时，可以用try-catch异常处理机制来解决问题</p>
</li>
<li><p>try-catch异常处理机制</p>
<ul>
<li><p>语法：  </p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;<span class="comment">/*可能产生异常的代码*/</span>&#125;</span><br><span class="line">    <span class="keyword">catch</span>(Typel id1)</span><br><span class="line">    &#123;<span class="comment">/*处理Typel异常的代码*/</span>&#125;</span><br><span class="line">    <span class="keyword">catch</span>(Type2 id1)</span><br><span class="line">    &#123;/处理Type2异常的代码*/&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在idea中，选中代码块， 快捷键 Ctrl + Alt + t ， 选中try - catch</strong></p>
</li>
<li><p>示例：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num3</span> <span class="operator">=</span> num1 / num2 ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception e)</span><br><span class="line">    &#123;<span class="comment">/*处理Typel异常的代码*/</span></span><br><span class="line">        e.printStackTrace();<span class="comment">//打印异常相关信息</span></span><br><span class="line">        System.out.println(e.getMessage);<span class="comment">//打印出现异常的原因</span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="常见的运行时异常"><a href="#常见的运行时异常" class="headerlink" title="常见的运行时异常"></a>常见的运行时异常</h3><ul>
<li><p>NullPointerException空指针异常</p>
<ul>
<li>当应用程序试图在需要对象的地方使用NULL时，抛出该异常</li>
<li>例: <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object[] array = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">10</span>];</span><br><span class="line">System.out.println(array[<span class="number">1</span>].getClass());</span><br><span class="line"><span class="comment">//创建对象数组时，记得要将数组内每个对象引用都初始化指向实例对象</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>ArithmeticException数学运算异常</p>
<ul>
<li>当出现异常的运算条件时，抛出此异常，如将一个整数除以零</li>
</ul>
</li>
<li><p>ArrayIndexOutOfBoundsException数组下标越界异常</p>
<ul>
<li>用非法索引访问数组时抛出的异常，如果索引为负或大于等于数组大小，则该索引为非法索引</li>
</ul>
</li>
<li><p>ClassCastException类型转换异常</p>
<ul>
<li>当试图将对象强制转换为不是实例的子类时，抛出该异常</li>
<li>例  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="comment">//main方法中：</span></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> (B) a ;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>NumberFormatException数字格式不正常异常</p>
<ul>
<li>当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当形式时，抛出该异常，使用时可以确保我们输入满足条件的字符串</li>
<li>例 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">test</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span> ;</span><br><span class="line">        Integer.parseInt(test);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="编译异常"><a href="#编译异常" class="headerlink" title="编译异常"></a>编译异常</h3><ul>
<li><p>概念 ：编译异常是指在编译期间就必须处理的异常，否则代码不能通过编译</p>
</li>
<li><p>常见的编译异常：</p>
<ul>
<li>SQLException ：操纵数据库时，查询表可能发生异常</li>
<li>IOEException：操纵文件时繁盛的异常</li>
<li>FileNotFound：当操纵一个不存在的文件时，发生异常</li>
<li>ClassNotFoundException：加载类时而该类不存在时，异常</li>
<li>EOFException : 操纵文件，到文件末尾时，发生异常</li>
<li>IIIegalArgumentException:参数异常</li>
</ul>
</li>
</ul>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><ul>
<li><p>基本介绍：<br>异常处理就是当异常发生时，对异常处理的方式</p>
</li>
<li><p>异常处理的方式：  </p>
<ul>
<li>try-catch-finally</li>
<li>throws</li>
</ul>
</li>
</ul>
<h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h3><p>用于程序员捕获在代码中发生异常，自行处理</p>
<ul>
<li><p>语法：   </p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//可能有异常的代码</span></span><br><span class="line"><span class="comment">//当异常发生时将异常封装成Exception对象,传递给catch </span></span><br><span class="line">&#125;   </span><br><span class="line"><span class="keyword">catch</span> (Type id) &#123; <span class="comment">//这里的Type是指异常的类，可以根据需要填入不同的异常类   </span></span><br><span class="line"><span class="comment">// 得到异常对象后，处理异常 handle exception ，未发现异常则不执行catch中代码 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;    </span><br><span class="line"><span class="comment">//不管是否发现异常，必须执行finally内的代码块，故通常将释放资源的代码放再finally中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>注意事项：</p>
<ul>
<li><p><u>如果异常发生了，则异常后的代码不会执行，直接进入到catch块</u></p>
</li>
<li><p><u>如果异常没有发生，则顺序执行try的代码，不会进入到catch块</u></p>
</li>
<li><p>如果希望不管是否发生异常，都执行某段代码块（比如关闭连接，释放资源等）则使用finally</p>
<ul>
<li>即使在catch中执行了 return 语句结束 ，finally中的代码仍会执行</li>
<li>只有当在catch中执行了System.exit(0) ，关闭了jvm，则任何代码都不再执行</li>
</ul>
</li>
<li><p>可以有多个catch语句，捕获不同的异常（针对不同的异常进行不同的业务处理）</p>
<ul>
<li><strong>如果发生异常只会匹配一个catch</strong></li>
<li><strong>要求父类异常在前，子类异常在后</strong>，比如Exception在后，NullPointerException在前）<ul>
<li>因为父类异常在前，父类exception会捕获所有的子类异常，具体的子类异常处理语句永远无法到达</li>
</ul>
</li>
<li>例：                 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">0</span> ;</span><br><span class="line">&#125; <span class="keyword">catch</span>(NullPointerException e)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是空指针异常&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(ArithmeticException e)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是算数异常&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(RuntimeException e)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;这是运行时异常&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;<span class="comment">//Exception是所有异常的父类</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>可以进行try-finally配合使用，这种用法<strong>相当于没有捕获异常，因此程序会直接崩掉</strong>。</p>
<ul>
<li>应用场景是执行一段代码，不管是否发生异常都必须执行某个业务逻辑，执行完finally内的语句后程序会崩掉</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h3><p> 将发生的异常抛出，交给调用者（方法）来处理，最顶级的处理者就是JVM</p>
<ul>
<li><p>基本介绍：</p>
<ul>
<li>如果一个方法中可能存在某种异常，但是并不能确定如何处理这种异常，则此方法声明应该显示地声明抛出异常，表明方法将不对这些异常进行处理，而<strong>由该方法的调用者负责</strong><ul>
<li>在方法声明中用throws语句可以声明抛出异常的列表，即抛出多个异常</li>
<li>throws后面的异常类型可以是方法中产生的具体异常类型，也可以是该异常类型的父类</li>
</ul>
</li>
</ul>
</li>
<li><p>基本语法 ：<br>  方法修饰符 + 方法名（） + throws + 该函数中出现的异常{}</p>
<ul>
<li>例：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Func</span> <span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">    <span class="comment">//这里可以直接抛出具体的异常，也可以是该异常的父类Exception</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;C:// aa.txt&quot;</span>);</span><br><span class="line">&#125;<span class="comment">//使用throws，抛出异常，让调用Func方法的调用者处理</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>throws使用细节</p>
<ul>
<li><p>对于编译异常，程序中必须处理，如try-catch或throws</p>
</li>
<li><p><strong>对于运行时异常</strong>，程序中如果没有处理，<u>默认就是throws的方式处理</u></p>
<ul>
<li>运行时异常可以不处理，java不强制要求处理，因为运行时异常有默认处理机制</li>
</ul>
</li>
<li><p>在throws过程中，如果有方法 try-catch ，就相当于处理，就可以不必throws</p>
</li>
<li><p>子类重写父类方法时，对抛出的异常的规定：子类重写的方法，所抛出的异常类型要么和父类抛出的异常一致，要么为父类抛出的异常的类型的子类型 </p>
<ul>
<li><p>即<strong>子类重写的抛出的异常的类型范围不能大于父类异常</strong> </p>
</li>
<li><p>父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出</p>
</li>
<li><p>例</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;<span class="comment">//发生编译错误</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Father</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            a.method();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RunTimeException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> <span class="keyword">throws</span> RuntimeException&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>解析：</p>
<ul>
<li>1 因为java的多态机制，在main方法中a.method()实际会调用Son中重写的method()方法</li>
<li>2 实际在try-catch中时针对父类的method方法做出的捕获，实际却调用子类的method方法，子类重写的方法抛出的异常是Exception，显然用于捕获父类异常的RunTimeException无法捕获该异常，可能会导致不可预测的错误</li>
<li>3 故在java中，子类重写父类的方法时，子类如果选择抛出异常，那么抛出的异常类型不能大于父类的异常类型</li>
</ul>
</li>
<li><p>这是遵循了java异常处理的多态性原则，确保在子类中重写的方法不会引入比父类更多的异常情况，以确保代码的稳定性和一致性</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>发生异常时以上两种方案二选一就可，要么在当前函数使用try-catch-finally处理异常，要么继续将异常抛出给调用当前函数的函数让其处理<br>    - 最顶级的异常处理<strong>JVM处理异常的方式是直接输出异常信息，退出程序</strong><br>    - 若无显示处理运行时异常，程序默认采用throws方法</p>
</blockquote>
<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><ul>
<li><p>自定义异常步骤：</p>
<ul>
<li>1 定义类： 自定义异常类名 ，继承Exception或RuntimeException</li>
<li>2 如果继承Exception，一般来说属于编译异常</li>
<li>3 如果继承RuntimeException ， 属于运行异常（一般来说，继承RuntimeException）  <ul>
<li>即把自定义异常做成运行时异常，好处在于可以使用运行时异常的默认处理机制</li>
</ul>
</li>
</ul>
</li>
<li><p>自定义异常使用实例：</p>
<ul>
<li>要求输入一个大于0，小于120的数字，否则抛出异常</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="title function_">MyException</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="comment">//这里的message参数是指该异常相关信息</span></span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="comment">//无参构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main方法中</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">180</span> ;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(num &gt; <span class="number">0</span> &amp;&amp; num &lt; <span class="number">120</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;错啦，数字输入不对&quot;</span>) ;</span><br><span class="line">            <span class="comment">//这里相当于创建一个MyException的匿名对象</span></span><br><span class="line">            <span class="comment">//通过 throw 将异常抛出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>throw 和 throws 的区别</strong></p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>意义</th>
<th>位置</th>
<th>后面跟的东西</th>
</tr>
</thead>
<tbody><tr>
<td>throws</td>
<td>异常处理的一种方式</td>
<td>方法声明处</td>
<td>异常类型</td>
</tr>
<tr>
<td>throw</td>
<td>是手动生成异常对象的关键字</td>
<td>方法体中</td>
<td>异常对象</td>
</tr>
</tbody></table>
<h1 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h1><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><ul>
<li><p>包装类的分类(Wrapper)</p>
<ul>
<li>针对八种基本定义类型的引用类型——包装类</li>
<li>有了类的特点就可以调用类中的方法  </li>
<li>包装类都是Object类的子类，实现了Serializable接口，部分实现了Compareable接口</li>
</ul>
</li>
<li><p>基本包装类：</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>booelan</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
</tbody></table>
</li>
<li><p>包装类与基本数据类型的区别（以int和Integer为例）</p>
<ul>
<li>数据类型不同 ，int是基础数据类型，而Integer是包装数据类型</li>
<li>默认值不同：int的默认值是0，而Integer的默认值是null<ul>
<li>包装类类型未付初值时的null值，更好表示出该变量当前状态</li>
</ul>
</li>
<li>内存中的储存方式不同：<ul>
<li>int 在内存中直接储存的是数据值</li>
<li>Integer实际存储的是对象引用，当new一个Integer时实际上是生成一个指针指向此对象</li>
</ul>
</li>
<li>实例化方式不同：Integer必须实例化才可以使用，而int不需要</li>
<li>变量的比较方式不同<ul>
<li>int可以直接用 &#x3D;&#x3D; 来比较两个变量是否相等</li>
<li>Integer是引用类型 ，必须要用equals来比较两个变量值是否相等，<ul>
<li>（因为常量池的存在数值在-128-127 之间的Integer对象可以用 &#x3D;&#x3D; 来比较，但超出这个范围就不行）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>包装类和基本数据的转换</p>
<ul>
<li><p>手动装箱和拆箱演示：以int与Integer转化为例</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"><span class="comment">//基本类型——&gt;包装类型[手动装箱]</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> Integer.valueOf(i);<span class="comment">//包装类内置static函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//包装类型——&gt;基本类型[手动拆箱]</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">99</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">j1</span> <span class="operator">=</span> j.intValue() ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自动装箱（JDK5以后）：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">M</span> <span class="operator">=</span> m ;<span class="comment">//自动装箱，底层是使用valueOf()方法，</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2</span>);<span class="comment">//自动拆箱,底层是使用inValue()方法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>例题：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="literal">true</span> ? <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>) : <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">2.0</span>) ;</span><br><span class="line">System.out.println(obj1) ;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意,此处输出为 1.0 ,并不是 1 。</strong>，根据 Java 语言规范，在这种情况下，需要进行类型转换以使得两个表达式具有相同的类型。Integer 和 Double 是不同的类型。在三元运算符中，为了满足类型一致性的要求，会发生自动类型提升，Integer 会自动转换为更高精度的类型 Double。因此，即使条件为 true，返回的值是 Integer(1)，但最终结果会被自动转换为 Double 类型。因此，最终的输出结果是 1.0 而不是 1。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>包装类和String类型的相互转换</p>
<ul>
<li><p>包装类转String：（以Integer的转换为例）</p>
<ul>
<li>实例：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"><span class="comment">//方案一:字符串拼接</span></span><br><span class="line"><span class="type">String</span> <span class="variable">string1</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span> + num;</span><br><span class="line"><span class="comment">//方案二：调用toString()方法 </span></span><br><span class="line"><span class="type">String</span> <span class="variable">string2</span> <span class="operator">=</span> num.toString();</span><br><span class="line"><span class="comment">//方案三:使用valueOf()方法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">string3</span> <span class="operator">=</span> String.valueOf(num);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>String转包装类：（以Integer的转换为例）</p>
<ul>
<li>实例：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span> ;</span><br><span class="line"><span class="comment">//方案一：使用包装类的parse函数</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">num1</span> <span class="operator">=</span> Integer.parseInt(string);<span class="comment">//此处也会发生自动装箱</span></span><br><span class="line"><span class="comment">//方案二：构造器,包装类有多个构造器，可按需调用</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(string);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>一些常用的包装类方法和属性</p>
<ul>
<li>继承Number类的数字相关包装类的MaxValue和MinValue值;</li>
<li>Character.isDigit()判断是不是字母 <ul>
<li>isLetter(),判断是不是字母</li>
<li>isUppercase()判断是不是大写字母 </li>
<li>isLowercase()判断是不是小写字母</li>
<li>toUppercase()转换成大写字母 </li>
<li>toLowercase()转换成小写字母</li>
</ul>
</li>
</ul>
</li>
<li><p>经典例题：Integer的创建方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>) ;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>) ;</span><br><span class="line">System.out.println( a == b) ;</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line">System.out.println( c == d );</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">e</span> <span class="operator">=</span> <span class="number">128</span> ;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">128</span> ;</span><br><span class="line">System.out.println( e == f );</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">128</span> ;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">128</span> ;</span><br><span class="line">System.out.println( x == y );</span><br></pre></td></tr></table></figure></li>
<li><p>第一处对比会输出false，因为创建了两个不同的对象，a,b引用指向不同对象</p>
</li>
<li><p>第二处对比会输出true；</p>
<ul>
<li>底层自动装包会使用valueOf()方法</li>
<li>查看valueOf()底层源码，发现在值在-128 - 127 时，会从对象数组中直接返回对象，在值不在该范围时才会创建新的对象</li>
<li>源码分析：IntegerCache是Integer的一个内部类，其中有静态属性cache，是一个Integer类型数组，里面保存了值为-127-128的Integer对象，  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>故此处两个对象引用指向同一个对象，输出true</li>
</ul>
</li>
<li><p>第三处对比会输出false，结合上文介绍，因为128不在设定范围内 故此处会创建两个不同对象。</p>
</li>
<li><p>第四处输出true，<u>只要有基本数据类型，判断的是值是否相等</u>，此处会把包装类自动拆箱。</p>
</li>
</ul>
<blockquote>
<p>这里用到了<strong>享元模式</strong>的设计，享元模式的核心思想是<strong>通过复用对象减少对象的创建数量，从而减少内存的占用和提升性能</strong></p>
</blockquote>
<h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiuzhublog/p/12823838.html">String类详解文章</a></li>
</ul>
<h3 id="String-基础"><a href="#String-基础" class="headerlink" title="String 基础"></a>String 基础</h3><ul>
<li>String类基本介绍<ul>
<li><p>String对象用于保存字符串，也就是一组字符序列</p>
<ul>
<li>String类实现了Serialzable接口，Comparable接口，CharSequeance接口</li>
<li>实现了Serialzable接口，说明该类可以串行化，该类对象可以在网络上传输</li>
<li>实现了Comparable接口，说明该类实现了compareTo方法，该类对象之间可以相互比较大小</li>
</ul>
</li>
<li><p>字符串是不可变的。一个字符串对象一旦被分配，其内容是不可变的</p>
</li>
<li><p>字符串字符使用Unicode字符编码，<u>一个字符占两个字节</u></p>
</li>
<li><p>String 类常用构造器</p>
<ul>
<li>new String()</li>
<li>new String(String original)</li>
<li>new String(char a[])</li>
<li>new String(byte[] b)</li>
</ul>
</li>
<li><p>String 类是final的类，不可被继承</p>
</li>
<li><p>String中有属性：private final char value[]，用于存放字符串内容</p>
<ul>
<li>这个value数组是final类型 ， 赋值后就不能再修改，即value作为引用的存放的地址不能修改, 也即是value的指向不能再修改 </li>
<li>可查看源码了解</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="String创建机制"><a href="#String创建机制" class="headerlink" title="String创建机制"></a>String创建机制</h3><ul>
<li><strong>创建String对象的两种方式</strong><ul>
<li><p>一 .直接赋值 String s &#x3D; “hello” ;</p>
<ul>
<li>使用直接赋值时 ，会先从常量池查看是否已有”hello”的数据空间，如果有则直接指向该位置 ； 若是没有则在常量池中重新创建，然后指向常量池中该数据位置，故s最终指向仍是常量池的空间</li>
</ul>
</li>
<li><p>二 .调用构造器 String s &#x3D; new String(“abc”);</p>
<ul>
<li><p>这个过程中生成一个或两个对象，取决于常量池是否有该字符串</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1686226">相关解析</a></p>
</li>
<li><p>Object类中对String的解释：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(String original)</span> &#123;<span class="number">3</span></span><br><span class="line">    <span class="built_in">this</span>.value = original.value;<span class="comment">//只是引用的传递，并没有在堆中开辟新的空间</span></span><br><span class="line">    <span class="built_in">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么不再在字符串常量池创建该字符串对象，在堆中创建String对象，让栈中的String引用变量s管理该String对象，然后堆中String的属性value指向常量池中的内容</p>
</li>
<li><p>如果用String创建的字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中，然后进行如上操作。</p>
</li>
<li><p>s最终指向是堆中的空间，(是指向堆中创建的String对象,String对象中的value指向常量池中的数据)</p>
<ul>
<li>故如果new两个String &#x3D; “hello”,则两个String的value数组引用中存放的地址相同，即都是常量池中的“hello”。</li>
</ul>
</li>
<li><p><img src="/images/java_base3_05.png" alt="img"></p>
</li>
</ul>
</li>
<li><p>补充：String的intern()函数</p>
<ul>
<li><p>当调用intern方法时，如果池已经包含一个等于此String对象的字符串（用equals(Object)方法确定），则返回来自池的字符串。否则，此String对象将添加到池中，并返回对此String对象的引用</p>
</li>
<li><p>即intern()方法最终是返回在常量池中的地址</p>
</li>
<li><p>相关实例：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">            <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">            System.out.println(a == b);<span class="comment">//T</span></span><br><span class="line">    </span><br><span class="line">            <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>) ;</span><br><span class="line">            <span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">            System.out.println(c == d);<span class="comment">//F</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​            </span><br><span class="line">​            System.out.println(a == d.intern());<span class="comment">//T</span></span><br><span class="line">​            System.out.println(c == d.intern());<span class="comment">//F</span></span><br><span class="line">​            ```</span><br><span class="line">​    </span><br><span class="line">​    - 创建字符串对象例题分析：</span><br><span class="line">​    </span><br><span class="line">​        - <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">​            - 这个过程中创建了一个对象</span><br><span class="line">​            - 编译器会做优化，判断创建的常量池对象是否有引用指向</span><br><span class="line">​            - 故最终优化为<span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;helloabc&quot;</span>；</span><br><span class="line">​    </span><br><span class="line">        - <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    </span><br><span class="line">            - debug跟踪步骤 </span><br><span class="line">                - 创建一个<span class="type">StringBulider</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBulider</span>();</span><br><span class="line">                - 执行sb.append(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">                - 执行sb.append(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">                - 调用sb.toString()</span><br><span class="line">                    - 这个过程中是创建了新的String对象，以“helloabc”初始化;</span><br><span class="line">                    - StringBulider的toString方法：返回一个在堆中创建的String对象</span><br><span class="line">                    ```java</span><br><span class="line">                    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">                        <span class="comment">// Create a copy, don&#x27;t share the array</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(value, <span class="number">0</span>, count);</span><br><span class="line">                    &#125;</span><br></pre></td></tr></table></figure>
<pre><code>      - 在常量池中创建“helloabc”
      - 将该String对象返回给c 
</code></pre>
<ul>
<li><p>这个过程创建了五个对象</p>
<ul>
<li><p>常量池中“hello”</p>
</li>
<li><p>常量池中“abc”</p>
</li>
<li><p>new String(“abc”)匿名对象</p>
</li>
<li><p>StringBulider对象sb，用于拼接字符串</p>
</li>
<li><p>一个字符串对象，指向堆中的helloabc，交给str管理</p>
<ul>
<li>注：StringBuilder内部是可变的字符数组，因为可变，故其不会存放在常量池中，而是在堆中某位置。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>总结：</p>
<ul>
<li>String c &#x3D; “hello” + “abc”常量相加，c直接指向池</li>
<li>String c &#x3D; a + b;变量相加， c会指向在堆中创建的String对象</li>
<li>StringBuilder，StringBuffer等创建的可变字符序列不会放在常量池中</li>
</ul>
</li>
<li><p>补充：</p>
<ul>
<li>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</li>
<li>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="String类常用方法"><a href="#String类常用方法" class="headerlink" title="String类常用方法"></a>String类常用方法</h3><p> String类只能保存字符串常量，每次更新都需要重新开辟空间，效率低，因此java设计者还提供了StringBuffer和StringBuider，注意对字符串操作后返回的是全新的字符串，对原字符串没有任何影响</p>
<ul>
<li><p>length ,获取字符的个数，字符串长度</p>
</li>
<li><p>equals(),判断内容是否相等，区分大小写</p>
</li>
<li><p>equalsIgnoreCase(),忽略大小写判断内容是否相等</p>
</li>
<li><p>indexOf() ,获取字符在字符串中第一次出现的位置索引，索引从零开始，如果没找到，返回-1</p>
</li>
<li><p>lastIndexOf(),获取字符在字符串中最后一次出现的索引，如果没找到，返回-1</p>
</li>
<li><p>substring()，截取指定范围的子串</p>
</li>
<li><p>trim()，截取前后空格</p>
</li>
<li><p>spilt() , 以参数字符串作为标准分割字符串，返回一个字符串数组</p>
</li>
<li><p>charAt:获取某索引出的字符，注意不能使用Str[index]这种方式取出字符串的字符</p>
</li>
<li><p>format：作为输出的模板</p>
<ul>
<li>例：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> String.format(<span class="string">&quot;姓名是%s , 体重是 %.2f&quot;</span>,<span class="string">&quot;hello&quot;</span> , <span class="number">12.012</span>);</span><br><span class="line">System.out.println(info);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> <span class="string">&quot;姓名是%s , 体重是 %.2f&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">info2</span> <span class="operator">=</span> String.format(d , <span class="string">&quot;hello&quot;</span> , <span class="number">12.012</span> )</span><br><span class="line"></span><br><span class="line">System.out.println(info2);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>还有很多字符串函数，根据需要查询</p>
</li>
</ul>
<h2 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h2><ul>
<li><p>基本介绍</p>
<ul>
<li><p>特性</p>
<ul>
<li><p>java.lang.StringBuffer代表可变的字符序列，可以对字符串内容进行增删</p>
</li>
<li><p>很多方法与String相同，但StringBuffer是可变长度的</p>
</li>
<li><p>StringBuffer是一个容器</p>
</li>
</ul>
</li>
<li><p>结构剖析</p>
<ul>
<li><p>StringBuffer的直接父类是 <u>抽象类AbstractStringBuilder</u></p>
<ul>
<li>父类中有属性，char[] value ,用于存放字符串内容，因为不是final的，故该value字符数组存放在堆中</li>
</ul>
</li>
<li><p>StringBuffer实现了Serializable接口，即可以串行化</p>
</li>
</ul>
</li>
<li><p>StringBuffer的构造器</p>
<ul>
<li><p>StringBuffer()&#x2F;&#x2F;查看源码发现创建一个长度为16的字符数组 用于存放字符内容</p>
</li>
<li><p>StringBuffer(int capacity)&#x2F;&#x2F;创建长度为capacity的字符数组</p>
</li>
<li><p>StringBuffer(String str)&#x2F;&#x2F;以str初始化字符数组，创建长度为str.length + 16 的字符数组</p>
</li>
<li><p>StringBuffer(CharSequence seq)&#x2F;&#x2F;构造一个字符串缓冲区，它包含与指定的CharSequence相同的字符</p>
</li>
</ul>
</li>
<li><p>String 与StringBuffer类对比</p>
<ul>
<li><p>String保存的是字符串常量，里面的值不能更改，每次String类的更新实际上就是更改地址，效率叫低&#x2F;&#x2F;private final char value[]</p>
</li>
<li><p>StringBuffer保存的是字符串常量，里面的值可以更改，每次StringBuffer的更新实际上可以更新内容，不用每次创建新的对象并更新地址，效率高&#x2F;&#x2F;char[] value放在堆中</p>
</li>
</ul>
</li>
<li><p>String与StringBuffer类的相互转换</p>
<ul>
<li><p>String -&gt; StringBuffer</p>
<ul>
<li><p>1 使用StringBuffer的构造器：new StringBuffer(str)</p>
</li>
<li><p>2 先创建一个空的StringBuffer对象，再使用其提供的append函数将字符串添加近这个对象中</p>
</li>
</ul>
</li>
<li><p>StringBuffer-&gt; String</p>
<ul>
<li><p>1 使用StringBuffer提供的toString()方法</p>
</li>
<li><p>2 使用String的构造器在，new String(stringBuffer)</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>StringBuffer常用方法</p>
<ul>
<li><p>增： append() &#x2F;&#x2F;有多个append方法，</p>
</li>
<li><p>删 delete(start , end) &#x2F;&#x2F;</p>
</li>
<li><p>查 indexOf() &#x2F;&#x2F;查找字串在字符串第一次出现的索引如果找不到返回 -1</p>
</li>
<li><p>改 replace(start ， end , string) &#x2F;&#x2F;将start-end中的内容替换掉，<u>且不含end</u></p>
</li>
<li><p>插入 insert()</p>
</li>
<li><p>获取长度length</p>
</li>
</ul>
</li>
<li><p>实例分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">sb.append(str);</span><br><span class="line">System.out.println(sb.length());<span class="comment">//结果为4</span></span><br><span class="line"><span class="comment">//debug跟踪查看源码，底层用到是AbstractStringBuilder的appendNull方法，将null转化为字符串&quot;null&quot;加入字符串中</span></span><br><span class="line"></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(str);</span><br><span class="line"><span class="comment">//此处调用StringBuffer(String str)构造器，底层会调用str.length ,此处会直接发生异常，抛出NullpointerException</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h2><ul>
<li><p>基本介绍 </p>
<ul>
<li><p>StringBuilder是个可变的的字符序列，此类提供一个与StringBuffer兼容的API，但不保证同步(StringBuilder不是线程安全的)。</p>
</li>
<li><p>该类被设计用作StringBuffer的一个简易替换，<strong>用在字符串缓冲区被单个线程使用的时候</strong></p>
</li>
<li><p>如果可能，建议优先采用该类，在大多数实现中，它比StringBuffer要快</p>
</li>
<li><p>在StringBuilder上的主要操作的是append和insert方法，重载的这些方法可以接受很多类型的数据作为参数</p>
</li>
</ul>
</li>
<li><p>结构剖析</p>
<ul>
<li><p>StringBuilder是final的 ， 不能被继承</p>
</li>
<li><p>StringBuilder继承了AbstractStringBuilder属性char value[],对象的字符序列内容存到该value，故也是存放在堆中</p>
</li>
<li><p>实现了Serializable接口，说明StringBuilder的对象可以串行化（对象可以网络传输，可以保存到文件）</p>
</li>
<li><p>StringBuilder的方法没有做互斥的处理，即没有synchronized关键字，因此最好只在单线程情况下使用StringBuilder</p>
</li>
</ul>
</li>
<li><p>常用方法：与StringBuffer的方法相近，不在赘述，根据需要查看源码和API文档</p>
</li>
</ul>
<h2 id="String-，-StringBuffer-，-StringBuilder比较"><a href="#String-，-StringBuffer-，-StringBuilder比较" class="headerlink" title="String ， StringBuffer ， StringBuilder比较"></a>String ， StringBuffer ， StringBuilder比较</h2><ul>
<li><p>String，StringBuilder，StringBuffer非常类似，均代表字符序列，而且方法也大都一样</p>
<ul>
<li><p>String：不可变字符序列，效率低，但是也因其不可变特性，使之非常安全且复用率高。</p>
</li>
<li><p>StringBuffer:可变字符序列，效率较高（增删），是线程安全的（StringBuffer的方法大都使用了synchronized同步）</p>
</li>
<li><p>StringBuilder：可变字符序列，效率最高，但是<u>线程不安全</u></p>
</li>
</ul>
</li>
<li><p><strong>效率：StringBulider &gt; StringBuffer &gt; String</strong></p>
<ul>
<li>验证：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> <span class="number">0L</span> ;</span><br><span class="line">    <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> <span class="number">0L</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span>  <span class="operator">=</span> <span class="string">&quot; &quot;</span>;</span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">70000</span> ; i++)&#123;</span><br><span class="line">        str = str + <span class="string">&quot;i&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    endTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;String的运行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(str);</span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">70000</span> ; i++)&#123;</span><br><span class="line">        sb.append(<span class="string">&#x27;i&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    endTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;StringBuffer的运行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sbd</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">70000</span> ; i++)&#123;</span><br><span class="line">        sbd.append(<span class="string">&#x27;i&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    endTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;StringBuilder的运行时间：&quot;</span> + (endTime - startTime));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>String使用注意：</p>
<ul>
<li>String s &#x3D; “a” ; s +&#x3D; “b”; 实际上原来的”a”字符对象已经丢弃了，现在有创建了一个新的字符串”ab”</li>
<li>如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率，如果这样的操作放到循环中会极大影响程序的性能</li>
<li>故如果要对字符串做大量修改，不要使用String</li>
</ul>
</li>
<li><p>结论：</p>
<ul>
<li>如果字符串存在大量修改操作，用StringBuilder或StringBuffer</li>
<li>如果字符串存在大量修改操作且在单线程情况下，用StringBuilder</li>
<li>如果字符串存在大量修改操作且在多线程情况下，用StringBuffer</li>
<li>如果字符串很少修改，且被多个对象引用，使用String，比如配置信息等</li>
</ul>
</li>
</ul>
<h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><ul>
<li><p>Math的主要运用是其中的static方法，具体用法可根据需要查询API文档或查看源码</p>
<ul>
<li><p>abs（求绝对值）</p>
</li>
<li><p>pow（求幂）</p>
</li>
<li><p>ceil（向上取整）</p>
</li>
<li><p>floor（向下取整）</p>
</li>
<li><p>round（四舍五入）</p>
</li>
<li><p>sqrt（求开方）</p>
</li>
<li><p>random（返回一个0-1之间的随机数，<u>包括0但不包括1</u>）</p>
<ul>
<li>例：获取a - b 之间的一个随机数</li>
<li>(int)(a + Math.random() * (b - a + 1 ) )</li>
</ul>
</li>
<li><p>补充：Random类：</p>
<ul>
<li><p>在java.util包中有一个Random类，它可以在指定的取值范围内随机产生数字</p>
</li>
<li><p>构造方法：</p>
<ul>
<li>Random() ,无参构造器用于创建一个伪随机数生成器，通过它创建的Random实例对象每次使用的种子是随机的（实际上系统会以当前时间戳作为种子）</li>
<li>Random(long seed),构造方法使用一个long型的seed种子创建伪随机数生成器</li>
</ul>
</li>
<li><p>特点： 当创建Random类的实例对象时，如果指定了相同的种子，则每个实例对象产生的随机数具有相同的序列</p>
</li>
<li><p>Random类常用方法：</p>
<ul>
<li>boolean newBoolean() 随机生成boolean类型的随机数</li>
<li>double nextDouble() 随机生成double类型的随机数</li>
<li>int nextInt() 随机生成int类型的随机数</li>
<li>int nextInt(int n ) 随机生成 0 ~ n之间的int类型的随机数（<strong>包括0，不包括n</strong>）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h2><ul>
<li><p>Arrays中包含了一系列静态方法，用于管理或操作数组（比如排序和搜索）</p>
<ul>
<li><p>toString()返回数组的字符串形式</p>
<ul>
<li>Arrays.toString(arr);</li>
</ul>
</li>
<li><p>sort()排序 （自然排序和定制排序）</p>
<ul>
<li><p>因为数组是引用类型，通过数组排序后会直接影响到实参</p>
</li>
<li><p>sort是重载的，可以通过传入接口Comparator实现定制排序</p>
</li>
<li><p>自然排序：</p>
<ul>
<li><p>若是调用Arrays.sort()没有传入Comparator对象指定排序方法，就会调用其内部的自然排序方法</p>
</li>
<li><p>源码实现</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NaturalOrder</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Object&gt; &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object first, Object second)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((Comparable&lt;Object&gt;)first).compareTo(second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">NaturalOrder</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NaturalOrder</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>分析源码，</p>
<ul>
<li><p>这里在Arrays类内部创建了一个NaturalOrder内部类，实现了Comparator接口，重写compare函数，并在内部提供了一个返回NaturalOrder对象的静态方法</p>
</li>
<li><p>注意这里会将传入的Object对象first强转为Comparable类对象,并会动态调用first的运行类型的CompareTo()方法，若是传入的是自定义的类，这个类若是没有实现Comparable接口则会发生.ClassCastException</p>
</li>
<li><p>例：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="type">int</span> num ;<span class="comment">//为了简化代码这里设置为public</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.num = num ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main中：</span></span><br><span class="line">Car[] cars = <span class="keyword">new</span> <span class="title class_">Car</span>[<span class="number">3</span>];</span><br><span class="line">cars[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="number">1</span>) ;</span><br><span class="line">cars[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="number">2</span>) ;</span><br><span class="line">cars[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="number">3</span>) ;</span><br><span class="line">Arrays.sort(cars);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>可定制排序方法，传入实例化的Comparator接口的匿名对象&#x2F;&#x2F;482节,484</p>
<ul>
<li><p>public static <T> void sort(T[] a, Comparator&lt;? super T&gt; c)</p>
</li>
<li><p>涉及接口编程，匿名内部类，动态绑定&#x2F;&#x2F;具体在hspjava481节</p>
</li>
<li><p>注意compare方法返回值是int类型</p>
</li>
<li><p>例：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr , Comparator c)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; arr.length ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; arr.length - i - <span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c.compare(arr[j] , arr[ j + <span class="number">1</span> ]) &gt; <span class="number">0</span> )&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j] ;</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>] ;</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main中：</span></span><br><span class="line">Integer[] arr = &#123; <span class="number">1</span> , <span class="number">3</span> , <span class="number">2</span> , <span class="number">4</span> &#125;;</span><br><span class="line">bubbleSort(arr, <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((Integer) o1) - ((Integer) o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//或直接利用Arrays.sort(),但只能接受Obeject类的数组</span></span><br><span class="line">Arrays.sort(arr, <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((Integer) o1) - ((Integer) o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(Arrays.toString( arr ) );</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>binarySearch 通过二分搜索进行查找，要求必须排好序</p>
<ul>
<li>如果数组中不存在该元素会返回 (-1)*（ 该元素应该在的位置下标 + 1 ）</li>
<li>细节查看源码，或查看483节</li>
</ul>
</li>
<li><p>copyof(&lt;&gt;[] array , int length) 数组元素的复制</p>
<ul>
<li>复制数组array从数组开头长度为length的内容</li>
<li>如果length &gt; array.length ,会以null&#x2F;空&#x2F;0等补齐，</li>
<li>如果length &lt; 0 抛出异常</li>
</ul>
</li>
<li><p>fill 数组元素的填充</p>
</li>
<li><p>equals 比较两个数组的元素内容是否完全一致，包括内容和顺序</p>
</li>
<li><p>asList 将一组值转换成为List</p>
<ul>
<li>List是一个接口，此处返回的List的运行类型是Arrays#ArrayList<ul>
<li>此处 # 表示ArrayList是Arrays的一个内部类</li>
</ul>
</li>
<li>例：List <Integer> aslist &#x3D; Arrays.asList(2,3,4,5);</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h2><ul>
<li><p>System常见方法</p>
<ul>
<li><p>exit(int status) 退出当前程序</p>
<ul>
<li>一般status为0 ， 表示正常退出</li>
</ul>
</li>
<li><p>arraycopy(Object src, int srcPos, Object dest, int destPos,int length) 复制数组元素，比较适合底层调用，一般使用Arrays.copy()完成数组复制</p>
</li>
<li><p>currentTimeMillens() 返回当前时间距离 1970 - 1 - 1 的毫秒数</p>
</li>
<li><p>gc() 运行垃圾回收机制</p>
</li>
</ul>
</li>
</ul>
<h2 id="BigInteger和BigDecimal类"><a href="#BigInteger和BigDecimal类" class="headerlink" title="BigInteger和BigDecimal类"></a>BigInteger和BigDecimal类</h2><ul>
<li><p>BigInteger</p>
<ul>
<li><p>用于大数据处理，保存很大的整形</p>
</li>
<li><p>在对BigInteger惊醒加减乘除的时候要使用对应的方法不能直接加减，要创建一个需要操作的BigInteger调用相关方法</p>
</li>
<li><p>创建： new BigInteger(“”);</p>
<ul>
<li>传入参数要为字符串，底层是当做字符串来处理</li>
</ul>
</li>
<li><p>常见方法</p>
<ul>
<li>add 加</li>
<li>subtract 减</li>
<li>multiply 乘</li>
<li>divide 除</li>
</ul>
</li>
</ul>
</li>
<li><p>BigDecimal</p>
<ul>
<li><p>用于保存处理一个精度很高的浮点型</p>
</li>
<li><p>在对BigDecimal惊醒加减乘除的时候要使用对应的方法不能直接加减，要创建一个 BigDecimal 对象，调用相关方法</p>
</li>
<li><p>创建； 同样要传入字符串作为构造函数的参数</p>
</li>
<li><p>常见方法同上</p>
<ul>
<li>但注意在divide时可能产生无限循环小数，抛出ArithmeticException</li>
<li>解决方法：在调用divide方法时指定精度即可<ul>
<li>System.out.pritln(bigdecimal.divide(bigdecimal2 , BigDecimal.ROUND_CEILING));</li>
<li>表示在结果为无限不循环小数时，保留到分子的精度</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h2><p> 了解知道即可</p>
<h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><ul>
<li><p>Date： 精确到毫秒，代表特定的2023年10月4日17:12:17</p>
</li>
<li><p>SimpleFormat：格式和解析日期的具体类，它允许进行格式化（日期-&gt;文本），解析（文本-&gt;日期）和规范化</p>
</li>
<li><p>具体内容看示例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();<span class="comment">//获取当前系统时间</span></span><br><span class="line">System.out.println(<span class="string">&quot;当前日期是:&quot;</span> + d1);<span class="comment">//这是默认日期输出格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建SimpleFormat对象可以指定日期输出格式</span></span><br><span class="line"><span class="comment">//这里的格式是规定好的，具体格式要求在API文档的SimpleFormat类中</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 hh:mm:ss E&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> simpleDateFormat.format(d1) ;<span class="comment">//将日期转换为指定格式字符串</span></span><br><span class="line">System.out.println(<span class="string">&quot;当前日期是:&quot;</span> + format);</span><br><span class="line"><span class="comment">//也可把一个格式化的String转成对应的Date,得到的Date输出还是按照默认模式，如果希望指定格式需要转换</span></span><br><span class="line"><span class="comment">//在String-&gt;Date时，String内容格式要和自定义格式完全匹配，否则抛出异常</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;1996年01月01日 10:20:30 星期一&quot;</span>;</span><br><span class="line"><span class="type">Date</span> <span class="variable">parse</span> <span class="operator">=</span> simpleDateFormat.parse(s) ;</span><br><span class="line">System.out.println(simplrDateFormat(parse.format(parse)));</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h3><ul>
<li><p>第二代日期类，Calendar类（日历）</p>
</li>
<li><p>Calendar是一个抽象类，它为特定瞬间与一组诸如YEAR，MONTH，DAY_OF_MONTH，HOUR等日期字段之间的转换提供了一些方法，并未操作日历字段提供了一些方法</p>
</li>
<li><p>Calendar的构造器是私有的，要使用Calendar.getInstance()函数获取实例，类似于单例设计模式的理念</p>
</li>
<li><p>具体使用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">cld</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        </span><br><span class="line">System.out.println(cld.get(Calendar.YEAR));<span class="comment">//获取年份</span></span><br><span class="line">System.out.println(cld.get(Calendar.DAY_OF_YEAR));<span class="comment">//当年的第__天</span></span><br><span class="line">System.out.println(cld.get(Calendar.MONTH) + <span class="number">1</span> );<span class="comment">//要加一，因为MONTH从零开始编号</span></span><br><span class="line">System.out.println(cld.get(Calendar.DAY_OF_MONTH));<span class="comment">//该月的第__天</span></span><br><span class="line">System.out.println(cld.get(Calendar.HOUR));</span><br><span class="line"><span class="comment">//Calendar没有专门的格式化方法，要自己组合</span></span><br><span class="line">System.out.println(<span class="string">&quot;今天是&quot;</span> + cld.get(Calendar.YEAR) + <span class="string">&quot;年&quot;</span> + cld.get(Calendar.MONTH) </span><br><span class="line">+<span class="string">&quot;月&quot;</span> + cld.get(Calendar.DAY_OF_MONTH) + <span class="string">&quot;日&quot;</span>);</span><br><span class="line"><span class="comment">//默认是12小时制，若要使用24小时制，将Calendar.HOUR -&gt; Calendar.HOUR_OF_DAY 即可</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="第三代日期类"><a href="#第三代日期类" class="headerlink" title="第三代日期类"></a>第三代日期类</h3><p>因前两代日期类的不足，在JDK8中创建新的日期类</p>
<ul>
<li><p>第三代日期类</p>
<ul>
<li><p>LocalDate （日期&#x2F;年月日）</p>
<ul>
<li>只包含日期，可以获得日期字段</li>
</ul>
</li>
<li><p>LocalTime （时间&#x2F;时分秒）</p>
<ul>
<li>只包含时间，可以获取时间字段</li>
</ul>
</li>
<li><p>LocaleDateTime（日期时间&#x2F;年月日时分秒）</p>
<ul>
<li>包含时间+日期，可以获得日期和时间字段</li>
</ul>
</li>
</ul>
</li>
<li><p>DateTimeFormate格式日期类</p>
<ul>
<li>类似于SimpleDateFormat</li>
<li>DateTimeFormat dtf &#x3D; DateTimeFormatter.ofPattern(格式);</li>
</ul>
</li>
<li><p>Instant 时间戳</p>
</li>
<li><p>第三代日期还有很多方法，按需查询即可，不用都记住</p>
</li>
<li><p>具体示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="comment">//使用now()返回表示当前日期时间的对象，可以获取年月日时分秒</span></span><br><span class="line">System.out.println(ldt);<span class="comment">//直接输出具体日期时间</span></span><br><span class="line">ldt.getYear();<span class="comment">//获取ldt的年份字段</span></span><br><span class="line">ldt.getMonth();</span><br><span class="line">ldt.getMonthValue();</span><br><span class="line">ldt.getDayOfMonth();</span><br><span class="line"><span class="comment">//关于DateTimeFormatter的格式参数要查看jdk8及以后JDK版本的文档</span></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日 HH小时mm分钟ss秒&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">strDate</span> <span class="operator">=</span> dtf.format(ldt);</span><br><span class="line">System.out.println(strDate);</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><ul>
<li><p>保存多个数据用数组有许多不便之处</p>
<ul>
<li>长度必须提前指定，且一旦指定无法更改</li>
<li>保存的必须为同一类型的元素</li>
<li>使用数组进行元素增加的代码比较复杂</li>
</ul>
</li>
<li><p>引入集合，<a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoxi/p/6089984.html">相关内容</a></p>
</li>
<li><p>集合</p>
<ul>
<li>可以动态保存任意多个对象，使用方便</li>
<li>提供了一系列方便的 操作对象的方法：add ， remove，set，get等</li>
<li>使用集合添加删除新元素的代码简洁明了</li>
</ul>
</li>
</ul>
<h2 id="集合的框架体系"><a href="#集合的框架体系" class="headerlink" title="集合的框架体系"></a>集合的框架体系</h2><ul>
<li><p>java集合框架图</p>
<ul>
<li><img src="/images/java_base3_06.png" alt="img"></li>
</ul>
</li>
<li><p>java集合主要分为两大类（单列和双列集合），如图</p>
<ul>
<li>Collection类<ul>
<li><p>Collection接口有两个重要子接口List 和Set，他们的实现子类都是单列集合</p>
</li>
<li><p><img src="/images/java_base3_07.png" alt="img"></p>
</li>
</ul>
</li>
<li>Map类<ul>
<li>Map的接口的实现子类是双列集合，存放<em>K-V数据</em></li>
<li><img src="/images/java_base3_08.png" alt="img"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Collection-接口"><a href="#Collection-接口" class="headerlink" title="Collection 接口"></a>Collection 接口</h2><ul>
<li><p>Collection: 单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要子接口List和Set</p>
</li>
<li><p>Collection简介      </p>
<ul>
<li><p>public interface Collection<E> extends Iterable<E>{}</p>
</li>
<li><p>Collection实现子类可以存放多个元素，每个元素可以是Object</p>
</li>
<li><p><strong>Collection接口没有直接的实现子类，是通过它的子接口Set和List来实现的</strong></p>
<ul>
<li>List的特点是元素有序，可重复</li>
<li>Set的特点是元素无序，且不可重复</li>
</ul>
</li>
</ul>
</li>
<li><p>Collection常用方法（以实现子类ArrayList为例）</p>
<ul>
<li><p>add 添加单个元素</p>
</li>
<li><p>remove 删除指定元素</p>
</li>
<li><p>contains 查找元素是否存在</p>
</li>
<li><p>size 获取元素的个数</p>
</li>
<li><p>isEmpty 判断是否为空</p>
</li>
<li><p>clear 清空</p>
</li>
<li><p>addAll 添加多个元素</p>
</li>
<li><p>containsAll 查找多个元素是否都存在</p>
</li>
<li><p>removeAll 删除多个元素</p>
</li>
<li><p>例：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>() ;</span><br><span class="line">list.add(<span class="string">&quot;hello &quot;</span>);</span><br><span class="line">list.add(<span class="number">1</span>) ; <span class="comment">//本质上是发生了list.add(Integer.valueOf(1))</span></span><br><span class="line">System.out.println(list);</span><br><span class="line">System.out.println(list.contains(<span class="number">1</span>)); <span class="comment">//参数是一个Object对象</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>迭代器Iterator</li>
<li>迭代器基本介绍<ul>
<li>Iterator对象成为迭代器，主要用于遍历Collection集合中的元素</li>
<li>所有实现了Collection接口的集合类都有一个Iterator()方法，用以返回一个实现了Iterator接口的对象，即可以返回一个迭代器<ul>
<li>因为Collection继承了Iterable接口，也继承其中的iterator()抽象方法，用于返回一个迭代器对象</li>
</ul>
</li>
<li>Iterator仅用于遍历集合，Iterator本身并不存放对象</li>
</ul>
</li>
<li>Iterator 结构<ul>
<li>Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素</li>
<li><img src="/images/java_base3_10.png" alt="img"></li>
</ul>
</li>
<li>Itertor接口的方法：<ul>
<li><img src="/images/java_base3_09.png" alt="img"></li>
<li>在调用Iterator方法前，迭代器索引位于第一个元素之前，不指向任何元素</li>
<li>每一次调用next()方法，迭代器会指向下一个数据所在区域并返回该位置的数据</li>
<li>注意： 在调用Iterator.next()方法前必须要先调用Iterator.hasNext()进行检测，若不调用，且下一条记录无效，直接调用.next()会抛出NoSuchElementException异常</li>
</ul>
</li>
<li>迭代器对象获取集合中的元素时，都会将这些元素当做Object类型来看待，如果想要得到特定类型的元素需要进行强制类型转换</li>
</ul>
</blockquote>
<ul>
<li><p>Colection接口实现子类的遍历元素方式 ：</p>
<ol>
<li><p>使用Iterator(迭代器)遍历</p>
<ul>
<li><p>代码示例：（可快捷键“ itit ”直接生成，Ctrl+J显示所有模板快捷键）</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//希望遍历上诉代码演示中的list集合</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> list.iterator();<span class="comment">//得到list对应的迭代器</span></span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;<span class="comment">//判断是否还有数据</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    System.out.println(<span class="string">&quot;obj = &quot;</span> + obj );</span><br><span class="line">    <span class="comment">//默认调用toString方法，根据动态绑定机制会找到obj运行类型重写的toString方法</span></span><br><span class="line">&#125;<span class="comment">//当退出while循环时，iterator迭代器指向最后一个元素，若是此时调用iterator.next()会抛出异常</span></span><br><span class="line"><span class="comment">//如果希望再次遍历则需要重置迭代器list。调用list.iterator();</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>补充：<strong>在使用Iterator迭代器对集合中的元素进行迭代时，如果调用了集合对象的remove方法删除元素后，继续使用迭代器遍历元素可能会出现异常</strong></p>
<ul>
<li>发生了并发修改异常ConcurrentModificationException，这个异常迭代器对象抛出的，出现异常的原因是集合中删除了元素会导致迭代器预期的迭代次数发生改变，导致迭代器的结果不准确</li>
<li>解决方式：在集合迭代期间删除集合中的元素，可以使用迭代器本身的删除方法：it.remove();<ul>
<li>例：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> list.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;jack&quot;</span>.equals(obj))</span><br><span class="line">        iterator.remove();</span><br><span class="line">&#125;<span class="comment">//调用迭代器对象的remove方法删除元素导致的迭代次数变化对于迭代器对象本身来说是可预知的</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>使用增强for循环</p>
<ul>
<li><p>基本介绍</p>
<ul>
<li>增强for循环，可以代替iterator迭代器，特点：增强for就是简化版的iterator，本质一样，只能用于遍历集合或是<u>数组</u></li>
</ul>
</li>
<li><p>基本语法：</p>
<ul>
<li><p>for(元素类型 元素名 ： 集合名或数组名){    </p>
<p> &#x2F;&#x2F;访问元素操作</p>
</li>
</ul>
<p>  }
  </p>
</li>
<li><p>案例演示：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Object obj : list)&#123;<span class="comment">//上述演示中的list集合</span></span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当使用foreach循环遍历集合和数组时，只能访问集合中的元素，而不能对集合中的元素进行修改</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ysocean/p/6822679.html">Java中的增强 for 循环 foreach </a></p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>​		  3.  使用普通for循环</p>
<h3 id="List-接口"><a href="#List-接口" class="headerlink" title="List 接口"></a>List 接口</h3><ul>
<li><p>List接口基本介绍</p>
<ul>
<li><p>List是Collection的子接口</p>
</li>
<li><p><strong>List集合类中元素有序</strong>（即添加顺序和取出顺序一致），且List内元素可重复</p>
</li>
<li><p>List集合中每个元素都有其对应的顺序索引，即支持索引</p>
<ul>
<li>索引从零开始</li>
<li>使用list的get(int index)方法取出</li>
</ul>
</li>
<li><p>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素</p>
</li>
<li><p>实现List接口的常用类有：</p>
<ul>
<li>ArrayList</li>
<li>LinkedList</li>
<li>Vector</li>
<li>Stack ，等</li>
</ul>
</li>
</ul>
</li>
<li><p>List接口常用方法(以ArrayList为例)</p>
<ul>
<li><p>void add(int index,Object ele):在index位置插入ele元素，若不加index，则默认插入在List的最后</p>
</li>
<li><p>boolean addAll(int index,Collection eles):从index位置开始将eles中的所有元素添加进来</p>
</li>
<li><p>boolean remove(Object o)：在ArrayList中查找并删除该对象，如果删除成功（ArrayList中的elementData数组后面的元素后自动前移补充空位）</p>
</li>
<li><p>Object get(int index): 获取指定index位置的元素</p>
<ul>
<li>取出的数据编译类型是Object，根据需要强转</li>
</ul>
</li>
<li><p>int indexOf(Object obj):返回obj在集合中首次出现的位置</p>
</li>
<li><p>int lastIndexOf(Object obj):返回obj在当前集合中最后一次出现的位置</p>
</li>
<li><p>Object set(int index , Object ele): 设置指定index位置的元素为ele，替换</p>
</li>
<li><p>List subList(int fromIndex , int toIndex):返回从fromIndex到toIndex位置的集合，包括formIndex位置，不包括toIndex位置</p>
</li>
<li><p><strong>public void sort(Comparator&lt;? super E&gt; c) ：将list内元素按传入的Comparator方法进行定制排序</strong></p>
</li>
</ul>
</li>
<li><p>List 的三种遍历方式</p>
<ul>
<li><p>List继承Collection接口，其实现子类ArrayList ， LinkedList , Vector等遍历方式与上述Collection实现子类遍历方式相同</p>
</li>
<li><p>例：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="comment">//List的实现子类都可以采用已下遍历方式</span></span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;__&quot;</span>);</span><br><span class="line">list.add( <span class="number">1</span> );</span><br><span class="line"><span class="comment">//Iterator迭代器遍历</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> list.iterator() ;</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//增强for循环遍历</span></span><br><span class="line"><span class="keyword">for</span> (Object ele : list)&#123;</span><br><span class="line">    System.out.println(ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通for循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="ArrayList底层结构和源码分析"><a href="#ArrayList底层结构和源码分析" class="headerlink" title="ArrayList底层结构和源码分析"></a>ArrayList底层结构和源码分析</h4><ul>
<li><p>ArrayList注意事项</p>
<ul>
<li><p>permits all elements ,including null,ArrayList可以加入null，并且可以放入多个空值</p>
</li>
<li><p>ArrayList是由数组来实现数据储存的</p>
</li>
<li><p>ArrayList基本等同于Vector，但ArrayList是线程不安全的（但执行效率高），看源码，多线程情况下不建议使用ArrayList</p>
<ul>
<li>ArrayList是线程不安全的，源码里，ArrayList方法等没有synchronized修饰</li>
</ul>
</li>
</ul>
</li>
<li><p>ArrayList 底层结构和源码分析</p>
<ul>
<li><p>ArrayList中维护了一个Object类型的数组elementData</p>
<ul>
<li>源码  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"><span class="comment">//transient 表示瞬间，短暂的，表示是该属性不会被序列化</span></span><br><span class="line"><span class="comment">//设置为非私有以简化嵌套类访问</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>当创建ArrayList对象时，如果使用的是无参构造器，则初始elementData容量为0，第一次添加，则扩容elementData为10，如需再次扩容，则扩容elementData为1.5倍</p>
<ul>
<li>无参构造器返回一个静态为空的Object数组</li>
<li>源码：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">//默认无参构造器：</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//add函数中:先判断容量是否够继续增加元素，若是list为空则增加一个最小容量的Object数组,size为10</span></span><br><span class="line"><span class="comment">//ensureExplictCapacity()方法中的modCount++ 是用于记录当前集合被修改次数，防止多线程操作发生异常</span></span><br><span class="line"><span class="comment">//内部若是容量不够则执行grow()方法扩容</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数组增长扩容函数grow()部分内容：</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line"><span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//第二次及以后扩容为1.5倍</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)<span class="comment">//若newCpacity小于10,则赋值为10 ，第一次扩容为10</span></span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line"><span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line"><span class="comment">//使用Arrays.copyOf()执行数组扩容，可以保留原集合元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>如果使用的是自定义大小的构造器，则初始化elementData容量为自定义大小，如果需要扩容则直接扩容elementData为1.5倍</p>
</li>
<li><p>底层是使用<strong>Arrays.copyof()函数扩容</strong></p>
</li>
<li><p>具体内容可查看510节</p>
</li>
</ul>
</li>
</ul>
<h4 id="Vector-底层结构和源码剖析"><a href="#Vector-底层结构和源码剖析" class="headerlink" title="Vector 底层结构和源码剖析"></a>Vector 底层结构和源码剖析</h4><ul>
<li><p>Vector类基本介绍</p>
<ul>
<li><p>定义说明：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vector</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure></li>
<li><p>Vector底层也是一个对象数组，protected Object[] elementData ;</p>
</li>
<li><p>Vector是线程同步的，即线程安全的，Vector类的操作方法带有<strong>synchronized</strong></p>
</li>
<li><p>在开发中，需要线程同步安全时，考虑使用Vector</p>
</li>
</ul>
</li>
<li><p>Vector底层结构</p>
<ul>
<li>Vector和ArrayList的比较：</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>底层结构</th>
<th>线程安全（同步），效率</th>
<th>扩容倍数</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayList</td>
<td>可变数组</td>
<td>不安全，效率高</td>
<td>如果是有参构造，扩容1.5倍.无参构造第一次为10，从第二次开始1.5倍扩容</td>
</tr>
<tr>
<td>Vector</td>
<td>可变数组Object[]</td>
<td>安全，效率不高</td>
<td>有参构造，扩容2倍。如果是无参，默认为10，之后每次按两倍扩容</td>
</tr>
</tbody></table>
<ul>
<li><p>源码分析与ArrayList相似，具体可debug追踪</p>
<ul>
<li>注意Vector的扩容机制：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line"><span class="comment">// overflow-conscious code</span></span><br><span class="line"><span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                 capacityIncrement : oldCapacity);<span class="comment">//此处为主要扩容操作  </span></span><br><span class="line"><span class="comment">//capacityIncrement默认是0，可以在构造器中传入，指定每次扩容增加量，否则默认扩双倍</span></span><br><span class="line"><span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = minCapacity;</span><br><span class="line"><span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="LinkedList-底层结构和源码剖析"><a href="#LinkedList-底层结构和源码剖析" class="headerlink" title="LinkedList 底层结构和源码剖析"></a>LinkedList 底层结构和源码剖析</h4><ul>
<li><p>LinkedList全面说明</p>
<ul>
<li>LinkedList底层实现了双向循环链表</li>
<li>可以添加任意元素（元素可以重复），包括null</li>
<li>线程不安全，没有实现同步</li>
</ul>
</li>
<li><p>LinkedList的底层操作机制</p>
<ul>
<li>LinkedList底层维护了一个双向链表</li>
<li>LinkedList中维护了两个属性first和last分别指向首节点和为节点</li>
<li>每个节点（Node对象），里又维护了prev，next，item三个属性其中通过prev指向前一个，通过next指向后一个节点，最终实现双向链表</li>
<li>故LinkedList的元素添加和删除通过修改节点之间引用关系即可，相对来说效率较高</li>
</ul>
</li>
<li><p>源码分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;<span class="comment">//LinkedList维护了一个名为Node的成员内部类，该内部类作为双向链表的节点类</span></span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//LinkedList内部属性：用于储存双向链表的相关属性</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;<span class="comment">//指向双向链表第一个节点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;<span class="comment">//指向双向链表最后一个节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;<span class="comment">//添加链表元素</span></span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;<span class="comment">//添加节点功能实现的主要代码</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line">E <span class="title function_">unlink</span><span class="params">(Node&lt;E&gt; x)</span> &#123;<span class="comment">//实现节点删除功能的主要代码</span></span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="literal">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类似的可多debug跟踪，多注意其中的异常处理内容</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="ArrayList和LinkedList比较"><a href="#ArrayList和LinkedList比较" class="headerlink" title="ArrayList和LinkedList比较"></a>ArrayList和LinkedList比较</h4><table>
<thead>
<tr>
<th></th>
<th>底层结构</th>
<th>增删效率</th>
<th>查改效率</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayList</td>
<td>可变数组</td>
<td>较低，在增加节点过程中发生数组扩容</td>
<td>较高</td>
</tr>
<tr>
<td>LinkedList</td>
<td>双向链表</td>
<td>较高，通过在链表追加节点</td>
<td>较低</td>
</tr>
</tbody></table>
<ul>
<li>总结：<ul>
<li>如果查改操作较多，选择ArrayList</li>
<li>如果增删操作多，选择LinkedList</li>
<li>一般来说在程序中大部分都是查询，因此大部分情况下选择ArrayList</li>
<li>在一个项目中，根据业务灵活选择，不同模块可采用不同的结构</li>
</ul>
</li>
</ul>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ul>
<li><p>Set接口基本介绍</p>
<ul>
<li><p><strong>无序</strong>（添加和取出的顺序不能保证一致），没有索引，取出的顺序虽然不同于添加的顺序，但是仍是按某固定的算法控制输出的顺序，不会相同内容每次输出的顺序都不同</p>
</li>
<li><p><strong>不允许重复元素</strong>，故最多包含一个null，实现Set接口类的类的实例对象不允许存放重复的元素</p>
</li>
<li><p>实现类常用的有：</p>
<ul>
<li>HashSet</li>
<li>TreeSet</li>
<li>其他可查看API文档</li>
</ul>
</li>
</ul>
</li>
<li><p>Set接口的常用方法     </p>
<ul>
<li>和List接口一样，Set接口也是Collection的子接口因此，常用方法和Collection接口相同</li>
<li>因Set的无序性，Set中没有get(int index)方法，也不存在索引值一说</li>
</ul>
</li>
<li><p>Set接口的遍历方式</p>
<ul>
<li>同Collection的遍历方式相同，因为Set接口是Collection接口的子接口，可以使用迭代器</li>
<li>增强for</li>
<li>不能通过索引的方式实现普通for循环遍历</li>
</ul>
</li>
</ul>
<h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><ul>
<li>HashSet简介<ul>
<li><p>HashSet实现了Set接口</p>
</li>
<li><p>HashSet实际上是HashMap：源码：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;<span class="comment">//HashSet默认构造器</span></span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//Constructs a new, empty set; the backing HashMap instance </span></span><br><span class="line">    <span class="comment">//has default initial capacity (16) and load factor (0.75)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以存放null值，但是只能有一个null</p>
</li>
<li><p>HashSet不保证元素是有序的，元素的顺序取决于求hash值后再确定索引的结果</p>
</li>
<li><p><strong>不能有重复的元素&#x2F;对象</strong></p>
<ul>
<li>例1：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HashSet</span> <span class="variable">hashSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">hashSet.add(<span class="string">&quot;hello&quot;</span>) ;</span><br><span class="line">hashSet.add(<span class="literal">null</span>);</span><br><span class="line">System.out.println(hashSet.add(<span class="string">&quot;hello&quot;</span>));<span class="comment">//此处会输出false</span></span><br><span class="line">System.out.println(hashSet);<span class="comment">//输出结果中只有一个hello </span></span><br></pre></td></tr></table></figure></li>
<li>例2：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Book</span><span class="params">(String name )</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main中：</span></span><br><span class="line"><span class="type">HashSet</span> <span class="variable">hashSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">hashSet.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;百年孤独&quot;</span>)) ;</span><br><span class="line">System.out.println(hashSet.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;百年孤独&quot;</span>)));<span class="comment">//此处输出true</span></span><br><span class="line">System.out.println(hashSet);<span class="comment">//此处打印出了两个Book对象</span></span><br></pre></td></tr></table></figure></li>
<li>例3：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HashSet</span> <span class="variable">hashSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">hashSet.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>)) ;</span><br><span class="line">hashSet.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>));<span class="comment">//此处会？</span></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>  如何理解HashSet不能添加相同的元素&#x2F;对象（跟踪源码）</p>
<ul>
<li><p>HashSet底层是HashMap，HashMap底层是数组+链表+红黑树</p>
</li>
<li><p>HashMap结构示例图：<br><img src="/images/java_base3_11.png" alt="img">  </p>
</li>
<li><p>模拟一个简易的MyHashSet（也就是HashMap），拉链法实现散列表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line"> Object item ;<span class="comment">//存放数据</span></span><br><span class="line"> Node next ;<span class="comment">//存放下一个节点</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Object item, Node next)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.item = item;</span><br><span class="line">      <span class="built_in">this</span>.next = next;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//main中模拟HashMap加入节点的过程</span></span><br><span class="line"> Node[] table = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">16</span>];</span><br><span class="line"> <span class="type">Node</span> <span class="variable">node1</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;hello&quot;</span> , <span class="literal">null</span>) ;</span><br><span class="line"> table[<span class="number">1</span>] = node1 ;<span class="comment">//table的索引为 1 处指向节点node1</span></span><br><span class="line"> <span class="type">Node</span> <span class="variable">node2</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;hi&quot;</span> , <span class="literal">null</span>) ;</span><br><span class="line"> node1.next = node2 ;<span class="comment">//将hi节点挂载在hello节点</span></span><br><span class="line"> <span class="comment">//此时table[1]处便连接一个链表</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>HashSet 的添加元素判断机制：<strong>（hash() + equals()）</strong></p>
<ul>
<li>HashSet底层是HashMap</li>
<li>添加一个元素时，先得到hash()值，会经过运算转化成索引值<ul>
<li><strong>此处的hash值不完全等于该元素的hashcode()，而是经过一定处理得到</strong>       </li>
<li>hash算法：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;<span class="comment">//key就是添加的对象</span></span><br><span class="line">    <span class="type">int</span> h;   </span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);  </span><br><span class="line">&#125;<span class="comment">//该算法的作用在于尽量让不同的key得到不同的hash值，尽量避免hash碰撞</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>在存储数据表table中看这个索引位置是否已经有存放的元素</li>
<li>如果没有直接加入</li>
<li>如果有，调用equals()比较  (此处程序员可通过重写equals方法来控制比较标准) ，如果相同就放弃添加，如果不同则添加到该索引处链表最后</li>
<li>在java8中，<strong>当如果一条链表长度达到8（TREEIFY_THRESHOLD），且table大小达到64（MIN_TREEIFY_CAPACITY），就会树化（红黑树）</strong></li>
</ul>
</blockquote>
<ul>
<li>判断新节点是否能加入的代码HashMap的putVal()方法分析：</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">           <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    n = (tab = resize()).length;<span class="comment">//如果table数组为空则创建table数组，并由tab临时变量指向table数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line"><span class="comment">//此处计算要插入的key在table数组中下标索引并赋给临时变量i: i = (n - 1) &amp; hash，同一索引值的节点连接在一个数组节点后形成链表</span></span><br><span class="line"><span class="comment">//此处中p是putVal方法中定义的临时辅助变量，p指向table数组中key的索引位置后</span></span><br><span class="line"><span class="comment">//如果p指向位置为空，即table[i]后续没有节点，则直接将该key对象加入table[i]后</span></span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//若p的指向table数组的位置后不为空，即table数组该索引位置后有节点</span></span><br><span class="line">    Node&lt;K,V&gt; e; K k;</span><br><span class="line">    <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">        ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">        <span class="comment">//这个判断条件用于确保在 HashMap 中没有重复的键。如果存在重复键，则需要进行覆盖操作，如果不存在则进行插入操作。</span></span><br><span class="line">        e = p;<span class="comment">//辅助变量e指向要传入的节点对应索引位置第一个节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">        e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">    <span class="comment">//判断要key插入的位置后的链表是不是已经被红黑树化，其中调用大量红黑树相关方法</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;<span class="comment">//死循环逐个判断要传入的节点与该索引后链表中节点是否“相同”</span></span><br><span class="line">            <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;<span class="comment">//发现链表中没有“相同”节点，则将该节点加入到链表最后</span></span><br><span class="line">                p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                <span class="comment">//添加节点后立刻判断当前链表是否已经达到8个节点，达到则调用treeifyBin函数，其中还会判断该table数组大小是否超过64</span></span><br><span class="line">                    treeifyBin(tab, hash);</span><br><span class="line">                <span class="comment">// if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span></span><br><span class="line">                <span class="comment">//只有当上述判断条件不成立时才进行树化，否则只是扩容</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//如果发现该链表中有节点和要传入的节点“相同”，则key不能加入，直接跳出循环</span></span><br><span class="line">            p = e;<span class="comment">//节点后移操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">        <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;<span class="comment">//这里的value就是HashSet中的静态成员PRESENT，所有HashSet中节点的Value值都相同</span></span><br><span class="line">        <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">            e.value = value;</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">        <span class="comment">//返回null，表示已经添加成功，在HashSet的add函数中还有一层返回语句如下：</span></span><br><span class="line">        <span class="comment">//return map.put(e, PRESENT)==null;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">++modCount;</span><br><span class="line"><span class="keyword">if</span> (++size &gt; threshold)<span class="comment">//size是HashMap类的属性，如果size大于阈值就扩容</span></span><br><span class="line">    resize();</span><br><span class="line">afterNodeInsertion(evict);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 源码解读看521 - 524节 ，仔细分析HashSet添加元素时调用的HashMap的putVal()方法，</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>补充：</p>
<ul>
<li><p>hash值的计算</p>
<ul>
<li>此处的hash值不完全等于该元素的hashcode()值，而是经过一定处理得到</li>
<li>自定义类hashcode方法可由程序员控制，一般重写Object类的hashCode方法用如下形式：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hash();<span class="comment">//Objects.hash()中是可变参数列表</span></span><br><span class="line">&#125;<span class="comment">//利用Objects工具类中的hash函数，参数列表为类中的属性，根据对象中的属性值求出hash值，</span></span><br></pre></td></tr></table></figure>
<ul>
<li>利用这种方式重写hashCode()可以保证根据不同的属性内容，计算出的hashCode值也不相同</li>
</ul>
</li>
</ul>
</li>
<li><p>i &#x3D; (n - 1) &amp; hash</p>
<ul>
<li>这是根据hash值计算key在table数组下标的算法</li>
<li>在这个表达式中，n 是 HashMap 的容量，而 hash 是键的散列码。&amp; 是位运算符中的按位与运算符。</li>
<li>由于 n 是HashMap的容量，通常会选择一个2的幂作为容量值（比如16、32、64等），这样可以确保 n - 1 的二进制表示最后m位全是1，得出的结果都是 0 到 n - 1 的范围内。</li>
<li>即：（n-1）&amp;hash &#x3D; hash % n</li>
</ul>
</li>
<li><p>if (p.hash &#x3D;&#x3D; hash &amp;&amp;<br>  ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</p>
<ul>
<li>p.hash &#x3D;&#x3D; hash 检查当前节点 p 的 hash 值是否与待插入节点的 hash 值相等。这是为了确保hash值相同的对象被散列到相同的桶中</li>
<li>由于HashMap采用了数组+链表&#x2F;红黑树的存储方式来处理哈希冲突，当发生哈希碰撞时，会将具有相同散列码的键值对放入同一个链表或红黑树中。因此，为了检查待插入的键值对是否需要放入已有的链表或红黑树中，就需要通过比较散列码来确认它们是否应该放在同一个桶中。</li>
<li>如果 p.hash 和 hash 不相等，那么说明待插入的键值对与已有的键值对散列码不同，它们不应该放在同一个桶中，因此就不需要执行后续的键相等性检查。</li>
<li>((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))) 则是用来检查键是否已经存在。在这里，首先将当前节点 p 的键存储在临时变量 k 中，然后与待插入键 key 进行比较。</li>
<li>k &#x3D;&#x3D; key 检查两个键是否是同一对象的引用。如果是，则说明键已经存在于 HashMap 中。</li>
<li>(key !&#x3D; null &amp;&amp; key.equals(k)) 是更一般化的检查。首先确保待插入键不为 null，然后调用待插入键的 equals 方法来检查是否与当前节点 p 的键相等。这是因为即使两个键不是同一对象的引用，但如果它们在逻辑上相等，则也应视为键已存在于 HashMap 中，会动态绑定调用要比较对象类内的equals方法</li>
</ul>
</li>
</ul>
</li>
<li><p>HashSet扩容机制：523-524节</p>
<ul>
<li><p>HashSet底层是HashMap，扩容机制主要在HashMap的resize方法中。- 第一次添加时，table数组扩容到16，临界值（threshold）&#x3D; 16 * 加载因子</p>
<ul>
<li>static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4; &#x2F;&#x2F; aka 16</li>
<li>static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;</li>
</ul>
</li>
<li><p>如果<strong>table中加入节点总元素个数</strong>，到了临界值12，就会扩容到16 * 2 &#x3D; 32，新的临界值就是32 * 0.75 &#x3D; 24， 以此类推</p>
</li>
<li><p>在添加节点的过程中，若是某个链表长度达到了8，则进入treeifyBin函数，判断<strong>table数组长度</strong>是否大于64，若否，则将该数组扩容两倍，若是则将该链表树化</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>上述三个HashSet添加元素例子分析：  </p>
<ul>
<li>判断标准：if (p.hash &#x3D;&#x3D; hash &amp;&amp;<br>  ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</li>
</ul>
<ol>
<li><p>两次加入的”hello”字符串都是存放在常量池中的同一对象，</p>
<ul>
<li>判断1 ：两次加入是同一对象，hash一定相同，为true</li>
<li>判断2 ：两次加入对象实际就是同一个对象，为true，故上诉判断语句结果为true，无法加入</li>
</ul>
</li>
<li><p>两次加入的是属性name相同的不同的Book对象，</p>
<ul>
<li>Book类没有重写hashCode方法，Object中hashCode方法是根据对象的地址来运算得到的，这里是不同对象，hash值不同，故求出的对应索引位置也不同，两个Book对象会加入table数组的不同索引位置后</li>
</ul>
</li>
<li><p>两次加入的是储存字符序列相同的String对象</p>
<ul>
<li><p>判断1 ：此处会动态绑定调用String重写的hashCode方法，内容完全相同的字符串返回的hashCode值一定相同，结果为true</p>
</li>
<li><p>判断2 ：两次加入的String对象是存放在堆中的不同对象，结果为false</p>
</li>
<li><p>判断3：两个String对象进行equals判断，这里会动态调用要判断对象类型的equals函数，String类中重写了Object中的equals函数，判断标准是两个String的内容是否完全相同，结果为true</p>
</li>
<li><p>结果为（true&amp;&amp;（false||true）） &#x3D; （true&amp;&amp;true） &#x3D; true，在函数最终结果是不能加入</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>总结：</p>
<ul>
<li><p>调用hashCode()方法来计算对象的哈希值从而确定元素的储存位置，重写hashcode()保证内容相同的对象的hashcode值一定相同，在插入HashMap时会被插入到同一索引位置后以进行后续判断</p>
</li>
<li><p>重写equals()保证会根据对象的内容进行判断，防止内容重复对象再次加入HashMap</p>
</li>
<li><p>equals函数和hashCode函数都要重写才能确保能按程序员希望的需求进行正确的判断去重，<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45427600/article/details/113484445">相关解析文章1</a>,<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1910930">相关解析文章2</a></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>​        </p>
<pre><code>- 例题分析：看551节例题分析：分析如下程序输出结果：
    - 这个题还挺恶心的，可以帮助更好了解底层
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//已知Person类按照id和name重写了hashCode和equals方法</span></span><br><span class="line"><span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;AA&quot;</span>) ;</span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1002</span>,<span class="string">&quot;BB&quot;</span>) ;</span><br><span class="line">set.add(p1);</span><br><span class="line">set.add(p2);</span><br><span class="line">p1.name = <span class="string">&quot;CC&quot;</span> ;</span><br><span class="line">set.remove(p1) ;</span><br><span class="line">System.out.println(set);</span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;CC&quot;</span>));</span><br><span class="line">System.out.println(set) ;</span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;AA&quot;</span>));</span><br><span class="line">System.out.println(set) ;</span><br></pre></td></tr></table></figure>
- 提示：注意p1的hashcode值的变化
- 若是没有重写hashCode和equal结果是什么样的？

- 补充：HashMap的table为什么是transient的：
    - [相关内容](https://www.cnblogs.com/xrq730/p/5030920.html)-懒
    - public native int hashCode();
</code></pre>
<h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><ul>
<li><p>LinkedHashSet基本介绍：</p>
<ul>
<li>LinkedHashSet是 HashSet 的子类</li>
<li>LinkedHashSet底层是一个LinkedHashMap，底层维护了一个 <strong>数组 + 双向链表</strong></li>
<li>LinkedHashSet 根据元素的hashCode值来决定元素的储存位置，同时<u>使用双向链表维护元素的次序，这使得元素看起是以插入顺序保存的</u></li>
<li>LinkedHashSet 不允许添加重复元素</li>
<li>LinkedHashSet示例结构图：<br>  <img src="/images/java_base3_12.png" alt="img"></li>
</ul>
</li>
<li><p>源码解读：</p>
<ul>
<li><p>在LinkedHashMap中维护了一个hash表和双向链表（LinkedHashMap有head和tail）</p>
</li>
<li><p>每一个节点有before和after属性，这样可以形成双向链表</p>
</li>
<li><p>在添加一个元素时，先求hash值，再求索引，确定该元素在table的位置，若是成功将该元素添加如table，再将添加的元素加入到双向链表（如果该元素已经存在，不添加，添加原则和hashSet一样）    </p>
<ul>
<li>因为LinkedHashSet是HashSet的子类，在调用add函数添加元素时直接调用父类的add函数，但在其中创建新节点时动态绑定调用了在LinkedHashSet中重写的newNode函数</li>
<li>将新插入hash表节点加入双向链表的代码：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tail.next = newElement;</span><br><span class="line">newElement.pre = tali ;</span><br><span class="line">tail = newElement ;</span><br></pre></td></tr></table></figure></li>
<li>实际添加过程很复杂，自己再debug一遍，写的很NB</li>
</ul>
</li>
<li><p>在第一次添加节点时，直接将数组table扩容到16，tabe是HashMap$Node类型数组，存放的节点是 LinkedHashMap$Entry类型对象</p>
<ul>
<li>LinkedHashMap$Entry 是LinkedHashMap类中的一个静态内部类</li>
<li>LinkedHashMap$Entry 继承了HashMap$Node 类,</li>
<li>LinkedHashMap将传入的数据保存在LinkedHashMap.Entry类对象中</li>
<li>LinkedHashMap.Entry定义源码：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Node&lt;K,V&gt; &#123;</span><br><span class="line">Entry&lt;K,V&gt; before, after;</span><br><span class="line">Entry(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    <span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>这样遍历LinkedHashSet也能确保插入顺序和遍历顺序一致</p>
</li>
</ul>
</li>
</ul>
<h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><ul>
<li><p>TreeSet底层是TreeMap</p>
<ul>
<li><strong>Set的value使用一个常量PRSENT占位，所有set是单列，但底层都是Map</strong></li>
<li>传入Set的对象传入了Map的Key，而Key不能重复，故Set不能加入重复元素<ul>
<li>TreeSet添加元素源码：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m.put(e, PRESENT)==<span class="literal">null</span>;<span class="comment">//这里的m是TreeSet中定义的Map的一个子类的实例对象</span></span><br><span class="line">    <span class="comment">//PERSENT定义：private static final Object PRESENT = new Object();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>当使用TreeSet的无参构造器创建TreeSet时，TreeSet看起来好像仍是无序的</p>
</li>
<li><p>使用TreeSet 提供的一个构造器，传入一个比较器（匿名内部类），Comparator指定排序规则</p>
<ul>
<li><p>例：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TreeSet</span> <span class="variable">treeSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>(<span class="keyword">new</span> <span class="title class_">Comparator</span>()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1 , Object o2)</span>&#123;</span><br><span class="line">        <span class="comment">//按需设置返回值，比如设置按字符串长度排序</span></span><br><span class="line">        <span class="keyword">return</span>  ((String)o1).length - ((String)o2)。length ;</span><br><span class="line">    &#125;<span class="comment">//如之前在Comparator部分说明，这个compare函数会被用作内部排序规则</span></span><br><span class="line">&#125;);</span><br><span class="line">treeSet.add(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">treeSet.add(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">System.out.println(treeSet);<span class="comment">//此处只会输出abcd,因为它把长度相同的字符串都认为是同一个key</span></span><br></pre></td></tr></table></figure></li>
<li><p>在TreeMap源码中 ， 如果加入的Key用传入Comparator的compare方法比较后发现与已有的Key值相同，则return t.setValue(value); </p>
<ul>
<li>从TreeSet加入TreeMap中所有节点的value都相同，相当于没有进行任何操作，该新节点也没有被加入</li>
<li>若是直接用TreeMap类，两次加入节点的Key值相同，return t.setValue(value); 则会使新加入节点的value值替换原有的value值<ul>
<li>例：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TreeMap</span>  <span class="variable">treeMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>(<span class="keyword">new</span> <span class="title class_">Comparator</span>()&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1 , Object o2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  ((String)o1).length() - ((String)o2).length() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">treeMap.put(<span class="string">&quot;hah&quot;</span>,<span class="string">&quot;123&quot;</span>);</span><br><span class="line">treeMap.put(<span class="string">&quot;hii&quot;</span> , <span class="string">&quot;234&quot;</span>);<span class="comment">//比较器认为两个对象Key相同，value被新的value替换</span></span><br><span class="line">System.out.println(treeMap);<span class="comment">//此处会输出&#123;hah=234&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>跟踪代码，发现用TreeSet默认构造器构造器TreeSet时，Comparator置为NULL，若Comparator为NULL，进行排序判断时会动态绑定使用 Key 对象类的compareTo方法进行元素的排序，而并不是完全的无序</p>
</li>
<li><p>下列代码，出现异常，分析原因</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TreeSet</span> <span class="variable">treeSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>() ;</span><br><span class="line">treeSet.put(<span class="keyword">new</span> <span class="title class_">Person</span>());</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>具体情况可查看543，544节，或跟踪TreeSet 的源码</p>
</li>
<li><p>前面在Arrays.sort()中有类似例子，问题在于Person类没有实现Comparable接口</p>
</li>
</ul>
</li>
</ul>
<h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><ul>
<li><p>Map类基本简介</p>
<ul>
<li><p>Map是双列集合的根接口， 它的每个元素都包含一个键对象(key)和值对象(Value),键和值对象之间存在一种对应关系，称为映射，从Map集合中访问元素时，可以通过指定的key找到对应的value。</p>
</li>
<li><p>Map接口的主要实现类有HashMap，TreeMap等</p>
</li>
</ul>
</li>
<li><p>Map接口特点：</p>
<ul>
<li><p>Map用于保存具有映射关系的数据：Key——Value ，Key和value之间存在<strong>单向一对一</strong>关系，即通过指定的key总能找到对应的value</p>
<ul>
<li>key 可以看做时value的“身份证号”，根据key就一定可以找到它对应的唯一的value（姓名）</li>
<li>但不同的key可以有相同的value值</li>
</ul>
</li>
<li><p>Map中<u>key和value可以是任何引用类型的数据</u>，<strong>会封装到HashMap$Node对象中</strong></p>
</li>
<li><p>Map中的<strong>Key是唯一的</strong>，可以为null,，不允许重复，原因如上在HashSet中的分析</p>
<ul>
<li>但是当有相同的key，不同value的节点加入时，会以新加入的节点(value)替换原节点(value)</li>
<li>即键相同，值覆盖；</li>
</ul>
</li>
<li><p>Map中的value可以为null，可以重复</p>
<ul>
<li>例如在HashSet底层是HashMap，就利用该特点，在向HashMap中加入节点时，传入的Key为要插入的对象，value为HashSet中的静态Object变量PRESENT</li>
<li>HashSet的add函数：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;<span class="comment">//所有加入节点都是PRESENT，即所有节点value值都相同</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//PRESENT定义：</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>HashMap为了方便遍历还会创建EntrySet集合，该集合存放元素类型为Entry,而HashMap$Node实现了Entry接口，故Entry类集合可以存放Node类型节点</p>
<ul>
<li><p>final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt;</p>
</li>
<li><p>Entry接口</p>
<ul>
<li>Entry 是一个Map接口中的内部接口类</li>
<li>把HashMap$Node对象存放在entrySet中。 EntrySet中存放了Entry类的引用，这些引用指向HashMap中的Node节点</li>
<li>Entry接口提供了getKey()和getValue()方法</li>
</ul>
</li>
<li><p><strong>Map接口没有迭代器，无法直接遍历Node，这时需要通过转变为Set集合，获取到Iterator对象才能方便遍历</strong></p>
</li>
</ul>
</li>
<li><p>结构图：（真难画（；——_——））<br>   <img src="/images/java_base3_13.png" alt="img"></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39736597/article/details/113762355">Entry相关</a>,或重新看531-534节</p>
</li>
</ul>
</li>
<li><p>Map接口常用方法</p>
<ul>
<li>put:添加</li>
<li>remove：根据键值删除映射关系</li>
<li>get：根据key获取value</li>
<li>size : 获取元素的个数</li>
<li>isEmpty：判断元素个数是否为0</li>
<li>clear：清除</li>
<li>containsKey：查看键是否存在</li>
</ul>
</li>
<li><p>Map接口遍历方法</p>
<ul>
<li><p>相关方法：</p>
<ul>
<li>containskey():查找键是否存在</li>
<li>keySet(): 获取所有的键</li>
<li>values():获取所有的值</li>
<li>entrySet()：获取储存在Map中所有映射的set集合<ul>
<li>Entry是Map接口的内部接口</li>
</ul>
</li>
</ul>
</li>
<li><p>方式一 ：取出所有Key，通过Key取出对应的Value</p>
<ul>
<li>增强for  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Set</span> <span class="variable">keySet</span> <span class="operator">=</span> map.keySet();</span><br><span class="line"><span class="keyword">for</span>(Object key : keySet)&#123;</span><br><span class="line">    System.out.println(key + <span class="string">&quot;-&quot;</span> + map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>迭代器  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> keyset.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next() ;</span><br><span class="line">    System.out.println(key + <span class="string">&quot;-&quot;</span> + map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>方式二：把所有的value取出</p>
<ul>
<li>增强for  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">values</span> <span class="operator">=</span> map.values();</span><br><span class="line"><span class="keyword">for</span>(Object value : values)&#123;</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>迭代器  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> values.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>方式三：<strong>通过EntrySet来获取k-v</strong></p>
<ul>
<li>通过Map。Entry的setValue来改变value值</li>
<li>增强for  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> map.entrySet() ;</span><br><span class="line"><span class="keyword">for</span>(Object entry : entrySet)&#123;</span><br><span class="line">    Map.<span class="type">Entry</span> <span class="variable">temp</span> <span class="operator">=</span> (Map.Entry)entry;</span><br><span class="line">    temp.getKey();</span><br><span class="line">    temp.getValue();</span><br><span class="line">    System.out.println(temp.getClass());<span class="comment">//运行类型是HashMap$Node-&gt;实现Map.Entry(getValue(),getKey())</span></span><br><span class="line">    <span class="comment">//但HashMap$Node是default访问权限，无法访问到，故将其从Object类型强转为Map.Entry类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>迭代器原理同上</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><ul>
<li><p>HashMap小结：</p>
<ul>
<li>Map接口的常用实现类：HashMap，Hashtable和Properties</li>
<li>HashMap是Map接口使用频率最高的实现类</li>
<li>HashMap是以key-value对的方式来储存数据<ul>
<li>（k-v）是一个HashMap$Node，实现了Map.Entry，</li>
</ul>
</li>
<li>key不能重复，但是值可以重复，允许使用null键和null值</li>
<li>如果添加相同的key，会覆盖原来的key-value，修改value值</li>
<li>与HashSet一样，不保证顺序，底层是以hash表的方式来储存的<ul>
<li>jdk8 ， HashMap底层 数组 + 链表 + 红黑树</li>
</ul>
</li>
<li>HashMap没有实现同步，因此是线程不安全的，方法没有做同步互斥的操作，即没有synchronized</li>
</ul>
</li>
<li><p>源码解析</p>
<ul>
<li><p>绝大部分同上述在HashSet中分析的：<br>   <img src="/images/java_base3_14.png" alt="img"></p>
</li>
<li><p>添加机制</p>
</li>
<li><p>扩容机制：</p>
<ul>
<li>当HashMap中的元素个数超过临界值时会自动触发扩容</li>
<li>临界值(threashold) &#x3D; 负载因子(loadFactor) * 容量大小(capacity)</li>
<li>容量大小默认是16 ，负载因子默认大小是0.75，当元素超过12时或扩容为原来的两倍大小</li>
<li>由于动态扩容机制的存在，实际应用里需要注意，集合初始化时最好要明确指定集合的大小，避免频繁扩容带来的性能上的影响（比如需要向HashMap中添加1024个元素，在默认容量W为16的情况下完成扩容需要扩容七次，在扩容过程中需要创建新的hash表并且完成数据的迁移，对性能影响极大）</li>
<li>负载因子是0.75原因：负载因子表示Hash表中元素的填充程度，负载因子值越大意味着触发扩容的元素数量会更大，虽然整体的空间利用率较高，但是发生Hash冲突的概率也会增加，负载因子的值的设置就是冲突概率和对空间利用率之间的平衡。0.75与泊松分布相关，当负载因子为0.75时，链表长度几乎不可能达到8，达到了空间成本和时间成本的平衡</li>
</ul>
</li>
<li><p>debug追踪，看537节</p>
</li>
</ul>
</li>
</ul>
<h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><ul>
<li><p>基本介绍：</p>
<ul>
<li>Hashtable实现了Map接口</li>
<li>存放的元素的键值对：K-V</li>
<li><u>Hashtable的键和值都不能为null</u>,发生NullPointerException</li>
<li>Hashtable使用方法基本上和HashMap一样</li>
<li>Hashtable是线程安全的（synchronized），HashMap是线程不安全的</li>
<li>Hashtable效率太低，存取元素时速度很慢，基本不使用，常用HashMap</li>
</ul>
</li>
<li><p>源码解读 - 看539  </p>
<ul>
<li>扩容机制：<br>  int newCapacity &#x3D; (oldCapacity &lt;&lt; 1) + 1;</li>
</ul>
</li>
</ul>
<h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><ul>
<li>基本介绍：<ul>
<li>Properties类继承自Hashtable类并且实现了Map接口，也是使用键值对的形式来保存数据</li>
<li>使用特点和Hashtable类似</li>
<li>Properties还可以从 xxx.properties 文件中加载数据到Properties类对象，并进行读取和修改</li>
<li>说明：xxx.properties 文件常作为配置文件，与IO流相关内容相关，<a target="_blank" rel="noopener" href="https://www.cnblogs.com/xudong-bupt/p/3758136.html">相关文章</a></li>
</ul>
</li>
</ul>
<h2 id="集合总结"><a href="#集合总结" class="headerlink" title="集合总结"></a>集合总结</h2><ul>
<li><p>在开发中根据实际业务需求和集合实现类特性选择要使用的集合实现类</p>
</li>
<li><p>分析：</p>
<ul>
<li><p>先判断储存的数据类型</p>
</li>
<li><p>若存储一组对象：Collection接口</p>
<ul>
<li><p>允许重复：List</p>
<ul>
<li>增删多：LinkedList（底层维护了一个双向链表）</li>
<li>改查多：ArrayList（底层维护了一个Object类型的可变数组，线程不安全）</li>
</ul>
</li>
<li><p>不允许重复：Set</p>
<ul>
<li>无序：HashSet（底层是HashMap，维护了一个哈希表，即数组加链表加红黑树）</li>
<li>排序：TreeSet（底层是TreeMap）</li>
<li>插入和取出顺序一致 ： LinkedHashSet（底层是LinkedHashMap，维护了数组+双向链表）</li>
</ul>
</li>
</ul>
</li>
<li><p>若存储一组键值对： Map</p>
<ul>
<li>键无序： HashMap</li>
<li>键排序：TreeMap</li>
<li>键插入和取出顺序一致：LinkedHashMap</li>
<li>读取文件：Properties</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h2><ul>
<li><p>Collections是一个操作Set ，List和Map等集合的工具类</p>
</li>
<li><p>Collection是中提供了一系列的静态方法对集合元素进行排序，查询和修改等操作</p>
<ul>
<li><p>reverse(List):反转List中元素的顺序</p>
</li>
<li><p>shuffle(List):对List集合进行随机排序</p>
</li>
<li><p>sort(List)：根据元素的自然顺序对List集合元素按升序排序</p>
</li>
<li><p>sort(List ,Comparator)：根据指定的Comparator产生的顺序对List集合元素进行排序</p>
</li>
<li><p>swap(List , int i , int j)：将指定list集合中i处元素和j处元素进行交换</p>
</li>
<li><p>Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素</p>
</li>
<li><p>Object max(Collection , Comparator):根据Comparator执行的顺序，返回给定集合中的最大元素</p>
<ul>
<li>类似的还有min方法</li>
</ul>
</li>
<li><p>int frequency(Collection ,Object):返回指定集合中指定元素的出现次数</p>
</li>
<li><p>void copy(List dest,List src):将src中的内容复制到dest中</p>
</li>
<li><p>boolean replaceAll(List list,Object oldVal,Object newVal):使用新值替换List对象的所有旧值</p>
</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://pengzhanyi.github.io">zhanyi peng</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://pengzhanyi.github.io/2023/09/24/java-base3/">https://pengzhanyi.github.io/2023/09/24/java-base3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://pengzhanyi.github.io" target="_blank">Blog | kaori</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a></div><div class="post_share"><div class="social-share" data-image="/images/java_base3_03.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/09/26/data-structure/" title="数据结构"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">数据结构</div></div></a></div><div class="next-post pull-right"><a href="/2023/09/19/java_base2/" title="java基础——面向对象基础"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">java基础——面向对象基础</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/11/24/JavaWeb/" title="JavaWeb"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-24</div><div class="title">JavaWeb</div></div></a></div><div><a href="/2023/09/17/java-base/" title="java基础语法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-17</div><div class="title">java基础语法</div></div></a></div><div><a href="/2023/10/20/java-base4/" title="java基础- 基于面向对象的应用_2"><img class="cover" src="/images/java_base3_03.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-20</div><div class="title">java基础- 基于面向对象的应用_2</div></div></a></div><div><a href="/2023/09/19/java_base2/" title="java基础——面向对象基础"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-19</div><div class="title">java基础——面向对象基础</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head_sculpture.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">zhanyi peng</div><div class="author-info__description">"人生就是在欲望不满的痛苦和欲望满足后的厌倦之间，像钟摆一样地来回摆动"</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.</span> <span class="toc-text">枚举和注解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">1.1.</span> <span class="toc-text">枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0%E6%9E%9A%E4%B8%BE"><span class="toc-number">1.1.1.</span> <span class="toc-text">自定义实现枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#enum%E5%85%B3%E9%94%AE%E5%AD%97%E5%AE%9E%E7%8E%B0%E6%9E%9A%E4%B8%BE"><span class="toc-number">1.1.2.</span> <span class="toc-text">enum关键字实现枚举</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.2.</span> <span class="toc-text">注解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">异常和异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">2.1.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E6%9C%BA%E5%88%B6try-catch"><span class="toc-number">2.1.1.</span> <span class="toc-text">简单的异常捕获机制try-catch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8"><span class="toc-number">2.1.2.</span> <span class="toc-text">常见的运行时异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%BC%82%E5%B8%B8"><span class="toc-number">2.1.3.</span> <span class="toc-text">编译异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">2.2.</span> <span class="toc-text">异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#try-catch-finally"><span class="toc-number">2.2.1.</span> <span class="toc-text">try-catch-finally</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#throws"><span class="toc-number">2.2.2.</span> <span class="toc-text">throws</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">2.3.</span> <span class="toc-text">自定义异常</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-number">3.</span> <span class="toc-text">常用类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">3.1.</span> <span class="toc-text">包装类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E7%B1%BB"><span class="toc-number">3.2.</span> <span class="toc-text">String类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#String-%E5%9F%BA%E7%A1%80"><span class="toc-number">3.2.1.</span> <span class="toc-text">String 基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E5%88%9B%E5%BB%BA%E6%9C%BA%E5%88%B6"><span class="toc-number">3.2.2.</span> <span class="toc-text">String创建机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.3.</span> <span class="toc-text">String类常用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringBuffer%E7%B1%BB"><span class="toc-number">3.3.</span> <span class="toc-text">StringBuffer类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringBuilder%E7%B1%BB"><span class="toc-number">3.4.</span> <span class="toc-text">StringBuilder类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-%EF%BC%8C-StringBuffer-%EF%BC%8C-StringBuilder%E6%AF%94%E8%BE%83"><span class="toc-number">3.5.</span> <span class="toc-text">String ， StringBuffer ， StringBuilder比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Math%E7%B1%BB"><span class="toc-number">3.6.</span> <span class="toc-text">Math类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Arrays%E7%B1%BB"><span class="toc-number">3.7.</span> <span class="toc-text">Arrays类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#System%E7%B1%BB"><span class="toc-number">3.8.</span> <span class="toc-text">System类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BigInteger%E5%92%8CBigDecimal%E7%B1%BB"><span class="toc-number">3.9.</span> <span class="toc-text">BigInteger和BigDecimal类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="toc-number">3.10.</span> <span class="toc-text">日期类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Date"><span class="toc-number">3.10.1.</span> <span class="toc-text">Date</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Calendar"><span class="toc-number">3.10.2.</span> <span class="toc-text">Calendar</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E4%BB%A3%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="toc-number">3.10.3.</span> <span class="toc-text">第三代日期类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">4.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E6%A1%86%E6%9E%B6%E4%BD%93%E7%B3%BB"><span class="toc-number">4.1.</span> <span class="toc-text">集合的框架体系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection-%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.2.</span> <span class="toc-text">Collection 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#List-%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.2.1.</span> <span class="toc-text">List 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">ArrayList底层结构和源码分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vector-%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%92%8C%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-number">4.2.1.2.</span> <span class="toc-text">Vector 底层结构和源码剖析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedList-%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%92%8C%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-number">4.2.1.3.</span> <span class="toc-text">LinkedList 底层结构和源码剖析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList%E5%92%8CLinkedList%E6%AF%94%E8%BE%83"><span class="toc-number">4.2.1.4.</span> <span class="toc-text">ArrayList和LinkedList比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set"><span class="toc-number">4.2.2.</span> <span class="toc-text">Set</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HashSet"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">HashSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedHashSet"><span class="toc-number">4.2.2.2.</span> <span class="toc-text">LinkedHashSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TreeSet"><span class="toc-number">4.2.2.3.</span> <span class="toc-text">TreeSet</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.3.</span> <span class="toc-text">Map接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap"><span class="toc-number">4.3.1.</span> <span class="toc-text">HashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hashtable"><span class="toc-number">4.3.2.</span> <span class="toc-text">Hashtable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Properties"><span class="toc-number">4.3.3.</span> <span class="toc-text">Properties</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93"><span class="toc-number">4.4.</span> <span class="toc-text">集合总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collections%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">4.5.</span> <span class="toc-text">Collections工具类</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/02/reveal-md/" title="reveal-md 的使用">reveal-md 的使用</a><time datetime="2023-12-02T11:40:23.000Z" title="发表于 2023-12-02 19:40:23">2023-12-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/24/JavaWeb/" title="JavaWeb">JavaWeb</a><time datetime="2023-11-24T08:07:15.000Z" title="发表于 2023-11-24 16:07:15">2023-11-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/11/java-base5/" title="java基础编程知识"><img src="/images/java_base3_03.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="java基础编程知识"/></a><div class="content"><a class="title" href="/2023/11/11/java-base5/" title="java基础编程知识">java基础编程知识</a><time datetime="2023-11-10T17:11:07.000Z" title="发表于 2023-11-11 01:11:07">2023-11-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/23/Code-Aesthetic/" title="Code Aesthetic">Code Aesthetic</a><time datetime="2023-10-23T09:11:05.000Z" title="发表于 2023-10-23 17:11:05">2023-10-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/20/java-base4/" title="java基础- 基于面向对象的应用_2"><img src="/images/java_base3_03.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="java基础- 基于面向对象的应用_2"/></a><div class="content"><a class="title" href="/2023/10/20/java-base4/" title="java基础- 基于面向对象的应用_2">java基础- 基于面向对象的应用_2</a><time datetime="2023-10-19T16:15:00.000Z" title="发表于 2023-10-20 00:15:00">2023-10-20</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By zhanyi peng</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>