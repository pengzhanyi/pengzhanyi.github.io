<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>java基础- 基于面向对象的应用 | Blog | kaori</title><meta name="author" content="zhanyi peng"><meta name="copyright" content="zhanyi peng"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[TOC] 枚举和注解枚举 基本介绍：  枚举对应英文enumeration,简写enum 枚举是一组常量的集合 可以理解为枚举属于一种特殊的类，里面只包含一组有限的特定的对象   枚举实现方式  1 自定义实现枚举 2 使用enum关键字实现枚举    自定义实现枚举 自定义枚举类特点 构造器私有化 对枚举对象&#x2F;属性使用final + static 共同修饰，实现底层优化 不需要提供类">
<meta property="og:type" content="article">
<meta property="og:title" content="java基础- 基于面向对象的应用">
<meta property="og:url" content="https://pengzhanyi.github.io/2023/09/24/java-base3/index.html">
<meta property="og:site_name" content="Blog | kaori">
<meta property="og:description" content="[TOC] 枚举和注解枚举 基本介绍：  枚举对应英文enumeration,简写enum 枚举是一组常量的集合 可以理解为枚举属于一种特殊的类，里面只包含一组有限的特定的对象   枚举实现方式  1 自定义实现枚举 2 使用enum关键字实现枚举    自定义实现枚举 自定义枚举类特点 构造器私有化 对枚举对象&#x2F;属性使用final + static 共同修饰，实现底层优化 不需要提供类">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pengzhanyi.github.io/images/java_base3_03.jpg">
<meta property="article:published_time" content="2023-09-24T08:50:40.000Z">
<meta property="article:modified_time" content="2023-10-06T04:28:51.649Z">
<meta property="article:author" content="zhanyi peng">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pengzhanyi.github.io/images/java_base3_03.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://pengzhanyi.github.io/2023/09/24/java-base3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java基础- 基于面向对象的应用',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-06 12:28:51'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Blog | kaori" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head_sculpture.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/java_base3_03.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Blog | kaori"><span class="site-name">Blog | kaori</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java基础- 基于面向对象的应用</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-24T08:50:40.000Z" title="发表于 2023-09-24 16:50:40">2023-09-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-06T04:28:51.649Z" title="更新于 2023-10-06 12:28:51">2023-10-06</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java基础- 基于面向对象的应用"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>[TOC]</p>
<h1 id="枚举和注解"><a href="#枚举和注解" class="headerlink" title="枚举和注解"></a>枚举和注解</h1><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><ul>
<li><p>基本介绍：</p>
<ul>
<li>枚举对应英文enumeration,简写enum</li>
<li>枚举是一组常量的集合</li>
<li>可以理解为枚举属于一种特殊的类，<u>里面只包含一组有限的特定的对象</u></li>
</ul>
</li>
<li><p>枚举实现方式</p>
<ul>
<li>1 自定义实现枚举</li>
<li>2 使用enum关键字实现枚举</li>
</ul>
</li>
</ul>
<h3 id="自定义实现枚举"><a href="#自定义实现枚举" class="headerlink" title="自定义实现枚举"></a>自定义实现枚举</h3><ul>
<li>自定义枚举类特点<ul>
<li>构造器私有化</li>
<li>对枚举对象&#x2F;属性使用final + static 共同修饰，实现底层优化</li>
<li>不需要提供类属性的set方法，因为枚举对象值通常为只读,可以提供get方法</li>
<li>对外暴露枚举对象，<u>设置对象为<strong>public static final</strong></u></li>
<li>枚举对象名通常使用全部大写，常量的命名规范</li>
<li>枚举对象根据需要，也可以有多个属性</li>
</ul>
</li>
<li>例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">private</span> String desc ;<span class="comment">//描述</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name , String desc)</span>&#123;</span><br><span class="line">        <span class="comment">//构造器设置为私有化防止外部直接实例化</span></span><br><span class="line">        <span class="built_in">this</span>.name = name ;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//去掉set方法防止属性被修改</span></span><br><span class="line">    <span class="comment">//在类内部直接创建固定的对象，public static final</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span> , <span class="string">&quot;温暖&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span> , <span class="string">&quot;炎热&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span> , <span class="string">&quot;凉爽&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span> , <span class="string">&quot;寒冷&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>


<h3 id="enum关键字实现枚举"><a href="#enum关键字实现枚举" class="headerlink" title="enum关键字实现枚举"></a>enum关键字实现枚举</h3><ul>
<li><p>实现具体过程</p>
<ul>
<li>使用关键字enum来代替class</li>
<li>public static final 对象名 &#x3D; new 枚举类名（参数列表） 定义枚举变量的方式变为直接用  <strong>变量名（参数列表）</strong></li>
<li>如果有多个常量（对象），使用 ， 间隔即可</li>
<li>如果<strong>使用enum来实现枚举，要求必须将定义常量对象写在类的最前面</strong></li>
<li>例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    Season(<span class="string">&quot;春天&quot;</span> , <span class="string">&quot;温暖&quot;</span>) ,SUMMER (<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;炎热&quot;</span>) ,</span><br><span class="line">    AUTUMN (<span class="string">&quot;秋天&quot;</span> , <span class="string">&quot;凉爽&quot;</span>),WINTER  (<span class="string">&quot;冬天&quot;</span> , <span class="string">&quot;寒冷&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">private</span> String desc ;<span class="comment">//描述</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name , String desc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name ;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name + <span class="built_in">this</span>.desc ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>enum关键字实现枚举注意事项     </p>
<ul>
<li>简化的定义枚举类变量的方式： 变量名（参数列表） 形式，这里必须知道它调用的是哪个构造器</li>
<li>当使用无参构造器创建枚举对象，则实参列表和小括号都可以省略</li>
<li>当有多个枚举对象时，使用 , 间隔，最后一个由分号结尾</li>
<li>枚举类对象必须放在枚举类的行首</li>
</ul>
</li>
<li><p>补充</p>
<ul>
<li><p>输出enum的对象时会调用enum的toString方法，返回该枚举对象名，具体内容可查看Enum类源码 </p>
</li>
<li><p>当使用enum关键字定义类时，这个类会默认继承Enum类，所以子类会获得Enum中的各种方法</p>
<ul>
<li><p>因为已经默认Enum类，因为java的单继承机制，故枚举类不能再继承别的类，但可以实现接口</p>
</li>
<li><p>可以用javap反编译.class文件以显示对应源码中隐藏的细节，通过这种方法来证明，枚举类继承Enum类,而且是一个final类</p>
<ul>
<li><img src="/images/java_base3_01.png" alt="img"></li>
</ul>
</li>
<li><p>或在idea中利用Ctrl + Alt + U来查看类的继承关系</p>
<ul>
<li><img src="/images/java_base3_02.png" alt="img"></li>
</ul>
</li>
</ul>
</li>
<li><p>enum类常用方法</p>
<ul>
<li>toString：Enum类已经重写过了，返回当前对象名，子类可以根据需要重写方法</li>
<li>name ： 返回当前对象名（常量名），是final的方法，子类中不能重写</li>
<li>ordinal :返回当期那对象的位置号，默认从0开始</li>
<li>values:返回当前枚举类中的所有常量<ul>
<li>隐藏起来了，在反编译中可以查看到，返回类型为该枚举类的数组</li>
</ul>
</li>
<li>valueOf：返回具有指定名称的指定枚举类型的枚举常量，要求字符串必须为已有的常量名，否则报异常<ul>
<li>就是在已有的枚举常量对象中寻找，并不会创建新的枚举对象</li>
</ul>
</li>
<li>compareTo ： 比较两个枚举常量，比较的就是位置号 </li>
<li>例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">season</span>&#123;</span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>) ， SUMMER(<span class="string">&quot;夏天&quot;</span>) ，AUTUMN(<span class="string">&quot;秋天&quot;</span>) ,WINTER(<span class="string">&quot;冬天&quot;</span>);</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showElements</span><span class="params">()</span>&#123;</span><br><span class="line">        Season[] array = Season.values();</span><br><span class="line">        <span class="comment">//使用values方法获得枚举类数组</span></span><br><span class="line">        <span class="keyword">for</span>(Season element : array)&#123;</span><br><span class="line">            System.out.println(element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name + <span class="built_in">this</span>.desc ;</span><br><span class="line">        <span class="comment">//根据需要重写toString方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><ul>
<li><p>注解介绍</p>
<ul>
<li><p>注解（Annotation）也被称为元数据（Metadata），用于修饰解释，包，类，方法，属性，构造器局部变量等数据信息</p>
</li>
<li><p>和注释一样，注解不影响程序逻辑，但注解可以被编译运行，相当于嵌入在代码中的补充信息</p>
</li>
<li><p>在JavaSE中，，注解的使用目的很简单，例如标记过时的功能，忽略警告等。但在javaEE中，注解很重要，例如用来配置应用程序的任何切面，代替javaEE旧版所一流的繁荣代码和XML配置等</p>
</li>
</ul>
</li>
<li><p>基本的Annotation介绍：  </p>
<ul>
<li>在使用注解时要在其前面增加@符号，并把该Annotation当成一个修饰符使用。用于修饰它支持的程序元素.</li>
<li>注解的作用在于编译器会根据注解的内容进行语法校验<ul>
<li>例如若在方法前加上@override，则在编译时，编译器回去检查该方法是否时真的是重写了父类中的函数或实现接口中的函数，若没有，则编译不能通过</li>
</ul>
</li>
</ul>
</li>
<li><p>三种基本注解类型</p>
<ul>
<li><p>@Override : 限定某个方法，表示重写父类方法，该注释只能用于方法</p>
<ul>
<li>@Override表示指定重写父类的方法（从编译层面验证），</li>
<li>若布鞋@Override注解，而父类有public的同名同返回类型的方法，仍然构成重写</li>
<li>@Override只能修饰方法，不能修饰类，包，属性等</li>
<li>查看@Override的源码为： @Target(ElementType.METHOD)，表示只能修饰方法</li>
<li>@Target是修饰注解的注解，称为元注解</li>
</ul>
</li>
<li><p>@Deprecated: 用于表示某个程序元素（类，方法）已经过时</p>
<ul>
<li>表示该类，方法，元素已过时，不推荐使用，但仍可以使用</li>
<li>可以做到新旧版本的兼容和过度</li>
</ul>
</li>
<li><p>@SuppressWarnings:抑制编译器警告</p>
<ul>
<li>当不希望看到警告时可以用@SuppressWarings</li>
<li>使用方法： @SuppressWarnings({ “ “}),在其中写入希望抑制的警告信息<ul>
<li>例：抑制所有警告 @SuppressWarings( { “ all “ } )</li>
<li>具体的警告类型可以自己查询 ， 例如”unused” , “unchecked”</li>
<li>@SuppressWarings 范围与放置的位置相关，可以放在类前，方法前等</li>
</ul>
</li>
<li>查看源码，该注解类有字符串数组参数String[] value(),用于输入多个警告信息</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>查看Override源码， @interface表示是一个注解，而不是接口</p>
</blockquote>
<ul>
<li><p>元注解<br>JDK的元Annotation用于修饰其他Annotation<br>元注解作用不大，了解即可，可多看源码</p>
<ul>
<li>元注解的种类<ul>
<li><p>Retention &#x2F;&#x2F;指定注解的作用范围，三种 SOURCE，CLASS，RUNTIME</p>
<ul>
<li>例如@Override的作用域在SOURCE，当编译器编译时生效，不会写入.class文件，也不会在Runtime（运行时）生效</li>
</ul>
</li>
<li><p>Target &#x2F;&#x2F;指定注解可以在哪些地方使用</p>
<ul>
<li>@Override的 @Target(ElementType.METHOD)，只能作用于方法</li>
<li>@SuppressWarings 的@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE}) ，可作用方法，变量等</li>
</ul>
</li>
<li><p>Document &#x2F;&#x2F;指定注解是否在javadoc中体现</p>
<ul>
<li>注解中加入@Documented 表示该注解会被保存在javadoc文档中</li>
</ul>
</li>
<li><p>Inherited &#x2F;&#x2F;子类会继承父类注解</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="异常和异常处理"><a href="#异常和异常处理" class="headerlink" title="异常和异常处理"></a>异常和异常处理</h1><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul>
<li><p>基本概念</p>
<ul>
<li>java语言中，将程序执行中发生的不正常情况称为“异常” ，</li>
<li>注意：开发过程中的语法错误和逻辑错误不是异常</li>
</ul>
</li>
<li><p>执行过程中的异常事件主要分为两类</p>
<ul>
<li><p>Error（错误）：java虚拟机无法解决的严重的问题，例如JVM系统内部错误，资源耗尽的严重情况。如StackOverflowError[栈溢出] ，Error是严重错误，程序会崩溃</p>
</li>
<li><p>Exception : 其他因编程错误或偶然外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如NullPointerException[空指针访问] 等</p>
<ul>
<li>Exception可以分为两大类<ul>
<li><p><strong>运行时异常</strong> ，程序运行时发生的异常，</p>
</li>
<li><p><strong>编译时异常</strong> ， 编译时，编译器检查出的异常</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>异常体系图</p>
<ul>
<li><p>下列图中列举一些常见异常的继承关系图</p>
<ul>
<li>注，绿色虚线代表实现接口，蓝色实线代表类的继承</li>
</ul>
</li>
<li><p><img src="/images/java_base3_04.png" alt="img"></p>
</li>
<li><p>总结 ：</p>
<ul>
<li><p>异常分为两大类，运行时异常和编译时异常</p>
</li>
<li><p>运行时异常，编译器不要求强制处理的异常。一般是指编程时的逻辑错误，以程序员应该避免其出现的异常。java.lang.RuntimeException类及他的子类都是运行时异常</p>
</li>
<li><p>编译时异常是编译器要求必须处理的异常</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="简单的异常捕获机制try-catch"><a href="#简单的异常捕获机制try-catch" class="headerlink" title="简单的异常捕获机制try-catch"></a>简单的异常捕获机制try-catch</h3><ul>
<li><p>对异常进行捕获，保证程序在遇到异常仍可以继续运行，不会直接崩溃保证程序健壮性</p>
</li>
<li><p>当程序员认为一段代码可能出现异常时，可以用try-catch异常处理机制来解决问题</p>
</li>
<li><p>try-catch异常处理机制</p>
<ul>
<li><p>语法：  </p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;<span class="comment">/*可能产生异常的代码*/</span>&#125;</span><br><span class="line">    <span class="keyword">catch</span>(Typel id1)</span><br><span class="line">    &#123;<span class="comment">/*处理Typel异常的代码*/</span>&#125;</span><br><span class="line">    <span class="keyword">catch</span>(Type2 id1)</span><br><span class="line">    &#123;/处理Type2异常的代码*/&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在idea中，选中代码块， 快捷键 Ctrl + Alt + t ， 选中try - catch</strong></p>
</li>
<li><p>示例：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num3</span> <span class="operator">=</span> num1 / num2 ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception e)</span><br><span class="line">    &#123;<span class="comment">/*处理Typel异常的代码*/</span></span><br><span class="line">        e.printStackTrace();<span class="comment">//打印异常相关信息</span></span><br><span class="line">        System.out.println(e.getMessage);<span class="comment">//打印出现异常的原因</span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="常见的运行时异常"><a href="#常见的运行时异常" class="headerlink" title="常见的运行时异常"></a>常见的运行时异常</h3><ul>
<li><p>NullPointerException空指针异常</p>
<ul>
<li>当应用程序试图在需要对象的地方使用NULL时，抛出该异常</li>
<li>例: <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object[] array = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">10</span>];</span><br><span class="line">System.out.println(array[<span class="number">1</span>].getClass());</span><br><span class="line"><span class="comment">//创建对象数组时，记得要将数组内每个对象引用都初始化指向实例对象</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>ArithmeticException数学运算异常</p>
<ul>
<li>当出现异常的运算条件时，抛出此异常，如将一个整数除以零</li>
</ul>
</li>
<li><p>ArrayIndexOutOfBoundsException数组下标越界异常</p>
<ul>
<li>用非法索引访问数组时抛出的异常，如果索引为负或大于等于数组大小，则该索引为非法索引</li>
</ul>
</li>
<li><p>ClassCastException类型转换异常</p>
<ul>
<li>当试图将对象强制转换为不是实例的子类时，抛出该异常</li>
<li>例  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="comment">//main方法中：</span></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> (B) a ;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>NumberFormatException数字格式不正常异常</p>
<ul>
<li>当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换Wie适当形式时，抛出该异常，使用时长可以确保我们输入满足条件的字符串</li>
<li>例 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">test</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span> ;</span><br><span class="line">        Integer.parseInt(test);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="编译异常"><a href="#编译异常" class="headerlink" title="编译异常"></a>编译异常</h3><ul>
<li><p>概念 ：编译异常是指在编译期间就必须处理的异常，否则代码不能通过编译</p>
</li>
<li><p>常见的编译异常：</p>
<ul>
<li>SQLException ：操纵数据库时，查询表可能发生异常</li>
<li>IOEException：操纵文件时繁盛的异常</li>
<li>FileNotFound：当操纵一个不存在的文件时，发生异常</li>
<li>ClassNotFoundException：加载类时而该类不存在时，异常</li>
<li>EOFException : 操纵文件，到文件末尾时，发生异常</li>
<li>IIIegalArgumentException:参数异常</li>
</ul>
</li>
</ul>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><ul>
<li><p>基本介绍：<br>异常处理就是当异常发生时，对异常处理的方式</p>
</li>
<li><p>异常处理的方式：  </p>
<ul>
<li>try-catch-finally</li>
<li>throws</li>
</ul>
</li>
</ul>
<h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h3><p>用于程序员捕获在代码中发生异常，自行处理</p>
<ul>
<li><p>语法：   </p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//可能有异常的代码</span></span><br><span class="line"><span class="comment">//当异常发生时将异常封装成Exception对象e,传递给catch </span></span><br><span class="line">&#125;   </span><br><span class="line"><span class="keyword">catch</span> (Type id) &#123; <span class="comment">//这里的Type是指异常的类，可以根据需要填入不同的异常类   </span></span><br><span class="line"><span class="comment">// 得到异常对象后，处理异常 handle exception ，未发现异常则不执行catch中代码 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;    </span><br><span class="line"><span class="comment">//不管是否发现异常，必须执行finally内的代码块，**故通常将释放资源的代码放再finally中**  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>注意事项：</p>
<ul>
<li><p>如果异常发生了，则异常后的代码不会执行，直接进入到catch块</p>
</li>
<li><p>如果异常没有发生，则顺序执行try的代码，不会进入到catch块</p>
</li>
<li><p>如果希望不管是否发生异常，都执行某段代码块（比如关闭连接，释放资源等）则使用finally</p>
</li>
<li><p>可以有多个catch语句，捕获不同的异常（针对不同的异常进行不同的业务处理）</p>
<ul>
<li><strong>如果发生异常只会匹配一个catch</strong></li>
<li><strong>要求父类异常在前，子类异常在后</strong>，比如Exception在后，NullPointerException在前）<ul>
<li>因为父类异常在前，父类exception会捕获所有的子类异常，具体的子类异常处理语句永远无法到达</li>
</ul>
</li>
<li>例：                 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">0</span> ;</span><br><span class="line">&#125; <span class="keyword">catch</span>(NullPointerException e)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是空指针异常&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(ArithmeticException e)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是算数异常&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(RuntimeException e)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;这是运行时异常&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;<span class="comment">//Exception是所有异常的父类</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>可以进行try-finally配合使用，这种用法<strong>相当于没有捕获异常，因此程序会直接崩掉</strong>。</p>
<ul>
<li>应用场景是执行一段代码，不管是否发生异常都必须执行某个业务逻辑，执行完finally内的语句后程序会崩掉</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h3><p> 将发生的异常抛出，交给调用者（方法）来处理，最顶级的处理者就是JVM</p>
<ul>
<li><p>基本介绍：</p>
<ul>
<li>如果一个方法中可能存在某种异常，但是斌不能确定如何处理这种异常，则此方法声明应该显示地声明抛出异常，表明方法将不对这些异常进行处理，而<strong>由该方法的调用者负责</strong><ul>
<li>在方法声明中用throws语句可以声明抛出异常的列表，即抛出多个异常</li>
<li>throws后面的异常类型可以是方法中产生的具体异常类型，也可以是该异常类型的父类</li>
</ul>
</li>
</ul>
</li>
<li><p>基本语法 ：<br>  方法修饰符 + 方法名（） + throws + 该函数中出现的异常{}</p>
<ul>
<li>例：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Func</span> <span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">    <span class="comment">//这里可以直接抛出具体的异常，也可以是该异常的父类Exception</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;C:// aa.txt&quot;</span>);</span><br><span class="line">&#125;<span class="comment">//使用throws，抛出异常，让调用Func方法的调用者处理</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>throws使用细节</p>
<ul>
<li><p>对于编译异常，程序中必须处理，如try-catch或throws</p>
</li>
<li><p><strong>对于运行时异常</strong>，程序中如果没有处理，<u>默认就是throws的方式处理</u></p>
<ul>
<li>运行时异常可以不处理，java不强制要求处理，因为运行时异常有默认处理机制</li>
</ul>
</li>
<li><p>在throws过程中，如果有方法 try-catch ，就相当于处理，就可以不必throws</p>
</li>
<li><p>子类重写父类方法时，对抛出的异常的规定：子类重写的方法，所抛出的异常类型要么和父类抛出的异常一致，要么为父类抛出的异常的类型的子类型 </p>
<ul>
<li>即<strong>子类重写的抛出的异常的类型范围不能大于父类异常</strong> </li>
<li>父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出</li>
<li>例  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;<span class="comment">//发生编译错误</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Father</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            a.method();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RunTimeException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> <span class="keyword">throws</span> RuntimeException&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>解析：<ul>
<li>1 因为java的多态机制，在main方法中a.method()实际会调用Son中重写的method()方法</li>
<li>2 实际在try-catch中时针对父类的method方法做出的捕获，实际却调用子类的method方法，子类重写的方法抛出的异常是Exception，显然用于捕获父类异常的RunTimeException无法捕获该异常</li>
<li>3 故在java中，子类重写父类的方法时，子类如果选择抛出异常，那么抛出的异常类型不能大于父类的异常类型</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>发生异常时以上两种方案二选一就可，要么在当前函数使用try-catch-finally处理异常，要么继续将异常抛出给调用当前函数的函数让其处理<br>    - 最顶级的异常处理<strong>JVM处理异常的方式是直接输出异常信息，退出程序</strong><br>    - 若无显示处理运行时异常，程序默认采用throws方法</p>
</blockquote>
<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><ul>
<li><p>自定义异常步骤：</p>
<ul>
<li>1 定义类： 自定义异常类名 ，继承Exception或RuntimeException</li>
<li>2 如果继承Exception，一般来说属于编译异常</li>
<li>3 如果继承RuntimeException ， 属于运行异常（一般来说，继承RuntimeException）  <ul>
<li>即把自定义异常做成运行时异常，好处在于可以使用运行时异常的默认处理机制</li>
</ul>
</li>
</ul>
</li>
<li><p>自定义异常使用实例：</p>
<ul>
<li>要求输入一个大于0，小于120的数字，否则抛出异常</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="title function_">MyException</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="comment">//这里的message参数是指该异常相关信息</span></span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main方法中</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">180</span> ;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(num &gt; <span class="number">0</span> &amp;&amp; num &lt; <span class="number">120</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;错啦，数字输入不对&quot;</span>) ;</span><br><span class="line">            <span class="comment">//这里相当于创建一个MyException的匿名对象</span></span><br><span class="line">            <span class="comment">//通过 throw 将异常抛出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>throw 和 throws 的区别</strong></p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>意义</th>
<th>位置</th>
<th>后面跟的东西</th>
</tr>
</thead>
<tbody><tr>
<td>throws</td>
<td>异常处理的一种方式</td>
<td>方法声明处</td>
<td>异常类型</td>
</tr>
<tr>
<td>throw</td>
<td>是手动生成异常对象的关键字</td>
<td>方法体中</td>
<td>异常对象</td>
</tr>
</tbody></table>
<h1 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h1><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><ul>
<li><p>包装类的分类(Wrapper)</p>
<ul>
<li>针对八种基本定义类型的引用类型——包装类</li>
<li>有了类的特点就可以调用类中的方法  </li>
<li>包装类都是Object类的子类，实现了Serializable接口，部分实现了Compareable接口</li>
</ul>
</li>
<li><p>基本包装类：</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>booelan</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
</tbody></table>
</li>
<li><p>包装类和基本数据的转换</p>
<ul>
<li><p>手动装箱和拆箱演示：以int与Integer转化为例</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"><span class="comment">//基本类型——&gt;包装类型[手动装箱]</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> Integer.valueOf(i);<span class="comment">//包装类内置static函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//包装类型——&gt;基本类型[手动拆箱]</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">99</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">j1</span> <span class="operator">=</span> j.intValue() ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自动装箱（JDK5以后）：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">M</span> <span class="operator">=</span> m ;<span class="comment">//自动装箱，底层仍是使用new Integer(m)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2</span>);<span class="comment">//自动拆箱,底层认识使用inValue()方法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>例题：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="literal">true</span> ? <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>) : <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">2.0</span>) ;</span><br><span class="line">System.out.println(obj1) ;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>**注意,此处输出为 1.0 ,并不是 1 。因为<u>三元运算符是一个整体</u>**，其中精度最高的是double，会提升优先级，故1会提升精度为1.0</p>
</blockquote>
</li>
</ul>
</li>
<li><p>包装类和String类型的相互转换</p>
<ul>
<li><p>包装类转String：（以Integer的转换为例）</p>
<ul>
<li>实例：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"><span class="comment">//方案一:字符串拼接</span></span><br><span class="line"><span class="type">String</span> <span class="variable">string1</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span> + num;</span><br><span class="line"><span class="comment">//方案二：调用toString()方法 </span></span><br><span class="line"><span class="type">String</span> <span class="variable">string2</span> <span class="operator">=</span> num.toString();</span><br><span class="line"><span class="comment">//方案三:使用valueOf()方法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">string3</span> <span class="operator">=</span> String.valueOf(num);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>String转包装类：（以Integer的转换为例）</p>
<ul>
<li>实例：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span> ;</span><br><span class="line"><span class="comment">//方案一：使用包装类的parse函数</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">num1</span> <span class="operator">=</span> Integer.parseInt(num);<span class="comment">//此处会发生自动装箱</span></span><br><span class="line"><span class="comment">//方案二：构造器,包装类有多个构造器，可按需调用</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(string);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>一些常用的包装类方法和属性</p>
<ul>
<li>继承Number类的数字相关包装类的MaxValue和MinValue值;</li>
<li>Character.isDigit()判断是不是字母 <ul>
<li>isLetter(),判断是不是字母</li>
<li>isUppercase()判断是不是大写字母 </li>
<li>isLowercase()判断是不是小写字母</li>
<li>toUppercase()转换成大写字母 </li>
<li>toLowercase()转换成小写字母</li>
</ul>
</li>
</ul>
</li>
<li><p>经典例题：Integer的创建方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>) ;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>) ;</span><br><span class="line">System.out.println( a == b) ;</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line">System.out.println( c == d );</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">e</span> <span class="operator">=</span> <span class="number">128</span> ;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">128</span> ;</span><br><span class="line">System.out.println( e == f );</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">128</span> ;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">128</span> ;</span><br><span class="line">System.out.println( x == y );</span><br></pre></td></tr></table></figure></li>
<li><p>第一处对比会输出False，因为创建了两个不同的对象，a,b引用指向不同对象</p>
</li>
<li><p>第二处对比会输出true；</p>
<ul>
<li>1 底层自动装包会使用valueOf()方法</li>
<li>2 查看valueOf()底层源码，发现在值在-127 - 128 时，会从对象数组中直接返回对象，在值不在该范围时才会创建新的对象</li>
<li>3 故此处两个对象引用指向同一个对象，输出true</li>
</ul>
</li>
<li><p>第三处对比会输出False，结合上文介绍，因为128不在设定范围内 故此处会创建两个不同对象。</p>
<ul>
<li>4 只要有基本数据类型，判断的是值是否相等，此处会把包装类自动拆箱。</li>
</ul>
</li>
<li><p>具体内容可查看源码或debug跟踪到底层代码</p>
</li>
</ul>
<h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiuzhublog/p/12823838.html">String类详解文章</a></li>
</ul>
<h3 id="String-基础"><a href="#String-基础" class="headerlink" title="String 基础"></a>String 基础</h3><ul>
<li>String类基本介绍<ul>
<li><p>String对象用于保存字符串，也就是一组字符序列</p>
<ul>
<li>String类实现了Serialzable接口，Comparable接口，CharSequeance接口</li>
<li>实现了Serialzable接口，说明该类可以串行化，该类对象可以在网络上传输</li>
<li>实现了Comparable接口，说明该类对象之间可以相互比较大小</li>
</ul>
</li>
<li><p>字符串是不可变的。一个字符串对象一旦被分配，其内容是不可变的</p>
</li>
<li><p>字符串字符使用Unicode字符编码，<u>一个字符占两个字节</u></p>
</li>
<li><p>String 类常用构造器</p>
<ul>
<li>new String()</li>
<li>new String(String original)</li>
<li>new String(char a[])</li>
<li>new String(byte[] b)</li>
</ul>
</li>
<li><p>String 类是final的类，不可被继承</p>
</li>
<li><p>String中有属性：private final char value[]，用于存放字符串内容</p>
<ul>
<li>这个value数组是final类型 ， 赋值后就不能再修改，即value作为引用的存放的地址不能修改, 也即是value的指向不能再修改 </li>
<li>可查看源码了解</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="String创建机制"><a href="#String创建机制" class="headerlink" title="String创建机制"></a>String创建机制</h3><ul>
<li><strong>创建String对象的两种方式</strong><ul>
<li><p>一 .直接赋值 String s &#x3D; “hello” ;</p>
<ul>
<li>使用直接赋值时 ，会先从常量池查看是否已有”hello”的数据空间，如果有则直接指向该位置 ； 若是没有则在常量池中重新创建，然后指向常量池中该数据位置，故s最终指向仍是常量池的空间</li>
</ul>
</li>
<li><p>二 .调用构造器 String s &#x3D; new String(“abc”);</p>
<ul>
<li><p>这个过程中生成一个或两个对象，取决于常量池是否有该字符串</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1686226">相关解析</a></p>
</li>
<li><p>Object类中对String的解释：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(String original)</span> &#123;<span class="number">3</span></span><br><span class="line">    <span class="built_in">this</span>.value = original.value;</span><br><span class="line">    <span class="built_in">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么不再在字符串常量池创建该字符串对象，在堆中创建String对象，让栈中的String引用变量s管理该String对象，然后堆中String的属性（数组引用）value指向常量池中的数据</p>
</li>
<li><p>如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中，然后进行如上操作。</p>
</li>
<li><p>s最终指向是堆中的空间，(是指向堆中创建的String对象,String对象中的value指向常量池中的数据)</p>
<ul>
<li>故如果new两个String &#x3D; “hello”,则两个String的value数组引用中存放的地址相同，即都指向常量池中的“hello”。</li>
</ul>
</li>
<li><p><img src="/images/java_base3_05.png" alt="img"></p>
</li>
</ul>
</li>
<li><p>补充：String的intern()函数</p>
<ul>
<li><p>当调用intern方法时，如果池已经包含一个等于此String对象的字符串（用equals(Object)方法确定），则返回来自池的字符串。否则，此String对象将添加到池中，并返回对此String对象的引用</p>
</li>
<li><p>即intern()方法最终是返回在常量池中的地址</p>
</li>
<li><p>相关实例：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(a == b);<span class="comment">//T</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>) ;</span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(c == d);<span class="comment">//F</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(a == d.intern());<span class="comment">//T</span></span><br><span class="line">System.out.println(c == d.inter());<span class="comment">//F</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>创建字符串对象例题分析：</p>
<ul>
<li><p>String a &#x3D; “hello” + “abc”;</p>
<ul>
<li>这个过程中创建了一个对象</li>
<li>编译器会做优化，判断创建的常量池对象是否有引用指向</li>
<li>故最终优化为String a &#x3D; “helloabc”；</li>
</ul>
</li>
<li><p>String a &#x3D; “hello” ;<br>String b &#x3D; “abc”;<br>String c &#x3D; a + b ;</p>
<ul>
<li><p>debug跟踪步骤 </p>
<ul>
<li>创建一个StringBulider sb &#x3D; new StringBulider();</li>
<li>执行sb.append(“hello”);</li>
<li>执行sb.append(“abc”);</li>
<li>调用sb.toString()<ul>
<li>这个过程中是创建了新的String对象，以“helloabc”初始化;</li>
<li>StringBulider的toString方法：返回一个在堆中创建的String对象  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Create a copy, don&#x27;t share the array</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(value, <span class="number">0</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在常量池中创建“helloabc”</li>
<li>将该String对象返回给c</li>
</ul>
</li>
</ul>
</li>
<li><p>这个过程创建了五个对象，常量池中有三个</p>
<ul>
<li>StringBulider对象sb</li>
<li>常量池中“hello”</li>
<li>常量池中“abc”</li>
<li>常量池中“helloabc”</li>
<li>一个字符串对象，指向常量池中的helloabc，交给字符串变量c管理</li>
</ul>
</li>
</ul>
</li>
<li><p>总结：</p>
<ul>
<li>String c &#x3D; “hello” + “abc”常量相加，c直接指向池</li>
<li>String c &#x3D; a + b;变量相加， c会指向在堆中创建的String对象</li>
<li>若是常量加变量，则c最终也会指向堆中String对象，该String对象的value指向常量池中的“helloabc”</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="String类常用方法"><a href="#String类常用方法" class="headerlink" title="String类常用方法"></a>String类常用方法</h3><p> String类只能保存字符串常量，每次更新都需要重新开辟空间，效率低，因此java设计者还提供了StringBuffer和StringBuider，注意对字符串操作后返回的是全新的字符串，对原字符串没有任何影响</p>
<ul>
<li><p>length ,获取字符的个数，字符串长度</p>
</li>
<li><p>equals(),判断内容是否相等，区分大小写</p>
</li>
<li><p>equalsIgnoreCase(),忽略大小写判断内容是否相等</p>
</li>
<li><p>indexOf() ,获取字符在字符串中第一次出现的位置索引，索引从零开始，如果没找到，返回-1</p>
</li>
<li><p>lastIndexOf(),获取字符在字符串中最后一次出现的索引，如果没找到，返回-1</p>
</li>
<li><p>substring()，截取指定范围的子串</p>
</li>
<li><p>trim()，截取前后空格</p>
</li>
<li><p>spilt() , 以参数字符串作为标准分割字符串，返回一个字符串数组</p>
</li>
<li><p>charAt:获取某索引出的字符，注意不能使用Str[index]这种方式取出字符串的字符</p>
</li>
<li><p>format：作为输出的模板</p>
<ul>
<li>例：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> String.format(<span class="string">&quot;姓名是%s , 体重是 %.2f&quot;</span>,<span class="string">&quot;hello&quot;</span> , <span class="number">12.012</span>);</span><br><span class="line">System.out.println(info);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> <span class="string">&quot;姓名是%s , 体重是 %.2f&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">info2</span> <span class="operator">=</span> String.format(d,<span class="string">&quot;hello&quot;</span> , <span class="number">12.012</span> )</span><br><span class="line"></span><br><span class="line">System.out.println(info2);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>还有很多字符串函数，根据需要查询</p>
</li>
</ul>
<h2 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h2><ul>
<li><p>基本介绍</p>
<ul>
<li><p>特性</p>
<ul>
<li><p>java.lang.StringBuffer代表可变的字符序列，可以对字符串内容进行增删</p>
</li>
<li><p>很多方法与String相同，但StringBuffer是可变长度的</p>
</li>
<li><p>StringBuffer是一个容器</p>
</li>
</ul>
</li>
<li><p>结构剖析</p>
<ul>
<li><p>StringBuffer的直接父类是 <u>抽象类AbstractStringBuilder</u></p>
<ul>
<li>父类中有属性，char[] value ,用于存放字符串内容，因为不是final该value存放在堆中</li>
</ul>
</li>
<li><p>StringBuffer实现了Serializable接口，即可以串行化</p>
</li>
</ul>
</li>
<li><p>StringBuffer的构造器</p>
<ul>
<li><p>StringBuffer()&#x2F;&#x2F;查看源码发现创建一个长度为16的字符数组 用于存放字符内容</p>
</li>
<li><p>StringBuffer(int capacity)&#x2F;&#x2F;创建长度为capacity的字符数组</p>
</li>
<li><p>StringBuffer(String str)&#x2F;&#x2F;以str初始化字符数组，创建长度为str.length + 16 的字符数组</p>
</li>
<li><p>StringBuffer(CharSequence seq)&#x2F;&#x2F;构造一个字符串缓冲区，它包含与指定的CharSequence相同的字符</p>
</li>
</ul>
</li>
<li><p>String 与StringBuffer类对比</p>
<ul>
<li><p>String保存的是字符串常量，里面的值不能更改，每次String类的更新实际上就是更改地址，效率叫低&#x2F;&#x2F;private final char value[]</p>
</li>
<li><p>StringBuffer保存的是字符串常量，里面的值可以更改，每次StringBuffer的更新实际上可以更新内容，不用每次创建新的对象并更新地址，效率高&#x2F;&#x2F;char[] value放在堆中</p>
</li>
</ul>
</li>
<li><p>String与StringBuffer类的相互转换</p>
<ul>
<li><p>String -&gt; StringBuffer</p>
<ul>
<li><p>1 使用StringBuffer的构造器：new StringBuffer(str)</p>
</li>
<li><p>2 先创建一个空的StringBuffer对象，再使用其提供的append函数将字符串添加近这个对象中</p>
</li>
</ul>
</li>
<li><p>StringBuffer-&gt; String</p>
<ul>
<li><p>1 使用StringBuffer提供的toString()方法</p>
</li>
<li><p>2 使用String的构造器在，new String(stringBuffer)</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>StringBuffer常用方法</p>
<ul>
<li><p>增： append() &#x2F;&#x2F;有多个append方法，</p>
</li>
<li><p>删 delete(start , end) &#x2F;&#x2F;</p>
</li>
<li><p>查 indexOf() &#x2F;&#x2F;查找字串在字符串第一次出现的索引如果找不到返回 -1</p>
</li>
<li><p>改 replace(start ， end , string) &#x2F;&#x2F;将start-end中的内容替换掉，<u>且不含end</u></p>
</li>
<li><p>插入 insert()</p>
</li>
<li><p>获取长度length</p>
</li>
</ul>
</li>
<li><p>实例分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">sb.append(str);</span><br><span class="line">System.out.println(sb.length());<span class="comment">//结果为4</span></span><br><span class="line"><span class="comment">//debug跟踪查看源码，底层用到是AbstractStringBuilder的appendNull方法，将null转化为字符串&quot;null&quot;加入字符串中</span></span><br><span class="line"></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(str);</span><br><span class="line"><span class="comment">//此处调用StringBuffer(String str)构造器，会调用str.length ,此处会直接发生异常，抛出NullpointerException</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h2><ul>
<li><p>基本介绍 </p>
<ul>
<li><p>StringBuilder是个可变的的字符序列，此类提供一个与StringBuffer兼容的API，但不保证同步(StringBuilder不是线程安全的)。</p>
</li>
<li><p>该类被设计用作StringBuffer的一个简易替换，<strong>用在字符串缓冲区被单个线程使用的时候</strong></p>
</li>
<li><p>如果可能，建议优先采用该类，在大多数实现中，它比StringBuffer要快</p>
</li>
<li><p>在StringBuilder上的主要操作时append和insert方法，看重载这些方法以接受任何类型的数据</p>
</li>
</ul>
</li>
<li><p>结构剖析</p>
<ul>
<li><p>StringBuilder是final的 ， 不能被继承</p>
</li>
<li><p>StringBuilder继承了AbstractStringBuilder属性char value[],对象的字符序列内容存到该value，故也是存放在堆中</p>
</li>
<li><p>实现了Serializable接口，说明StringBuilder的对象可以串行化（对象可以网络传输，可以保存到文件）</p>
</li>
<li><p>StringBuilder的方法没有做互斥的处理，即没有synchronized关键字，因此最好只在单线程情况下使用StringBuilder</p>
</li>
</ul>
</li>
<li><p>常用方法：与StringBuffer的方法相近，不在赘述，根据需要查看源码和API文档</p>
</li>
</ul>
<h2 id="String-StringBuffer-StringBuilder比较"><a href="#String-StringBuffer-StringBuilder比较" class="headerlink" title="String StringBuffer StringBuilder比较"></a>String StringBuffer StringBuilder比较</h2><ul>
<li><p>String，StringBuilder，StringBuffer非常类似，均代表可变的字符序列，而且方法也大都一样</p>
<ul>
<li><p>String：不可变字符序列，效率低，但是也因其不可变特性，使之非常安全且复用率高。</p>
</li>
<li><p>StringBuffer:可变字符序列，效率较高（增删），是线程安全的（StringBuffer的方法大都使用了synchronized同步）</p>
</li>
<li><p>StringBuilder：可变字符序列，效率最高，但是<u>线程不安全</u></p>
</li>
</ul>
</li>
<li><p><strong>效率：StringBulider &gt; StringBuffer &gt; String</strong></p>
<ul>
<li>验证：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> <span class="number">0L</span> ;</span><br><span class="line">    <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> <span class="number">0L</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span>  <span class="operator">=</span> <span class="string">&quot; &quot;</span>;</span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">70000</span> ; i++)&#123;</span><br><span class="line">        str = str + <span class="string">&quot;i&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    endTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;String的运行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(str);</span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">70000</span> ; i++)&#123;</span><br><span class="line">        sb.append(<span class="string">&#x27;i&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    endTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;StringBuffer的运行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sbd</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">70000</span> ; i++)&#123;</span><br><span class="line">        sbd.append(<span class="string">&#x27;i&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    endTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;StringBuilder的运行时间：&quot;</span> + (endTime - startTime));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>String使用注意：</p>
<ul>
<li>String s &#x3D; “a” ; s +&#x3D; “b”; 实际上原来的”a”字符对象已经丢弃了，现在有创建了一个新的字符串”ab”</li>
<li>如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率，如果这样的操作放到循环中会极大影响程序的性能</li>
<li>故如果要对字符串做大量修改，不要使用String</li>
</ul>
</li>
<li><p>结论：</p>
<ul>
<li>如果字符串存在大量修改操作，用StringBuilder或StringBuffer</li>
<li>如果字符串存在大量修改操作且在单线程情况下，用StringBuilder</li>
<li>如果字符串存在大量修改操作且在多线程情况下，用StringBuffer</li>
<li>如果字符串很少修改，且被多个对象引用，使用String，比如配置信息等</li>
</ul>
</li>
</ul>
<h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><ul>
<li><p>Math的主要运用是其中的static方法，具体用法可根据需要查询API文档或查看源码</p>
<ul>
<li><p>abs（求绝对值）</p>
</li>
<li><p>pow（求幂）</p>
</li>
<li><p>ceil（向上取整）</p>
</li>
<li><p>floor（向下取整）</p>
</li>
<li><p>round（四舍五入）</p>
</li>
<li><p>sqrt（求开方）</p>
</li>
<li><p>random（返回一个0-1之间的随机数，<u>包括0但不包括1</u>）</p>
<ul>
<li>例：获取a - b 之间的一个随机数</li>
<li>(int)(a + Math.random() * (b - a + 1 ) )</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h2><ul>
<li><p>Arrays中包含了一系列静态方法，用于管理或操作数组（比如排序和搜索）</p>
<ul>
<li><p>toString()返回数组的字符串形式</p>
<ul>
<li>Arrays.toString(arr);</li>
</ul>
</li>
<li><p>sort()排序 （自然排序和定制排序）</p>
<ul>
<li>因为数组是引用类型，通过数组排序后会直接影响到实参</li>
<li>sort是重载的，可以通过传入接口Comparator实现定制排序<ul>
<li><p>源码实现</p>
</li>
<li><p>涉及接口编程，匿名内部类，动态绑定&#x2F;&#x2F;具体在hspjava481节</p>
</li>
<li><p>可定制排序方法，使用Comparator接口&#x2F;&#x2F;482节,484</p>
<ul>
<li>注意compare方法返回值是int类型</li>
</ul>
</li>
<li><p>例：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr , Comparator c)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; arr.length ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; arr.length - i - <span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c.compare(arr[j] , arr[ j + <span class="number">1</span> ]) &gt; <span class="number">0</span> )&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j] ;</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>] ;</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main中：</span></span><br><span class="line">Integer[] arr = &#123; <span class="number">1</span> , <span class="number">3</span> , <span class="number">2</span> , <span class="number">4</span> &#125;;</span><br><span class="line">bubbleSort(arr, <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((Integer) o1) - ((Integer) o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//或直接利用Arrays.sort(),但只能接受Obeject类的数组</span></span><br><span class="line">Arrays.sort(arr, <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((Integer) o1) - ((Integer) o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(Arrays.toString( arr ) );</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>binarySearch 通过二分搜索进行查找，要求必须排好序</p>
<ul>
<li>如果数组中不存在该元素会返回 (-1)*（ 该元素应该在的位置下标 + 1 ）</li>
<li>细节查看源码，或查看483节</li>
</ul>
</li>
<li><p>copyof(&lt;&gt;[] array , int length) 数组元素的复制</p>
<ul>
<li>复制数组array从数组开头长度为length的内容</li>
<li>如果length &gt; array.length ,会以null&#x2F;空&#x2F;0等补齐，</li>
<li>如果length &lt; 0 抛出异常</li>
</ul>
</li>
<li><p>fill 数组元素的填充</p>
</li>
<li><p>equals 比较两个数组的元素内容是否完全一致，包括内容和顺序</p>
</li>
<li><p>asList 将一组值转换成为List</p>
<ul>
<li>List是一个接口，此处返回的List的运行类型是Arrays#ArrayList<ul>
<li>此处 # 表示ArrayList是Arrays的一个内部类</li>
</ul>
</li>
<li>例：List <Integer> aslist &#x3D; Arrays.asList(2,3,4,5);</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h2><ul>
<li><p>System常见方法</p>
<ul>
<li><p>exit(int status) 退出当前程序</p>
<ul>
<li>一般status为0 ， 表示正常退出</li>
</ul>
</li>
<li><p>arraycopy(Object src, int srcPos, Object dest, int destPos,int length) 复制数组元素，比较适合底层调用，一般使用Arrays.copy()完成数组复制</p>
</li>
<li><p>currentTimeMillens() 返回当前时间距离 1970 - 1 - 1 的毫秒数</p>
</li>
<li><p>gc() 运行垃圾回收机制</p>
</li>
</ul>
</li>
</ul>
<h2 id="BigInteger和BigDecimal类"><a href="#BigInteger和BigDecimal类" class="headerlink" title="BigInteger和BigDecimal类"></a>BigInteger和BigDecimal类</h2><ul>
<li><p>BigInteger</p>
<ul>
<li><p>用于大数据处理，保存很大的整形</p>
</li>
<li><p>在对BigInteger惊醒加减乘除的时候要使用对应的方法不能直接加减，要创建一个需要操作的BigInteger调用相关方法</p>
</li>
<li><p>创建： new BigInteger(“”);</p>
<ul>
<li>传入参数要为字符串，底层是当做字符串来处理</li>
</ul>
</li>
<li><p>常见方法</p>
<ul>
<li>add 加</li>
<li>subtract 减</li>
<li>multiply 乘</li>
<li>divide 除</li>
</ul>
</li>
</ul>
</li>
<li><p>BigDecimal</p>
<ul>
<li><p>用于保存处理一个精度很高的浮点型</p>
</li>
<li><p>在对BigDecimal惊醒加减乘除的时候要使用对应的方法不能直接加减，要创建一个 BigDecimal 对象，调用相关方法</p>
</li>
<li><p>创建； 同样要传入字符串作为构造函数的参数</p>
</li>
<li><p>常见方法同上</p>
<ul>
<li>但注意在divide时可能产生无限循环小数，抛出ArithmeticException</li>
<li>解决方法：在调用divide方法时指定精度即可<ul>
<li>System.out.pritln(bigdecimal.divide(bigdecimal2 , BigDecimal.ROUND_CEILING));</li>
<li>表示在结果为无限不循环小数时，保留到分子的精度</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h2><p> 了解知道即可</p>
<h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><ul>
<li><p>Date： 精确到毫秒，代表特定的2023年10月4日17:12:17</p>
</li>
<li><p>SimpleFormat：格式和解析日期的具体类，它允许进行格式化（日期-&gt;文本），解析（文本-&gt;日期）和规范化</p>
</li>
<li><p>具体内容看示例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();<span class="comment">//获取当前系统时间</span></span><br><span class="line">System.out.println(<span class="string">&quot;当前日期是:&quot;</span> + d1);<span class="comment">//这是默认日期输出格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建SimpleFormat对象可以指定日期输出格式</span></span><br><span class="line"><span class="comment">//这里的格式是规定好的，具体格式要求在API文档的SimpleFormat类中</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 hh:mm:ss E&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> simpleDateFormat.format(d1) ;<span class="comment">//将日期转换为指定格式字符串</span></span><br><span class="line">System.out.println(<span class="string">&quot;当前日期是:&quot;</span> + format);</span><br><span class="line"><span class="comment">//也可把一个格式化的String转成对应的Date,得到的Date输出还是按照默认模式，如果希望指定格式需要转换</span></span><br><span class="line"><span class="comment">//在String-&gt;Date时，String内容格式要和自定义格式完全匹配，否则抛出异常</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;1996年01月01日 10:20:30 星期一&quot;</span>;</span><br><span class="line"><span class="type">Date</span> <span class="variable">parse</span> <span class="operator">=</span> simpleDateFormat.parse(s) ;</span><br><span class="line">System.out.println(simplrDateFormat(parse.format(parse)));</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h3><ul>
<li><p>第二代日期类，Calendar类（日历）</p>
</li>
<li><p>Calendar是一个抽象类，它为特定瞬间与一组诸如YEAR，MONTH，DAY_OF_MONTH，HOUR等日期字段之间的转换提供了一些方法，并未操作日历字段提供了一些方法</p>
</li>
<li><p>Calendar的构造器是私有的，要使用Calendar.getInstance()函数获取实例，类似于单例设计模式的理念</p>
</li>
<li><p>具体使用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">cld</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        </span><br><span class="line">System.out.println(cld.get(Calendar.YEAR));<span class="comment">//获取年份</span></span><br><span class="line">System.out.println(cld.get(Calendar.DAY_OF_YEAR));<span class="comment">//当年的第__天</span></span><br><span class="line">System.out.println(cld.get(Calendar.MONTH) + <span class="number">1</span> );<span class="comment">//要加一，因为MONTH从零开始编号</span></span><br><span class="line">System.out.println(cld.get(Calendar.DAY_OF_MONTH));<span class="comment">//该月的第__天</span></span><br><span class="line">System.out.println(cld.get(Calendar.HOUR));</span><br><span class="line"><span class="comment">//Calendar没有专门的格式化方法，要自己组合</span></span><br><span class="line">System.out.println(<span class="string">&quot;今天是&quot;</span> + cld.get(Calendar.YEAR) + <span class="string">&quot;年&quot;</span> + cld.get(Calendar.MONTH) </span><br><span class="line">+<span class="string">&quot;月&quot;</span> + cld.get(Calendar.DAY_OF_MONTH) + <span class="string">&quot;日&quot;</span>);</span><br><span class="line"><span class="comment">//默认是12小时制，若要使用24小时制，将Calendar.HOUR -&gt; Calendar.HOUR_OF_DAY 即可</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="第三代日期类"><a href="#第三代日期类" class="headerlink" title="第三代日期类"></a>第三代日期类</h3><p>因前两代日期类的不足，在JDK8中创建新的日期类</p>
<ul>
<li><p>第三代日期类</p>
<ul>
<li><p>LocalDate （日期&#x2F;年月日）</p>
<ul>
<li>只包含日期，可以获得日期字段</li>
</ul>
</li>
<li><p>LocalTime （时间&#x2F;时分秒）</p>
<ul>
<li>只包含时间，可以获取时间字段</li>
</ul>
</li>
<li><p>LocaleDateTime（日期时间&#x2F;年月日时分秒）</p>
<ul>
<li>包含时间+日期，可以获得日期和时间字段</li>
</ul>
</li>
</ul>
</li>
<li><p>DateTimeFormate格式日期类</p>
<ul>
<li>类似于SimpleDateFormat</li>
<li>DateTimeFormat dtf &#x3D; DateTimeFormatter.ofPattern(格式);</li>
</ul>
</li>
<li><p>Instant 时间戳</p>
</li>
<li><p>第三代日期还有很多方法，按需查询即可，不用都记住</p>
</li>
<li><p>具体示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="comment">//使用now()返回表示当前日期时间的对象，可以获取年月日时分秒</span></span><br><span class="line">System.out.println(ldt);<span class="comment">//直接输出具体日期时间</span></span><br><span class="line">ldt.getYear();<span class="comment">//获取ldt的年份字段</span></span><br><span class="line">ldt.getMonth();</span><br><span class="line">ldt.getMonthValue();</span><br><span class="line">ldt.getDayOfMonth();</span><br><span class="line"><span class="comment">//关于DateTimeFormatter的格式参数要查看jdk8及以后JDK版本的文档</span></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日 HH小时mm分钟ss秒&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">strDate</span> <span class="operator">=</span> dtf.format(ldt);</span><br><span class="line">System.out.println(strDate);</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><ul>
<li><p>保存多个数据用数组有许多不便之处</p>
<ul>
<li>长度必须提前指定，且一旦指定无法更改</li>
<li>保存的必须为同一类型的元素</li>
<li>使用数组进行元素增加的代码比较复杂</li>
</ul>
</li>
<li><p>引入集合</p>
</li>
<li><p>集合</p>
<ul>
<li>可以动态保存任意多个对象，使用方便</li>
<li>提供了一系列方便的 操作对象的方法：add ， remove，set，get等</li>
<li>使用集合添加删除新元素的代码简洁明了</li>
</ul>
</li>
</ul>
<h2 id="集合的框架体系"><a href="#集合的框架体系" class="headerlink" title="集合的框架体系"></a>集合的框架体系</h2><ul>
<li><p>java集合框架图</p>
<ul>
<li><img src="/images/java_base3_06.png" alt="img"></li>
</ul>
</li>
<li><p>java集合主要分为两大类，如图</p>
<ul>
<li>Collection类<ul>
<li><img src="/images/java_base3_07.png" alt="img"></li>
</ul>
</li>
<li>Map类<ul>
<li><img src="/images/java_base3_08.png" alt="img"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="特殊类"><a href="#特殊类" class="headerlink" title="特殊类"></a>特殊类</h1><h2 id="泛型容器类"><a href="#泛型容器类" class="headerlink" title="泛型容器类"></a>泛型容器类</h2><blockquote>
<p>例：ArrayList&lt;*Stirng*&gt; notes &#x3D; new ArrayList&lt;*String*&gt;;</p>
</blockquote>
<ul>
<li>容器有两个类型：<ul>
<li>容器的类型：例如ArrayList</li>
<li>元素的类型：例如String      <br></li>
</ul>
</li>
<li>ArrayList</li>
</ul>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><ul>
<li>定义在别的类的内部，函数内部的类<ul>
<li>内部类能直接访问外部的全部资源</li>
<li>外部是函数时，只能访问那个函数里final的变量</li>
</ul>
</li>
</ul>
<h2 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h2><ul>
<li>在new对象时给出类的定义形成了匿名类</li>
<li>匿名类可以继承某类，也可以实现某接口</li>
<li>Swing的消息机制广泛使用匿名类<ul>
<li>注入反转</li>
</ul>
</li>
</ul>
<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h2 id="equals函数"><a href="#equals函数" class="headerlink" title="equals函数"></a>equals函数</h2><ul>
<li><p>equals()是Object类中的方法，只能判断引用类型变量所指对象</p>
</li>
<li><p><strong>equals()在Object中函数默认是判断地址是否相等</strong>，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">    &#125;<span class="comment">//Object类中法equals()方法实现</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>但<strong>在Object子类中，如String，Integer，会重写该方法，用于判断内容是否相同</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == anObject) &#123;<span class="comment">//Object类中法equals()方法实现</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">anotherString</span> <span class="operator">=</span> (String)anObject;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> value.length;</span><br><span class="line">            <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">                <span class="type">char</span> v1[] = value;</span><br><span class="line">                <span class="type">char</span> v2[] = anotherString.value;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="重写equals-函数"><a href="#重写equals-函数" class="headerlink" title="重写equals()函数"></a>重写equals()函数</h3><ul>
<li>在声明定义一个类时，若直接调用类的equals()函数，使用的是继承自Object类的equals，作用是判断两个对象变量是否管理同一个对象。</li>
<li>若要想要比较字符串的内容而不是引用，应该重写一个属于该类的equals()函数</li>
<li>重写步骤<ul>
<li>1 判断传入的Obj是否与当前对象地址相同<ul>
<li>若是，则可直接返回true</li>
</ul>
</li>
<li>2 判断传入的obj的运行类型是否与当前对象类型相同<ul>
<li>若否，则可直接返回false</li>
</ul>
</li>
<li>3 <strong>将传入的obj向下造型，赋给一个当前对象类型的变量</strong><ul>
<li><strong>以获得访问该类特有属性的权限</strong></li>
</ul>
</li>
<li>4 比较属性内容是否相同<ul>
<li>全为真方可返回为true</li>
</ul>
</li>
</ul>
</li>
<li>学习： 多阅读源码</li>
</ul>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">integer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">12</span>);<span class="comment">//若是将12换成1000，结果是否会有所不同</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">12</span>);</span><br><span class="line">System.out.println(integer1.equals(integer2));</span><br><span class="line"><span class="type">String</span> <span class="variable">string1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span> ;</span><br><span class="line"><span class="type">String</span> <span class="variable">string2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span> ;</span><br><span class="line">System.out.println(string1.equals(string2));</span><br><span class="line"><span class="type">String</span> <span class="variable">string3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>) ;</span><br><span class="line"><span class="type">String</span> <span class="variable">string4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>) ;</span><br><span class="line">System.out.println(string3.equals(string4));</span><br></pre></td></tr></table></figure>

<h2 id="hashcode-函数"><a href="#hashcode-函数" class="headerlink" title="hashcode()函数"></a>hashcode()函数</h2><ul>
<li>小结 <ul>
<li>hashcode()的作用主要是提高具有哈希结构的容器的效率</li>
<li>两个引用如果指向同一个对象则哈希值一定相同</li>
<li>两个引用如果指向不同对象则哈希值一定不同</li>
<li>哈希值是根据地址号经过特殊算法运算得来的</li>
<li>如果需要也会要重写hashcode()</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;<span class="comment">//String 的hashcode方法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">                h = <span class="number">31</span> * h + val[i];</span><br><span class="line">            &#125;</span><br><span class="line">            hash = h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h2><ul>
<li>基本介绍<ul>
<li>默认返回：全类名 + @ + 哈希值的十六进制，<blockquote>
<p>return getClass().getName() + “@” + Integer.toHexString(hashCode());  </p>
</blockquote>
</li>
<li>实际开发中通常希望对象的toString()方法返回一些特有属性信息等，故子类往往会重写toString()方法</li>
<li>重写toString方法，打印或拼接对象时，都会自动调用该对象的toString形式</li>
<li>当直接输出一个对象时，toString方法会被默认调用</li>
</ul>
</li>
</ul>
<h2 id="clone-函数"><a href="#clone-函数" class="headerlink" title="clone()函数"></a>clone()函数</h2><h3 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h3><ul>
<li>浅拷贝：默认情况下，clone()方法执行的是浅拷贝（shallow copy），它只会复制对象的字段引用，而不是字段的内容。这意味着如果对象包含其他对象的引用，那么复制的对象和原始对象将共享这些引用，可能导致意外的副作用。</li>
<li>隐式类型转换：clone()方法返回的是Object类型，需要进行显式的类型转换才能得到正确的类型。这可能导致类型转换错误和运行时异常。</li>
<li>不适用于不可变对象：对于不可变对象（如String），通常没有必要使用clone()方法，因为它们本身就是不可变的，可以直接共享。</li>
</ul>
<h3 id="clone-函数的重写"><a href="#clone-函数的重写" class="headerlink" title="clone()函数的重写"></a>clone()函数的重写</h3><h2 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h2><ul>
<li>当对象被回收时，系统自动调用该对象的finalize方法，子类可以重写该方法，根据需要做一些<strong>释放资源</strong>的操作等</li>
<li>何时被回收，当某个对象没有任何引用时，则jvm就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁前会调用finalize方法（类似于CPP中的析构函数）</li>
<li>垃圾回收机制的调用，是由系统来决定<ul>
<li>并不是对象不被引用后立刻就回收，而是系统有专门算法控制回收时机</li>
<li>可以通过System.gc()主动触发垃圾回收机制</li>
</ul>
</li>
<li>若未重写该方法，则会调用Object类中finalize方法，即默认处理</li>
</ul>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><ul>
<li>设计模式是静态方法和属性的经典使用</li>
<li>设计模式是在大量的实践中总结和理论化之后优选的代码结果，编程风格，以及解决问题的思考方式。设计模式就像是被经典的棋谱，免得我们再去摸索</li>
</ul>
<h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><ul>
<li>单例设计模式就是采取一定的方法保证在整个软件系统中，某个类只能存在一个实例对象，并且只提供一个取得其对象实例的方法</li>
<li>单例模式有两种方式<ul>
<li>饿汉式</li>
<li>懒汉式</li>
</ul>
</li>
</ul>
<h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><ul>
<li>实现方式<ul>
<li>1 构造器私有化-&gt;防止类外将该类实例化</li>
<li>2 类的内部创建对象</li>
<li>3 向外提供一个公共的静态方法返回该实例对象<ul>
<li>饿汉式是指在类加载时就直接创建这个对象</li>
<li>故饿汉式可能创建了对象但是没有被使用</li>
</ul>
</li>
</ul>
</li>
<li>代码演示 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleClass</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleClass</span> <span class="params">()</span>&#123;&#125;;<span class="comment">//构造器私有化保证只有一个实例化对象   </span></span><br><span class="line">    <span class="comment">//在类内创建好改对象实例，为了能在静态方法中返回该实例对象，需要将其修饰为static</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SingleClass</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleClass</span>();</span><br><span class="line">    <span class="comment">//提供对外返回该实例的公共的static接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingleClass <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><ul>
<li>实现方式与饿汉式相近<ul>
<li>区别在于懒汉式是在用户调用该getInstance方法时才会创建实例对象</li>
<li>且再次调用getInstance方法时会返回之前创建的对象</li>
</ul>
</li>
<li>代码演示<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleClass</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleClass</span> <span class="params">()</span>&#123;&#125;;<span class="comment">//构造器私有化保证只有一个实例化对象   </span></span><br><span class="line">    <span class="comment">//在类内创建对象变量但并不实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleClass instance ;</span><br><span class="line">    <span class="comment">//提供对外返回该实例的公共的static接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingleClass <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)<span class="comment">//如果instance为null则创建实例对象，若部位null则返回之前已经创建好的对象</span></span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">SingleClass</span>();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li>二者最大区别在于创建对象的时机不同，饿汉式是在类加载时就创建了对象实例，而懒汉式时在使用时才创建</li>
<li>饿汉式不存在线程安全为题，懒汉式存在线程安全问题</li>
<li>饿汉式存在资源浪费的可能。</li>
<li>在javaSE的标准类中，java.lang.Runtime就是经典的单例模式</li>
</ul>
<h2 id="模板设计模式"><a href="#模板设计模式" class="headerlink" title="模板设计模式"></a>模板设计模式</h2><p>例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Template&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doJob</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calculateTime</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        dojob();<span class="comment">//在父类模板中调用抽象方法，子类调用该方法会动态绑定调用自己重写的doJob()</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Subclass1 <span class="keyword">extends</span> <span class="title class_">Template</span>&#123;</span><br><span class="line">    <span class="meta">@override</span><span class="comment">//重写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doJob</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="comment">//执行任务代码，例如计算1加到一百万</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://pengzhanyi.github.io">zhanyi peng</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://pengzhanyi.github.io/2023/09/24/java-base3/">https://pengzhanyi.github.io/2023/09/24/java-base3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://pengzhanyi.github.io" target="_blank">Blog | kaori</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a></div><div class="post_share"><div class="social-share" data-image="/images/java_base3_03.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/09/26/data-structure/" title="数据结构"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">数据结构</div></div></a></div><div class="next-post pull-right"><a href="/2023/09/19/java_base2/" title="java基础——面向对象基础"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">java基础——面向对象基础</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/09/17/java-base/" title="java基础语法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-17</div><div class="title">java基础语法</div></div></a></div><div><a href="/2023/09/19/java_base2/" title="java基础——面向对象基础"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-19</div><div class="title">java基础——面向对象基础</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head_sculpture.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">zhanyi peng</div><div class="author-info__description">"人生就是在欲望不满的痛苦和欲望满足后的厌倦之间，像钟摆一样地来回摆动"</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.</span> <span class="toc-text">枚举和注解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">1.1.</span> <span class="toc-text">枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0%E6%9E%9A%E4%B8%BE"><span class="toc-number">1.1.1.</span> <span class="toc-text">自定义实现枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#enum%E5%85%B3%E9%94%AE%E5%AD%97%E5%AE%9E%E7%8E%B0%E6%9E%9A%E4%B8%BE"><span class="toc-number">1.1.2.</span> <span class="toc-text">enum关键字实现枚举</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.2.</span> <span class="toc-text">注解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">异常和异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">2.1.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E6%9C%BA%E5%88%B6try-catch"><span class="toc-number">2.1.1.</span> <span class="toc-text">简单的异常捕获机制try-catch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8"><span class="toc-number">2.1.2.</span> <span class="toc-text">常见的运行时异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%BC%82%E5%B8%B8"><span class="toc-number">2.1.3.</span> <span class="toc-text">编译异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">2.2.</span> <span class="toc-text">异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#try-catch-finally"><span class="toc-number">2.2.1.</span> <span class="toc-text">try-catch-finally</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#throws"><span class="toc-number">2.2.2.</span> <span class="toc-text">throws</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">2.3.</span> <span class="toc-text">自定义异常</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-number">3.</span> <span class="toc-text">常用类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">3.1.</span> <span class="toc-text">包装类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E7%B1%BB"><span class="toc-number">3.2.</span> <span class="toc-text">String类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#String-%E5%9F%BA%E7%A1%80"><span class="toc-number">3.2.1.</span> <span class="toc-text">String 基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E5%88%9B%E5%BB%BA%E6%9C%BA%E5%88%B6"><span class="toc-number">3.2.2.</span> <span class="toc-text">String创建机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.3.</span> <span class="toc-text">String类常用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringBuffer%E7%B1%BB"><span class="toc-number">3.3.</span> <span class="toc-text">StringBuffer类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringBuilder%E7%B1%BB"><span class="toc-number">3.4.</span> <span class="toc-text">StringBuilder类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-StringBuffer-StringBuilder%E6%AF%94%E8%BE%83"><span class="toc-number">3.5.</span> <span class="toc-text">String StringBuffer StringBuilder比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Math%E7%B1%BB"><span class="toc-number">3.6.</span> <span class="toc-text">Math类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Arrays%E7%B1%BB"><span class="toc-number">3.7.</span> <span class="toc-text">Arrays类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#System%E7%B1%BB"><span class="toc-number">3.8.</span> <span class="toc-text">System类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BigInteger%E5%92%8CBigDecimal%E7%B1%BB"><span class="toc-number">3.9.</span> <span class="toc-text">BigInteger和BigDecimal类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="toc-number">3.10.</span> <span class="toc-text">日期类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Date"><span class="toc-number">3.10.1.</span> <span class="toc-text">Date</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Calendar"><span class="toc-number">3.10.2.</span> <span class="toc-text">Calendar</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E4%BB%A3%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="toc-number">3.10.3.</span> <span class="toc-text">第三代日期类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">4.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E6%A1%86%E6%9E%B6%E4%BD%93%E7%B3%BB"><span class="toc-number">4.1.</span> <span class="toc-text">集合的框架体系</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%B1%BB"><span class="toc-number">5.</span> <span class="toc-text">特殊类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB"><span class="toc-number">5.1.</span> <span class="toc-text">泛型容器类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">5.2.</span> <span class="toc-text">内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E7%B1%BB"><span class="toc-number">5.3.</span> <span class="toc-text">匿名类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#API"><span class="toc-number">6.</span> <span class="toc-text">API</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#equals%E5%87%BD%E6%95%B0"><span class="toc-number">6.1.</span> <span class="toc-text">equals函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%86%99equals-%E5%87%BD%E6%95%B0"><span class="toc-number">6.1.1.</span> <span class="toc-text">重写equals()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">6.1.2.</span> <span class="toc-text">常量池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashcode-%E5%87%BD%E6%95%B0"><span class="toc-number">6.2.</span> <span class="toc-text">hashcode()函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#toString-%E6%96%B9%E6%B3%95"><span class="toc-number">6.3.</span> <span class="toc-text">toString()方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#clone-%E5%87%BD%E6%95%B0"><span class="toc-number">6.4.</span> <span class="toc-text">clone()函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">6.4.1.</span> <span class="toc-text">深拷贝与浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clone-%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E5%86%99"><span class="toc-number">6.4.2.</span> <span class="toc-text">clone()函数的重写</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#finalize"><span class="toc-number">6.5.</span> <span class="toc-text">finalize()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.1.</span> <span class="toc-text">单例设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A5%BF%E6%B1%89%E5%BC%8F"><span class="toc-number">7.1.1.</span> <span class="toc-text">饿汉式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%87%92%E6%B1%89%E5%BC%8F"><span class="toc-number">7.1.2.</span> <span class="toc-text">懒汉式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">7.1.3.</span> <span class="toc-text">区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.2.</span> <span class="toc-text">模板设计模式</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/26/data-structure/" title="数据结构">数据结构</a><time datetime="2023-09-26T14:39:14.000Z" title="发表于 2023-09-26 22:39:14">2023-09-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/24/java-base3/" title="java基础- 基于面向对象的应用"><img src="/images/java_base3_03.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="java基础- 基于面向对象的应用"/></a><div class="content"><a class="title" href="/2023/09/24/java-base3/" title="java基础- 基于面向对象的应用">java基础- 基于面向对象的应用</a><time datetime="2023-09-24T08:50:40.000Z" title="发表于 2023-09-24 16:50:40">2023-09-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/19/java_base2/" title="java基础——面向对象基础">java基础——面向对象基础</a><time datetime="2023-09-19T13:37:20.000Z" title="发表于 2023-09-19 21:37:20">2023-09-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/17/%E4%B8%AA%E4%BA%BAblog%E5%BB%BA%E8%AE%BE/" title="个人blog建设">个人blog建设</a><time datetime="2023-09-17T12:19:01.000Z" title="发表于 2023-09-17 20:19:01">2023-09-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/17/java-base/" title="java基础语法">java基础语法</a><time datetime="2023-09-17T11:25:52.000Z" title="发表于 2023-09-17 19:25:52">2023-09-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By zhanyi peng</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>