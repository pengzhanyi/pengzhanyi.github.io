<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog | kaori</title>
  
  
  <link href="https://pengzhanyi.github.io/atom.xml" rel="self"/>
  
  <link href="https://pengzhanyi.github.io/"/>
  <updated>2023-11-18T17:07:27.864Z</updated>
  <id>https://pengzhanyi.github.io/</id>
  
  <author>
    <name>zhanyi peng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java基础编程知识</title>
    <link href="https://pengzhanyi.github.io/2023/11/11/java-base5/"/>
    <id>https://pengzhanyi.github.io/2023/11/11/java-base5/</id>
    <published>2023-11-10T17:11:07.000Z</published>
    <updated>2023-11-18T17:07:27.864Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="java网络编程"><a href="#java网络编程" class="headerlink" title="java网络编程"></a>java网络编程</h1><p>java是Internet上的语言，它从语言级上提供对网络应用程序的支持，程序员能够很容易开发常见的网络应用程序。<br>java提供的网络类库，可以实现无痛的网络连接，联网的底层细节被隐藏在java的本机暗转系统里，由JVM进行控制，并且java实现了一个跨平台的网络库，程序员面对的是一个同一的网络编程环境。</p><ul><li><p>软件架构：</p><ul><li><p>c&#x2F;s 架构：全称为Clinet&#x2F;Server 结构，是指客户端和服务器结构，常见程序有QQ，美团APP等软件</p></li><li><p>B&#x2F;S 架构：全程为Browser&#x2F;Server结构，是指浏览器和服务器结构，常见浏览器有IE，谷歌等</p></li></ul></li><li><p>两种架构各有优势，但无论哪种架构都离不开网络的支持，<strong>网络编程</strong>就是在一定的协议下实现计算机之间通信的程序</p></li></ul><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><p>网络</p><ul><li><p>概念：两台或多态设备通过一定物理设备连接起来构成了网络</p></li><li><p>根据网络的覆盖范围不同，对网络进行分类：</p><ul><li><p>局域网： 覆盖范围最小，仅仅覆盖一个机房或一个网吧等</p></li><li><p>域域网： 覆盖范围大，可以覆盖一个城市</p></li><li><p>广域网： 覆盖范围最大，可以覆盖全国乃至全球，万维网是广域网的代表</p></li></ul></li></ul></li><li><p>网络通信</p><ul><li><p>概念：两台设备之间通过网络实现数据传输</p></li><li><p>计算机网络：把分布在不同地理区域的计算机与转换们的外部设备备用通信电路互联成一个规模大，功能强的网络系统，从而使众多的计算机可以方便的互相传递信息，共享硬件，软件，数据信息等资源。</p></li><li><p>网络编程的目的：直接或间接地通过网络协议与其他计算机实现数据交换进行通信</p></li><li><p>网络通信： 将数据通过网络从一台设备传输到另一台设备</p></li><li><p><strong>java.net</strong>下提供了一系列的类或接口，供程序员使用完成网络通信</p></li><li><p><img src="/images/java_base5/01.png" alt="img"></p></li><li><p>实现网络传输的三个要素：</p><ul><li>如何准确地定位网络上的一台或多态主机？—— 使用IP地址</li><li>如何定位主机上的特定的应用？         —— 使用端口号</li><li>如何可靠高效地进行网络信息传输？      —— 使用网络协议</li></ul></li></ul></li></ul><h2 id="IP地址，域名，端口号"><a href="#IP地址，域名，端口号" class="headerlink" title="IP地址，域名，端口号"></a>IP地址，域名，端口号</h2><ul><li><p>查看本机IP 地址：ipconfig </p></li><li><p>查看网站服务器地址 ： ping <a href="http://www.baidu.com/">www.baidu.com</a> </p></li><li><p>IP 地址</p><ul><li><p>概念： IP地址指的是互联网协议地址(Internet Protocol Address),简称IP。 IP地址用来给网络中的一台计算机设备做唯一的编号，即用于唯一标识网络中的每台计算机&#x2F;主机</p></li><li><p>IP地址表示形式：点分十进制 xx.xx.xx.xx<br>  IPv4表示，四个字节表示一个 IP地址，每个字节(8bit)表示范围0-255,</p></li><li><p>ip地址的组成： IP地址 &#x3D; 网络地址 + 主机地址 如：192.168.16.69</p></li><li><p>IP地址分类方式1 ：ipv4 和 ipv6</p><ul><li><p>ipv4 占用4个字节      </p><ul><li>IPv4 的最大问题在于网络地址资源有限，严重制约了互联网的应用发展。IPv6的使用不仅解决了网络地址资源有限的问题也解决了多种接入设备连入互联网的障碍   </li><li>ipv4 地址分类：<br>  <img src="/images/java_base5/02.png" alt="img"></li></ul></li><li><p>ipv6 (占用16个字节)</p><ul><li>IPv6 是用于代替 IPv4 的下一代 IP协议，其地址数量极大。</li><li>IPv6 使用128 位表示地址，用16进制表示 ，16个字节，是IPv4 地址长度的4倍，写成8个无符号整数，每个整数用四个十六进制数表示，数之间用冒号分割。     </li><li>例如：2001:da8:215:8f02:b451:29cc:ed4f:3173</li></ul></li></ul></li><li><p>IP地址分类方式2：</p><ul><li>公网地址(万维网使用) 和私有地址(局域网使用，以192.168开头)。</li></ul></li></ul></li></ul><blockquote><p>本地回路地址 : 127.0.0.1 表示直接连接到本机</p></blockquote><ul><li><p>域名</p><ul><li><p>概念：将ip 地址映射成域名</p></li><li><p>作用：为了方便记忆，解决记 IP 地址的困难</p></li><li><p>例 ：域名： <a href="http://www.baidu.com/">www.baidu.com</a>  ， 通过DNS(域名解析服务器)将域名解析成对应 的ip地址，访问以取得相应服务</p></li></ul></li><li><p>端口号</p><ul><li>概念： 如果说IP地址可以唯一标识网络中的设备，那么端口号可以唯一标识设备中的进程(应用程序)。</li></ul></li><li><p>在一个主机上可以同时运行多个服务，不同进程有不同的端口号。网络信息要获得 IP + 端口，用Ip地址找到对应主机，利用端口号区分不同服务（进程），将对应信息输送到对应服务中</p><ul><li>表示形式： 以整数形式表示，范围 0 ~ 65535(两个字节表示端口0 ~ 2^16-1)</li></ul></li><li><p>0 ~ 1023 已经被占用，比如 ssh 22 , ftp 21 , smtp 25, http 80（在网络开发中不要使用0-1024的端口）</p><ul><li><p>常见的网络端口号：</p><ul><li>tomcat: 8080</li></ul></li><li><p>mysql: 3306</p><ul><li>oracle: 1521</li></ul></li><li><p>sqlserver:1433</p></li></ul></li></ul><blockquote><p><strong>netstat指令</strong> ：</p><ul><li>netstat -an 查看当前主机网络情况，包括接口监听情况和网络连接情况<ul><li>状态 Listening 表示该端口正在监听</li><li>Established 表示有某个外部程序(客户端)连接到该端口，此时外部地址就会显示该外部程序的IP地址和端口</li></ul></li><li>netstat - an | more 可以分页显示</li><li>netstat -anb 命令(需要管理员权限)查看当前计算机端口占用情况，并显示具体相应端口的程序信息</li></ul></blockquote><h2 id="InetAddress-类"><a href="#InetAddress-类" class="headerlink" title="InetAddress 类"></a>InetAddress 类</h2><ul><li><p>public class InetAddress extends Object implements Serializable</p></li><li><p>此类表示Internet协议（IP）地址，InetAddress的一个实例由一个IP地址和可能的相应主机名组成</p></li><li><p>InetAddress类构造方法私有化，其中有相应的静态方法用于获取对象实例</p></li><li><p>相应方法应用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getLocalHost(),用于获取本机的InetAddress对象,输出本机设备名称和IP</span></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">localHost</span> <span class="operator">=</span> InetAddress.getLocalHost() ;</span><br><span class="line">System.out.println(localHost);</span><br><span class="line"></span><br><span class="line"><span class="comment">//getByName(String host) 获取指定ip/主机名/域名 对应的ip地址对象</span></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">inet1</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;LAPTOP-4TA8TN0D&quot;</span>);</span><br><span class="line">System.out.println(inet1);</span><br><span class="line"></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">inet2</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">System.out.println(inet2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// getHosetAddres(),通过InetAddress对象获取对应的地址</span></span><br><span class="line"><span class="type">String</span> <span class="variable">hostAddress</span> <span class="operator">=</span> byName1.getHostAddress();</span><br><span class="line">System.out.println(hostAddress);</span><br><span class="line"></span><br><span class="line"><span class="comment">// getHostName(),获取此IP地址的主机名，如果是本机则是计算机名，不是本机则是主机名，如果没有域名则是IP地址</span></span><br><span class="line">System.out.println(<span class="string">&quot;域名/主机名是：&quot;</span> + byName1.getHostName());</span><br><span class="line">System.out.println(<span class="string">&quot;IP地址是：&quot;</span> + byName1.getHostAddress());</span><br></pre></td></tr></table></figure></li></ul><h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li><p>目的：为了实现数据可靠高效地传输</p></li><li><p>通信双方地址：</p><ul><li>IP地址</li><li>端口号</li></ul></li><li><p>协议就是一种规范，是一种要求在网络上传输的数据必须要满足的组织形式，按照网络协议发送数据，能保证数据的准确高效地发送到目的地（类似于人之间的语言交流，说出的话必须要满足某种语法规范，不然别人无法理解你的话） </p></li><li><p>协议实际涉及内容很多，比如原地址和目标地址，加密解密，压缩和解压缩，擦错控制，流量控制等，极其复杂，故在制定协议时将协议分层：</p><ul><li><p>将协议分成不同层次，同层间可以通信，上一层可以调用下一层，而与在下一层不发生关系。各层之间互不影响，利于系统的开发和扩展。</p></li><li><p><img src="/images/java_base5/04.png" alt="img"></p><blockquote><p>OSI 模型只是理论上的模型，但过于复杂理想化，在实际应用中简化为 tcp&#x2F;ip 模型。</p></blockquote></li></ul></li><li><p>tcp &#x2F; ip 协议</p><ul><li><p>TCP&#x2F;IP (Transmission Control Protocol&#x2F;Internet Protocol)</p></li><li><p>传输控制协议&#x2F;因特网互联协议 ， 也叫网络通讯协议，这是Internet最基本的协议，Internet国际互联的基础，简单的说就是由网络层的Ip 协议和传输层的TCP 协议组成</p></li><li><p>数据进入协议栈时的封装过程，层层打包，同理取出数据时层层拆包取出数据<br>  <img src="/images/java_base5/03.png" alt="img"></p></li><li><p><a href="https://www.cnblogs.com/crazymakercircle/p/14499211.html">相关内容</a></p></li></ul></li></ul><h3 id="TCP-和-UDP："><a href="#TCP-和-UDP：" class="headerlink" title="TCP 和 UDP："></a>TCP 和 UDP：</h3><ul><li><p>TCP协议：传输控制协议</p><ul><li><p>TCP协议是<strong>面向连接</strong>的通信协议。即在传输数据前现在发送端和接受端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。</p></li><li><p>TCP协议进行通信的两个应用进程：客户端 ， 服务端。</p></li><li><p><strong>在TCP连接中必须要明确客户端与服务端</strong>，使用TCP协议前，需先<strong>建立TCP连接</strong>，形成基于字节流的传输数据通道，客户端向服务器端发出连接请求，每次连接要要经过<strong>三次握手</strong>确认连接，点对点通信，是可靠的：</p><ul><li><p>第一次握手，客户端向服务器端发出连接请求，等待服务器确认；第二次握手，服务器端向客户端会送一个响应，通知客户端收到了连接请求；第三次握手，客户端再次向服务器端发送确认信号，确认连接。 </p></li><li><p>TCP协议使用<strong>重发机制</strong>，当一个通信实体发送一个消息给另一个通信实体后，需要收到另一个通信实体确认信息，如果没有收到确认信息，则会再次重发刚才发送的消息。</p></li></ul></li><li><p>在连接中可进行<strong>大数据量的传输</strong></p></li><li><p>传输完毕，需释放已建立的连接，进行“<strong>四次挥手</strong>”</p></li><li><p>由于TCP的面向连接特性，它可以保证传输数据的安全性，因此TCP协议是一个被广泛采用的协议，例如在下载文件时，如果数据接收不完整将会导致数据丢失而不能被打开，因此下载文件时必须采用TCP协议。</p></li></ul></li><li><p>UDP协议：用户数据报协议</p><ul><li><p>UDP 是<strong>无连接通信协议</strong>，即在数据传输时，数据的发送端和接受端不建立逻辑连接。即在计算机发送数据时，发送端不会确认接收端是否存在就会发出数据；同样，接收端在收到数据时，也不会向发送端反馈是否收到数据。</p></li><li><p>将数据，源，目的封装成数据包，<strong>不需要建立连接</strong></p></li><li><p>每个数据包的大小限制在<strong>64K</strong> 内，不适合传输大量数据</p></li><li><p>因无需连接，故UDP是<strong>不可靠</strong>的，不能保证数据的完整性</p></li><li><p>发送数据结束是无需释放资源(因为不是面向连接的)，<strong>速度快</strong></p></li><li><p>UDP协议由于消耗资源小，通信效率高，故通常用于音频，视屏和普通数据的传输，如视频聊天，这种情况即使丢失一两个数据包也不会对接受结果造成太大影响。</p></li></ul></li><li><p>理解：</p><ul><li><p>TCP本质是建立双向通讯，UDP只是单纯的一方向另一方发送数据，</p></li><li><p>tcp传输一堆有序号的大数据分片，不管哪个分片先收到，接收方收齐以后把所有分片都合成大数据再读取，缺失任何一片都不行</p></li><li><p>udp是传输单条或多条数据，不管哪条先收到或有数据缺失也没关系，读取最新的数据包就行，例如网络直播的实现</p></li></ul></li></ul><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><ul><li><p>网络上具有唯一标识的IP地址和端口号组合在一起构成唯一能识别的标识符套接字</p></li><li><p>Socket(套接字)开发网络应用程序被广泛采用，以至于成为事实上的标准</p></li><li><p>通信的两端都要有socket，是两台机器间通讯的端点</p></li><li><p>Socket 允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输</p></li><li><p>一般主动发起通信的应用程序属客户端，等待通信请求的为服务器</p></li><li><p>Socket分类：</p><ul><li><p>流套接字(stream socket):使用TCP提供可依赖的字节流服务</p><ul><li><p>ServerSocket ：此类实现TCP服务器套接字。服务器套接字等待请求通过网络传入</p></li><li><p>Socket：此类实现客户端套接字,套接字是两台机器间通信的端点</p></li></ul></li><li><p>数据报套接字(datagram socket):使用UDP提供的数据包服务</p><ul><li>DatagramSocket:此类表示用来发送和接受UDP数据报包的套接字</li></ul></li></ul></li><li><p>需要通讯时(读写数据时)：</p><ul><li><p>socket.getOutputStream();</p></li><li><p>socket.getInputStream();</p></li></ul></li><li><p>Socket 的两种编程方式：</p><ul><li><p>TCP 编程，可靠</p></li><li><p>UDP 编程，不可靠</p></li></ul></li></ul><h3 id="UDP-通信"><a href="#UDP-通信" class="headerlink" title="UDP 通信"></a>UDP 通信</h3><ul><li>UDP是一种面向无连接的协议，在通信时发送端和接收端不用建立连接。</li><li>类 DatagramSocket 和 DatagramPacket[数据包]，实现了基于 UDP 协议的网络程序</li><li>UDP数据包通过数据包套接字 DatagramSocket 发送和接受，系统不保证 UDP 数据包一定能安全送到指定位置，也不确定什么时候解压到达</li><li>DatagramPacket 对象封装了 UDP 数据包，在数据包中包含了发送端的IP地址 和端口号以及接收端的IP地址和端口号</li><li>UDP协议中每个数据包都给出了完整的地址信息，故无需建立发送方和接收方的连接</li><li><u>没有服务端和客户端概念</u></li></ul><h4 id="DatagramPacket"><a href="#DatagramPacket" class="headerlink" title="DatagramPacket"></a>DatagramPacket</h4><ul><li><p>UDP通信的过程就像是货运公司在两个码头之间发送货物，JDK中提供了DatagramPacket类,该类实例对象用于封装UDP通信中发送或接受的数据。</p></li><li><p>构造方法：</p><ul><li>在创建发送端和接收端的 DatagramPacket对象时使用的构造方法不同，接收端的构造方法只需要接收一个字节数组用于存放接收到的数据，而发送端的数据包一定要明确指出数据的目的地(IP地址和端口号)，接收端不需要明确数据的来源，只需要接收到数据即可。“发出快递必须要知道目的地的地址”</li></ul><table><thead><tr><th>方法声明</th><th>功能描述</th></tr></thead><tbody><tr><td>DatagramPacket(byte[] buf,int length)</td><td>构造一个 DatagramPacket用于接收长度length的数据包 。这个对象明显只能用于接收端</td></tr><tr><td>DatagramPacket(byte[] buf,int length，InetAddress addr ,int port)</td><td>构造用于发送 length长度的分组的数据报包，到指定主机上到指定的端口</td></tr><tr><td>DatagramPacket(byte[] buf, int offset, int length)</td><td>与方法一类似，同样用于接收端，只是在其基础上增加了一个offset参数，用于指定接收到的数据在放入buf缓冲数组时是从offset处开始的</td></tr><tr><td>DatagramPacket(byte[] buf, int offset, int length, InetAddress address, int port)</td><td>与方法二类似。</td></tr></tbody></table></li><li><p>常用方法：</p><table><thead><tr><th>方法声明</th><th>功能描述</th></tr></thead><tbody><tr><td>InetAdress getAddress()</td><td>该方法用于返回发送端或接收端的IP地址，如果是发送端的DatagramPacket对象，就返回接收端的IP地址；反之，就返回发送端的IP地址</td></tr><tr><td>byte[] getData()</td><td>该方法用于但会将要接收或者将要发送的数据，如果是发送端的DatagramPacket对象，就返回将要发送的数据；反之，就返回接受到的数据</td></tr><tr><td>int getPort()</td><td>返回发送端或接收端的端口号。如果是发送端的DatagramPacket对象，就返回接收端的端口号；反之，就返回发送端的端口号</td></tr><tr><td>int getLength()</td><td>返回要发送的数据的长度或接收到的数据的长度</td></tr><tr><td>SocketAddress getSocketAddress()</td><td>获取该数据包发送到或正在从其发送的远程主机的SocketAddress（通常为IP地址+端口号）。</td></tr><tr><td>void setAddress(InetAddress iaddr)</td><td>设置该数据报发送到的机器的IP地址</td></tr></tbody></table></li></ul><h4 id="DatagramSocket"><a href="#DatagramSocket" class="headerlink" title="DatagramSocket"></a>DatagramSocket</h4><ul><li><p>要实现通信不仅需要“集装箱”，还需要“码头”，JDK提供了一个DatagramSocket类，作用就类似与“码头”，使用这个类的实例对象就可以发送和接收DatagramPacket数据包。</p></li><li><p>构造方法：</p><ul><li>创建发送端与接收端的 DatagramSocket对象使用的构造方法也不相同</li></ul><table><thead><tr><th>方法声明</th><th>功能描述</th></tr></thead><tbody><tr><td>DatagramSocket()</td><td>构造发送端的 DatagramPacket对象，在创建对象时并没有指定端口号，此时系统会分配一个没有被其他网络程序所使用的端口号。</td></tr><tr><td>DatagramSocket(int port)</td><td>构造既可以可用于接收端也可用于发送端的DatagramSocket对象。<strong>在创建接收端的对象时必须要指定一个端口号，这样就可以监听指定的端口</strong>。</td></tr><tr><td>DatagramSocket(int port,InetAddress addr)</td><td>使用该方法时指定端口号和相关IP地址。该对象使用适用于计算机上有多块网卡的情况，在使用时可以有明确规定数据通过哪块网卡向外发送和接受哪块网卡的数据。<strong>由于计算机会针对不同的网卡分配不同的IP</strong>，因此在创建DatagramSocket对象时需要指定IP地址来确定使用哪块网卡进行通信。</td></tr></tbody></table></li><li><p>常用方法：</p><table><thead><tr><th>方法声明</th><th>功能描述</th></tr></thead><tbody><tr><td>void receive(DatagramPacket p)</td><td>该方法用于将接收到的数据填充到DatagramPacket数据包中，<strong>在接收到数据之前会一直处于阻塞状态</strong>，只有当接受到数据包时，该方法才会返回。</td></tr><tr><td>void send(DatagramPacket p)</td><td>该方法用于发送DatagramPacket 数据包，发送的数据包中包含将要发送的数据，数据的长度，远程主机的IP地址和端口号</td></tr><tr><td>void close()</td><td>关闭当前的Socket，通知驱动程序释放这个Socket保留的资源</td></tr></tbody></table></li></ul><h4 id="UDP-网络程序"><a href="#UDP-网络程序" class="headerlink" title="UDP 网络程序"></a>UDP 网络程序</h4><ul><li><p>实现UDP网络通信需创建一个发送端程序和一个接收端程序。注意，在通信时只有接收端程序先运行，才能避免发送端发送数据时找不到接收端而造成数据丢失的问题</p></li><li><p>先实现接收端程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接收端，创建一个字节数组用于接收数据</span></span><br><span class="line"><span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="type">DatagramPacket</span> <span class="variable">datagramPacket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buf ,buf.length) ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建UDP接收端DatagramSocket对象需要指定要监听的端口</span></span><br><span class="line"><span class="type">DatagramSocket</span> <span class="variable">datagramSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">8984</span>) ;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;等待监听发向本机8984端口的数据&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待数据接收，没有接收到数据则会阻塞在这里</span></span><br><span class="line">datagramSocket.receive(datagramPacket);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将接收到的byte数组转化为可显示的字符串，要采用这种构造器才能保证输出不会是乱码~</span></span><br><span class="line"><span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(datagramPacket.getData() , <span class="number">0</span>,datagramPacket.getLength()) ;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;接收到的数据：&quot;</span> + data + <span class="string">&quot;，发送端的IP地址：&quot;</span> +</span><br><span class="line">datagramPacket.getAddress().getHostAddress() + <span class="string">&quot;，发送端的端口号是：&quot;</span> + datagramPacket.getPort());</span><br></pre></td></tr></table></figure></li><li><p>发送端程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要发送的数据</span></span><br><span class="line"><span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> <span class="string">&quot;hello world!&quot;</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得目的地 IP地址对象</span></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">inetAddress</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;10.21.150.9&quot;</span>) ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建发送数据的数据包，并指定数据要发往的IP地址和端口号</span></span><br><span class="line"><span class="type">DatagramPacket</span> <span class="variable">datagramPacket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(info.getBytes() , info.getBytes().length, inetAddress , <span class="number">8984</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建发送端的DatagramSocket对象，未指定端口号，系统会分配一个没有被使用的端口</span></span><br><span class="line"><span class="comment">//DatagramSocket datagramSocket = new DatagramSocket() ;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建指定从本机某个端口号发送数据包的DatagramSocket对象</span></span><br><span class="line"><span class="type">DatagramSocket</span> <span class="variable">datagramSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">3000</span>) ;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;向目标主机8984端口进行数据发送&quot;</span>);</span><br><span class="line">datagramSocket.send(datagramPacket);</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>需要注意的是，在创建发送端的DatagramSocket对象时，可以不指定端口号，而上述示例中指定端口号的目的是为了每次运行时接收端的getPort()方法的返回值是一致的，否则发送端的端口由系统自动分配，接收端的getPort()方法返回值每次都不同。</p></blockquote><h4 id="聊天程序"><a href="#聊天程序" class="headerlink" title="聊天程序"></a>聊天程序</h4><ul><li>监听信息类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Listener</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//接收方的DatagramSocket对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">DatagramSocket</span> <span class="variable">acceptSocket</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收方的DatagramPacket对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">DatagramPacket</span> <span class="variable">acceptPacket</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用于接收信息的byte数组</span></span><br><span class="line">    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>] ;</span><br><span class="line">    </span><br><span class="line">    Listener(<span class="type">int</span> acceptPort)&#123;</span><br><span class="line">        <span class="comment">//变量初始化</span></span><br><span class="line">        acceptPacket = <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes , <span class="number">0</span> , bytes.length) ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//接收端DatagramSocket必须要传入监听的的端口号</span></span><br><span class="line">            acceptSocket = <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(acceptPort) ;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            acceptSocket.receive(acceptPacket);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(acceptPacket.getData() , <span class="number">0</span> , acceptPacket.getLength()) ;</span><br><span class="line"><span class="comment">//        System.out.println(data  + &quot;发送方发送端口号是：&quot; + acceptPacket.getPort() );</span></span><br><span class="line">        System.out.println(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            listen();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>发送信息类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sender</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">//发送端的DatagramSocket对象与DatagramPacket对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">DatagramSocket</span> <span class="variable">sendSocket</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">DatagramPacket</span> <span class="variable">sendPacket</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数，传入发送</span></span><br><span class="line">    Sender(InetAddress destIP, <span class="type">int</span> sendToPort)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//初始化发送端DatagramPacket对象，并传入目标IP地址对象与端口号</span></span><br><span class="line">        sendPacket = <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(<span class="string">&quot;&quot;</span>.getBytes() , <span class="string">&quot;&quot;</span>.getBytes().length</span><br><span class="line">                , destIP , sendToPort) ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//发送信息的端口号可由系统随机指定未使用的端口</span></span><br><span class="line">            sendSocket = <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>() ;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要传输的数据：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> scanner.nextLine() ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置每次要发送的数据</span></span><br><span class="line">        sendPacket.setData(message.getBytes() , <span class="number">0</span> , message.getBytes().length  );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//将数据包发出</span></span><br><span class="line">            sendSocket.send(sendPacket);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="comment">//循环，不停发送信息</span></span><br><span class="line">            send();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>聊天类：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chat</span>  &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">Listener</span> <span class="variable">listener</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Sender</span> <span class="variable">sender</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">    </span><br><span class="line">    Chat( InetAddress destIP, <span class="type">int</span> sendToPort , <span class="type">int</span> acceptPort)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//传入发送信息目的主机的IP地址对象 和端口号 </span></span><br><span class="line">       sender = <span class="keyword">new</span> <span class="title class_">Sender</span>(destIP ,sendToPort) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Thread</span>(sender).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接受信息类传入本机接受信息的端口号，即接收端DatagramSocket对象监听的端口号</span></span><br><span class="line">       listener = <span class="keyword">new</span> <span class="title class_">Listener</span>(acceptPort) ;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Thread</span>(listener).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>main函数：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;请输入你要发往的目的端口号：&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">sendToPort</span> <span class="operator">=</span> scanner.nextInt() ;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;请输入你接受信息的端口号：&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">acceptPort</span> <span class="operator">=</span> scanner.nextInt() ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里是发往本机,也可以指定其他主机，用InetAddress.getByname()</span></span><br><span class="line"><span class="type">Chat</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chat</span>( InetAddress.getLocalHost(), sendToPort , acceptPort );</span><br></pre></td></tr></table></figure><p>在两个java文件中运行main函数，同时运行，开启两个窗口实现聊天功能</p><h3 id="TCP通信"><a href="#TCP通信" class="headerlink" title="TCP通信"></a>TCP通信</h3><ul><li>TCP 通信同UDP通信一样也是实现两台计算机之间的通信，但TCP通信的两端需要创建socket对象<ul><li>UDP通信与TCP通信的区别在于，UDP中只有发送端和接收端，不区分客户端与服务器端，计算机之间可以随意发送数据</li><li><strong>TCP 通信严格区分客户端与服务端</strong>，在通信时，必须先由客户端去连接服务器端才能实现通信，服务器端不能主动连接客户端，并且服务器端需要提前启动，等待客户端的连接。</li></ul></li><li>JDK中提供了两个用于实现TCP程序的类：<ul><li>ServerSocket 类，用于表示服务器端</li><li>Socket 类，用于表示客户端</li></ul></li><li>通信时，首先创建代表服务器端的 ServerSocket 对象，创建该对象相当于开启一个服务，此服务会等待客户端的连接；然后创建代表客户端的Socket 对象，使用该对象向服务器端发送请求连接，服务器响应请求后，两者才建立连接，开始通信。</li></ul><h4 id="ServerSocket"><a href="#ServerSocket" class="headerlink" title="ServerSocket"></a>ServerSocket</h4><ul><li>构造方法：</li></ul><table><thead><tr><th>方法声明</th><th>功能描述</th></tr></thead><tbody><tr><td>ServerSocket()</td><td>使用该构造方法在创建ServerSocket()对象时并没有绑定端口号，这样对象创建的服务器端没有监听任何端口，不可以正常使用，还需要继续调用bing(SocketAddress endpoint)方法将其绑定到指定的端口号上才可以正常使用</td></tr><tr><td>ServerSocket(int port)</td><td>使用该构造方法创建ServerSocket对象时可以将其绑定到一个指定的端口号上(参数port)。（端口号可以指定为0.此时系统就会分配一个还没有被其他网络程序所使用的的端口号，但并不常用）</td></tr><tr><td>ServerSocket(int port,int backlog)</td><td>该构造方法就是在构造方法2的基础上增加了一个backlog参数。该参数用于指定在服务器忙时，可以与之保持连接请求的等待客户的数量，如果没有指定这个参数，默认为50</td></tr><tr><td>ServerSocket(int port,int backlog,InetAddress bindAddr)</td><td>bindAddr参数用于指定相关IP地址。该构造方法适用于计算机上有多块网卡和多个IP的情况，使用时可以明确规定ServerSocket在哪块网卡或IP地址上等待客户的连接请求。一般也不经常使用。</td></tr></tbody></table><blockquote><p>如果端口被占用或者没有权限使用某些端口会抛出BindException错误。</p></blockquote><ul><li>常用方法：</li></ul><table><thead><tr><th>方法声明</th><th>功能描述</th></tr></thead><tbody><tr><td>Socket accept()</td><td>该方法用于等待客户端的连接，<strong>在客户端连接之前会一直处于阻塞状态</strong>，如果有客户端连接会返回一个与之对应的Socket对象</td></tr><tr><td>InetAddress getInetAddress()</td><td>该方法用于返回一个 InetAddress对象，该对象中封装了 ServerSocket 绑定的IP地址</td></tr><tr><td>boolean isColsed()</td><td>该方法用于判断ServerSocket 对象是否为关闭状态，若是关闭状态则返回true，否则返回false</td></tr><tr><td>void bind(SocketAddress endpoint)</td><td>该方法用于将ServerSocket 对象绑定到指定的IP地址和端口号，其中参数 endpoint封装了IP地址和端口号</td></tr></tbody></table><ul><li>ServerSocket 对象负责监听某台计算机的某个端口号，在创建ServerSocket对象后，需要继续调用该对象的accept()方法，接受来自客户端的请求。当执行了accept()方法后，服务器端程序发生阻塞，直到客户端发生连接请求时，accept()方法才会返回一个Socket()对象，用于和客户端实现通信，程序才能继续向下执行。</li></ul><h4 id="Socket-1"><a href="#Socket-1" class="headerlink" title="Socket"></a>Socket</h4><ul><li>Socket 类用于实现 TCP 客户端程序。</li><li>构造方法：</li></ul><table><thead><tr><th>方法声明</th><th>功能描述</th></tr></thead><tbody><tr><td>Socket()</td><td>使用该构造方法在创建 Socket 对象时，没有指定IP地址和端口号，只创建了客户端对象，并没有连接服务器。后续还需调用connect(SocketAddress endpoint)方法，才能完成与指定服务器端的连接。endpoint用于封装IP地址和端口号</td></tr><tr><td>Socket(String host,int port)</td><td>使用该构造方法在创建 Socket 对象时，会根据参数去连接在指定地址和端口上运行的服务器程序。其中，参数host 接收的是一个字符串类型的IP地址</td></tr><tr><td>Socket(InetAddress address,int port)</td><td>与方法二类似，参数address用于接收一个 InetAddress 类型的对象，该对象封装一个IP地址</td></tr></tbody></table><ul><li>常用方法：</li></ul><table><thead><tr><th>方法声明</th><th>功能描述</th></tr></thead><tbody><tr><td>int getPort()</td><td>该方法返回一个int 类型变量，该变量是 Socket对象与服务器端连接的端口号</td></tr><tr><td>InetAddress getLocalAddress()</td><td>该方法用于获取 Socket 对象绑定的本地 IP地址，并将 IP地址封装成 InetAddress类型的对象返回</td></tr><tr><td>void close()</td><td>该方法用于关闭 Socket 对象连接，结束本次通信。在关闭Socket对象之前，应将与 Socket相关的所有输入输出流全部关闭，一个良好的程序应该在执行完毕时释放所有资源</td></tr><tr><td>InputStream getInputStream()</td><td>该方法返回一个InputStream 类对象，如果该对象是由服务器端的 Socket 返回的，就用于读取客户端发送的数据；反之，用于读取服务器端发送的数据</td></tr><tr><td>OutputStream getOutputStream()</td><td>该方法返回一个OutputStream 类型的输出流对象，如果该对象是由服务器端的 Socket返回的，就用于向客户端发送数据；反之用于向服务器端发送数据。</td></tr></tbody></table><ul><li>当客户端与服务端建立连接后，数据是以 IO 流的形式进行交互的，从而实现通信。</li><li>基于Socket 的TCP通信：<img src="/%5Cimages%5Cjava_base5%5C05.png" alt="img"></li></ul><blockquote><p>Socket 类的 accept() 函数<a href="(https://zhuanlan.zhihu.com/p/490360921?utm_oi=776449486972030976)">深入理解</a>：</p><img src="\images\java_base5\06.png" alt="img" style="zoom:60%;" /></blockquote><h4 id="简单的TCP程序"><a href="#简单的TCP程序" class="headerlink" title="简单的TCP程序"></a>简单的TCP程序</h4><ul><li>服务端程序：（简化异常处理部分代码）</li><li>客户端与服务器端各有一个Socket，客户端程序accept()监听对应端口，程序将一直阻塞直到捕捉到一个来自Client端的请求，并<strong>返回一个专门用于与该Client通信的Socket对象Link-Socket。</strong>此后Server程序只要向这个Socket对象读写数据，就可以实现向远端的Client读写数据。结束监听时，关闭ServerSocket对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将该服务器绑定到主机的8000号端口</span></span><br><span class="line"><span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务器端与客户端获得连接后，获取Socket对象，若未连接会阻塞在此处</span></span><br><span class="line"><span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取输出流</span></span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> client.getOutputStream();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;，与客户端完成连接，向客户端传送数据：&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过输出流，写入数据到 数据通道</span></span><br><span class="line">outputStream.write(<span class="string">&quot;你好&quot;</span>.getBytes() );</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待3秒</span></span><br><span class="line">Thread.sleep(<span class="number">3000</span>) ;</span><br><span class="line"></span><br><span class="line">outputStream.write(<span class="string">&quot;好好学习java&quot;</span>.getBytes() );</span><br><span class="line"></span><br><span class="line"><span class="comment">//结束与客户端交互数据并释放资源</span></span><br><span class="line">outputStream.close();</span><br><span class="line">client.close();</span><br></pre></td></tr></table></figure><ul><li>客户端程序：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端向 指定IP地址和端口号的服务端发送连接</span></span><br><span class="line"><span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span> , <span class="number">8000</span>) ;</span><br><span class="line"></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> client.getInputStream();</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">readLength</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取服务器端写入到数据通道的数据并输出//这里是直到服务器端的outputStream关闭才会结束输入流的读取</span></span><br><span class="line"><span class="keyword">while</span>((readLength = inputStream.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">    </span><br><span class="line">System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="number">0</span> ,readLength));</span><br><span class="line">&#125;</span><br><span class="line">                </span><br><span class="line">inputStream.close();</span><br><span class="line"></span><br><span class="line">client.close();</span><br></pre></td></tr></table></figure><ul><li><p>若是Socket 对象要接收信息，又要输出信息，同时启用OutputStream和InputStream，，则启用另一个时要关闭正在使用的流。比如服务端已经接收完输入流的信息，但输入流不知道何时输入结束会一直读取不会关闭，若此时需要调用输出流就会出现阻塞，而一个数据源不能同时有两个流在操作，此时需要给已经使用结束的流设置结束标记。调用socket.shutdownOutput( ）  &#x2F;  shutdownInput()</p><ul><li>例如，服务端向客户端发送数据后再接收来自客户端的消息，则在发送数据结束后要调用socket.shutdownOutput() .</li><li>🐳669节</li></ul></li><li><p>也可用字符流编程，利用字符转换流，</p><ul><li>注意用字符流写入结束时要调用flush函数，冲刷输出在缓冲区的数据</li><li>用字符流输出时调用了缓冲输出字符流的newline()时，要求读取数据时，必须使用包装流BufferedReader.readLine()</li><li>670节</li></ul></li><li><p>当客户端连接到服务器时，实际上客户端也是通过一个端口和服务端进行通讯的，这个端口是 TCP&#x2F;IP 分配的，是不确定的，随机的。可以调用client.getLocalPort();返回该Socket 对象绑定的端口号</p></li></ul><h4 id="多线程的TCP网络程序"><a href="#多线程的TCP网络程序" class="headerlink" title="多线程的TCP网络程序"></a>多线程的TCP网络程序</h4><ul><li>实际上很多服务器端程序都是允许被多个应用程序访问的，例如门户网站可以被多个用户同时访问，因此<strong>服务器都是多线程的</strong>。</li><li>某个端口同一时间只能有一个ServerSocket ，但可以监听并处理多个连接请求，ServerSocket可以返回多个Socket，也就是多个客户端连接服务器的高并发</li><li>多个客户端访问同一个服务器端，<strong>服务器端为每一个客户端创建一个对应的Socket，并且开启一个新的线程使两个Socket建立专项通信</strong>。</li><li>多线程的服务器端程序：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">TCPServer</span>().listen(); ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TCPServer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">8000</span> ;</span><br><span class="line">    <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line"></span><br><span class="line">    TCPServer() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">      serverSocket = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(PORT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//监听发向端口8000的连接请求</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//与客户端建立连接完成，lambda表达式实现Runnable接口，为每一个客户端创建一个新线程</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> client.getOutputStream();</span><br><span class="line">                    System.out.println(<span class="string">&quot;建立连接&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    os.write(<span class="string">&quot;你好,您已经与服务器建立连接&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">&quot;结束交互&quot;</span>);</span><br><span class="line">                    os.close();</span><br><span class="line"></span><br><span class="line">                    client.close();</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><ul><li><p>从服务器端下载图片文件到本地指定目录下</p></li><li><p>服务器端</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span>&#123;</span><br><span class="line">    <span class="type">ServerSocket</span> <span class="variable">sever</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">    <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;D:\\kaori.jpg&quot;</span> ;</span><br><span class="line">    Server()&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//服务器与8000端口绑定</span></span><br><span class="line">            sever = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8000</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;等待客户端连接：&quot;</span>);</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> sever.accept() ;</span><br><span class="line">            System.out.println(<span class="string">&quot;连接成功！&quot;</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;开始发送数据！&quot;</span>);</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath) ;</span><br><span class="line"></span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>] ;</span><br><span class="line">            <span class="type">int</span> readLength ;</span><br><span class="line">            <span class="keyword">while</span>((readLength = is.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">                os.write(bytes,<span class="number">0</span>,readLength);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            os.close();</span><br><span class="line">            is.close();</span><br><span class="line">            socket.close();</span><br><span class="line">            sever.close();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>用户端：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Client</span>&#123;</span><br><span class="line">    <span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">    <span class="type">String</span> <span class="variable">destFilePath</span> <span class="operator">=</span> <span class="string">&quot;D:\\Program Files\\kaori.jpg&quot;</span> ;</span><br><span class="line">    Client()&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//客户端连接指定InetAddress和端口的 服务器</span></span><br><span class="line">            client = <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getLocalHost() , <span class="number">8000</span>) ;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取服务器端的输出的信息流</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> client.getInputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将服务器端输出的数据流，输出到本地指定目标位置下</span></span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFilePath) ;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> readLength ;</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>] ;</span><br><span class="line">            <span class="keyword">while</span>((readLength = is.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//通过FileOutputStream，将从数据传输通道读取的数据下载到本地指定位置</span></span><br><span class="line">                os.write(bytes, <span class="number">0</span> , readLength);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//释放资源</span></span><br><span class="line">            os.close();</span><br><span class="line">            is.close();</span><br><span class="line">            client.close();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;java网络编程&quot;&gt;&lt;a href=&quot;#java网络编程&quot; class=&quot;headerlink&quot; title=&quot;java网络编程&quot;&gt;&lt;/a&gt;java网络编程&lt;/h1&gt;&lt;p&gt;java是Internet上的语言，它从语言级上提供对网络应用程序</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Code Aesthetic</title>
    <link href="https://pengzhanyi.github.io/2023/10/23/Code-Aesthetic/"/>
    <id>https://pengzhanyi.github.io/2023/10/23/Code-Aesthetic/</id>
    <published>2023-10-23T09:11:05.000Z</published>
    <updated>2023-10-23T10:43:57.164Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://www.bilibili.com/video/BV14u411u7sJ/">视频</a></li></ul><h1 id="代码美学"><a href="#代码美学" class="headerlink" title="代码美学~"></a>代码美学~</h1><h2 id="代码命名"><a href="#代码命名" class="headerlink" title="代码命名"></a>代码命名</h2><ul><li><p>java代码命名规则：</p><ul><li>所有的package名一律小写。</li><li>类名和接口名每个单词的首字母都要大写，如ArrayList，Iterator</li><li>常量名所有字母都大写，单词之间用下划线连接，如DAY_OF_MONTH</li><li>变量名和方法名第一个单词首字母小写，从第二个单词开始，每个单词首字母大写：如getName,setAge</li><li>在程序中尽量使用有意义的英文单词来定义标识符，增强程序可读性</li></ul></li><li><p>tips</p><ul><li><p>不要用无意义的单个字符或不容易辨认的字符组合(比如单词缩写)命名</p></li><li><p>在变量名中加上单位</p><ul><li>这样使用该变量的用户可以通过变量名理解该变量的单位和信息</li><li>例： void execut(int delaySeconds) ;</li><li>此处由此可知应传入秒数为参数,</li></ul></li><li><p>类的命名中不要加入 Abstract , Base等不宜理解的词</p></li><li><p>最好不要将类名设置为已存在标准库类类名 如”Utils”</p></li></ul></li></ul><h2 id="组合优于继承"><a href="#组合优于继承" class="headerlink" title="组合优于继承"></a>组合优于继承</h2><ul><li><p><a href="https://zhuanlan.zhihu.com/p/60282972#:">相关解析</a></p></li><li><p>两者都是为了解决代码复用问题</p></li><li><p>继承的缺点：</p><ul><li>在java中，类只能单根继承。也就是说，一个类只能有一个父类，不能同时继承两个父类，java无法通过继承的方式，重用多个类中的代码。</li><li>子类会与基类发生耦合，父类的属性和方法，子类是无条件全部继承的。为了复用其中的某个方法而创建子类却必须要继承父类的所有函数，即是有些函数可能对子类毫无意义，使用继承很容易造成方法的污染。一旦父类的属性和方法，在子类中不能完全适用。那么，也就不应该使用继承关系了。</li></ul></li><li><p>使用组合完成代码，用接口同样能实现类似继承实现的多态效果</p><ul><li>在接口中集成想要能多态调用的函数，将对象以接口形式作为参数传入对应函数，在其中调用接口函数（依赖注入）</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV14u411u7sJ/&quot;&gt;视频&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;代码美学&quot;&gt;&lt;a href=&quot;#代码美学&quot; class=&quot;headerlink&quot; title=&quot;代码</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>java基础- 基于面向对象的应用_2</title>
    <link href="https://pengzhanyi.github.io/2023/10/20/java-base4/"/>
    <id>https://pengzhanyi.github.io/2023/10/20/java-base4/</id>
    <published>2023-10-19T16:15:00.000Z</published>
    <updated>2023-11-10T03:17:50.228Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="泛型引入："><a href="#泛型引入：" class="headerlink" title="泛型引入："></a>泛型引入：</h2><ul><li>案例<ul><li><p>若想打印数字：创建一个数字打印类</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IntegerPrint</span>&#123;</span><br><span class="line">    Integer content ;</span><br><span class="line">    IntegerPrint(Integer input)&#123;</span><br><span class="line">        <span class="built_in">this</span>.content = input ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main中：</span></span><br><span class="line"><span class="type">IntegerPrint</span> <span class="variable">integerPrint</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntegerPrint</span>(<span class="number">100</span>) ;</span><br><span class="line">integerPrint.print() ;</span><br></pre></td></tr></table></figure></li><li><p>若想打印字符串，则需再创建一个字符串打印类：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringPrint</span>&#123;</span><br><span class="line">    String content ;</span><br><span class="line">    StringPrint(String input)&#123;</span><br><span class="line">        <span class="built_in">this</span>.content = input ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main中：</span></span><br><span class="line"><span class="type">StringPrint</span> <span class="variable">stringPrint</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringPrint</span>(<span class="string">&quot;hello&quot;</span>) ;</span><br><span class="line">stringPrint.print() ;</span><br></pre></td></tr></table></figure></li><li><p>代码高度重复，为避免，引入泛型，只需创建一个类就可以处理所有的类型：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Print</span>&lt;T&gt;&#123;<span class="comment">//用&lt;T&gt;声明泛型类，占位符T表示这个类可以传入任何类型的参数(可以用任何字符来取代这个T)，可以声明多个类型参数</span></span><br><span class="line">    T content ; <span class="comment">//具体的T的类型是由调用时决定，这里相当于把类型参数当做一个特殊的参数，根据传入的参数决定这里的T</span></span><br><span class="line">    Print(T input)&#123;</span><br><span class="line">        <span class="built_in">this</span>.content = input ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main中：</span></span><br><span class="line">Print&lt;Integer&gt; printInteger = <span class="keyword">new</span> <span class="title class_">Print</span>&lt;&gt;(<span class="number">99</span>); <span class="comment">//使用泛型类需要声明类型，且传入的类型不能为基础数据类型</span></span><br><span class="line">printInteger.print();</span><br><span class="line">Print&lt;String&gt; printString = <span class="keyword">new</span> <span class="title class_">Print</span>&lt;&gt;(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">printString.print() ;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="泛型内容"><a href="#泛型内容" class="headerlink" title="泛型内容"></a>泛型内容</h2><ul><li><p>简介：</p><ul><li>泛型又称参数化类型，jdk5.0出现，解决数据类型的安全性问题</li><li>可以认为<strong>泛型是一种表示数据类型的数据类型</strong></li><li>在类声明或实例化时只要指定好需要的类型即可</li><li>java的泛型使用后在编译阶段就会进行类型检查</li></ul></li><li><p>泛型的作用：可以在类声明时通过一个标识表示类中某个属性的类型，或某个方法的返回值的类型或是参数类型</p></li><li><p>泛型语法：</p><ul><li><p>泛型的声明：</p><ul><li>接口中泛型： interface 接口<T>{} </li><li>类中的泛型： class 类名&lt;K , V…&gt;{}</li></ul></li><li><p>其中的T，K，V不代表值，而只是占位符，表示类型,可以有多个</p></li><li><p>占位符用任何字符都可以，但常用T（Type）</p></li><li><p>占位符的具体类型在编译期间就确定，</p><ul><li>如在类Class Person<T>{}，</li><li>在创建实例对象时Person <Integer>person &#x3D; new Person() ;时确定T为Integer</li><li>此时相当于把Person类内所有的T 换成 Integer</li></ul></li><li><p>泛型的实例化：要在类名后指定类型参数的值</p><ul><li>List<String> strList &#x3D; new ArrayList&lt;&gt;();</li><li><u>这里后面的&lt;&gt;中可以为空,编译器会进行类型推断</u>,推荐这种简写形式</li><li>Iterator<Customer> iterator &#x3D; customer.iterator();</li></ul></li></ul></li><li><p>泛型细节：</p><ul><li>普通成员包括属性方法等可以使用泛型</li><li><strong>使用泛型的数组不能初始化</strong></li><li><strong>静态方法中不能使用类的泛型</strong></li><li>泛型类的类型在创建对象时确定（在创建对象时指定类型）</li><li>如果在创建对象时没有指定类型，默认为Object类<ul><li>例：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> &lt;T&gt;&#123;</span><br><span class="line">    T info ;</span><br><span class="line">    Bus(T info)&#123;</span><br><span class="line">        <span class="built_in">this</span>.info = info ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main:</span></span><br><span class="line"><span class="type">Bus</span> <span class="variable">test1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bus</span>&lt;&gt;(<span class="string">&quot;hhk&quot;</span>);</span><br><span class="line">System.out.println(test1.info);</span><br><span class="line">test1.info = <span class="number">123</span> ;</span><br><span class="line">System.out.println(test1.info);</span><br></pre></td></tr></table></figure></li><li>因为创建对象时没有指定类型故为Object类，故String作为Object的子类可以被传入，而int类数据123，在这个过程中完成了自动装箱为Integer类，故可以被info接收</li></ul></li></ul></li><li><p>自定义泛型示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &lt;T&gt;&#123;</span><br><span class="line">    T information ;</span><br><span class="line"></span><br><span class="line">    Student(T information)&#123;</span><br><span class="line">        <span class="built_in">this</span>.information = information ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.information + <span class="string">&quot;&quot;</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main:（模拟HashSet创建）</span></span><br><span class="line"> HashMap&lt;Student , Object&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();/</span><br><span class="line"> </span><br><span class="line"><span class="type">Object</span> <span class="variable">PRSENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>() ;</span><br><span class="line"></span><br><span class="line">hashMap.put (<span class="keyword">new</span> <span class="title class_">Student</span>&lt;&gt;(<span class="string">&quot;jack&quot;</span>) , PRSENT);</span><br><span class="line">hashMap.put (<span class="keyword">new</span> <span class="title class_">Student</span>&lt;&gt;(<span class="string">&quot;Mike&quot;</span> ), PRSENT) ;</span><br><span class="line">Set&lt;Map.Entry&lt;Student,Object&gt;&gt; set = hashMap.entrySet() ;</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Student,Object&gt; entry : set)&#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span>  entry.getKey();</span><br><span class="line">    System.out.println(student);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>泛型注意事项</p><ul><li>占位符 T，E只能是引用类型，不能是基础数据类型</li><li>在指定泛型具体类型后，可以传入该类型或者其子类型</li></ul></li></ul><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><ul><li>interface 接口名&lt;T,R ….&gt;{}</li><li>接口中，静态成员也不能使用泛型</li><li>泛型接口的类型，在继承接口或者实现接口时确定</li><li>没有指定类型则默认为Object（最好不要这样）</li></ul><h2 id="在函数中使用泛型"><a href="#在函数中使用泛型" class="headerlink" title="在函数中使用泛型"></a>在函数中使用泛型</h2><ul><li><p>修饰符&lt;T,R…&gt; 返回类型 方法名(参数列表){}</p></li><li><p>generic method</p></li><li><p>细节：</p><ul><li>泛型方法可以别定义在普通类中，也可以定义在泛型类中</li><li>当泛型方法被调用时，类型会确定</li><li>如 void eat(E e){}，修饰符后没有&lt;T,R..&gt;,并不是泛型方法，只是使用了泛型<ul><li>泛型方法可以使用类声明的泛型，也可以使用自己声明的泛型</li><li>使用时最好将这二者分开，用不同的字符表示</li></ul></li></ul></li><li><p>例：实现一个打印任何类型变量的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T , K&gt; <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(T content1 , K content2)</span>&#123;</span><br><span class="line">    System.out.println(content1) ;</span><br><span class="line">    System.out.println(content2) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main中</span></span><br><span class="line">print(<span class="string">&quot;hello&quot;</span> , <span class="number">11</span>) ;</span><br></pre></td></tr></table></figure></li><li><p>好像不常用，更好的是用通配符</p></li></ul><h2 id="类型安全"><a href="#类型安全" class="headerlink" title="类型安全"></a>类型安全</h2><ul><li><p>需求引入</p><ul><li>传统的方法不能对加入集合中的数据类型进行约束(不安全)  </li><li>在取出集合中的元素进行操作时需要进行强制类型转换，不仅影响效率也容易发生类型转换异常</li></ul></li><li><p>解决方案——泛型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> String name;<span class="comment">//为简化代码这里使用public</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main中：</span></span><br><span class="line">ArrayList&lt;Dog&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Dog</span>());</span><br><span class="line"><span class="keyword">for</span>(Dog dog : list)&#123;</span><br><span class="line">    dog.name = <span class="string">&quot;jack&quot;</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>用ArrayList<Dog> 表示存放到ArrayList集合中的元素只能是Dog类型（或Dog类的子类），表示一种约束</li><li>如果编译器发现加入的类型不满足要求会报错，</li><li>在遍历时可以直接取出Dog类型的数据而不是Object</li></ul></li><li><p>泛型的类型约束——有界限的泛型</p><ul><li>bounded generics</li><li>用具体的类约束（常在集合框架中使用）：如上述示例</li><li>用类约束：public class Test <T extends Dog>{} ;表示只能接受Dog类的子类或Dog类本身</li><li>用接口约束：public class Test<T implemnts Comparable>{};表示只能接收实现Comparable接口的类</li></ul></li><li><p>泛型好处：</p><ul><li><strong>编阶段检查添加元素的类型</strong>，提高了安全性</li><li>减少类型强制转换的次数，提高效率，</li><li>不再提示编译警告</li></ul></li></ul><h2 id="泛型的继承和通配符"><a href="#泛型的继承和通配符" class="headerlink" title="泛型的继承和通配符"></a>泛型的继承和通配符</h2><ul><li><p>泛型不具备继承性</p></li><li><p>通配符 ? 支持任意泛型类型</p><ul><li><? extends A> :表示允许传入A类已经A的子类</li><li><? super A> :表示支持A类及A类的父类</li><li><? implements A>：表示允许传入实现A接口的类</li></ul></li><li><p>通配符“ ？ ”</p><ul><li>? 处可以匹配所有的类型  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(List&lt;?&gt; content)</span>&#123;</span><br><span class="line">    System.out.println(content) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>注意此处不认为用Object可以起相同作用  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(List&lt;Object&gt; content)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>  因为String和Integer虽然是Object的子类，但List&lt; String &gt; 并不是List&lt; Object &gt;的子类，List&lt; String &gt;是一个整体</li></ul></li><li><p>一个讲泛型挺好的<a href="https://www.bilibili.com/video/BV1H94y1a7bJ/">视频</a></p></li></ul><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><ul><li>线程相关概念<ul><li><p>程序：是为完成任务，用语言编写的一组指令的集合</p></li><li><p>进程</p><ul><li>进程：进程是指运行中的程序，比如当我们使用一个程序QQ，操作系统就会为该进程分配内存空间，每当启动新的进程，操作系统就会为该进程分配新的内存空间</li><li>进程是程序的一次执行的过程，或是正在运行的一个程序，是动态过程，有它自身的产生，存在和消亡的过程</li></ul></li><li><p>线程：</p><ul><li>线程由进程创建，是进程的一个实体</li><li>一个进程可以拥有多个线程</li></ul></li><li><p>进程是操作系统资源分配的基本单位 ，线程是操作系统可识别的最小执行和调度单位。</p></li><li><p>其他概念：</p><ul><li>并发：同一时刻，多个任务交替执行，但CPU在交替执行时切换速度极快造成一种“貌似同时”的错觉。简单的说，单核CPU实现的多任务就是并发</li><li>并行：同一时刻，多个任务同时执行，多核CPU可以实现并行</li><li>并发和并行在电脑中可能会同时发生  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line"><span class="type">int</span> <span class="variable">cpuCounts</span> <span class="operator">=</span> runtime.availableProcessors();</span><br><span class="line">System.out.println(<span class="string">&quot;当前电脑可用处理器数量：&quot;</span> + cpuCounts);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="线程的使用："><a href="#线程的使用：" class="headerlink" title="线程的使用："></a>线程的使用：</h2><ul><li><p>创建线程的两种方式：</p><ul><li><p>继承 Thread 类 ，重写run方法</p><ul><li>当一个类继承了Thread类，重写 run 方法 ，该类就可用当做线程使用</li></ul></li><li><p>实现Runnable接口，重写run方法</p><ul><li>run方法是Runnable接口中的抽象函数,通过Thread(Runnable target)构造方法创建线程对象，为该方法传递一个实现了Runnable接口的实例对象，创建的线程将会调用实现Runnable接口的run()方法</li></ul></li></ul></li><li><p>继承Thread类创建线程</p><ul><li><p>例：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;hello 线程 &quot;</span> + <span class="built_in">this</span>.getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);<span class="comment">//Ctrl+Alt+t 用try-catch包围，或Alt+Enter选择解决方法</span></span><br><span class="line">                <span class="comment">///millis为休眠时长，以毫秒为单位</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里只能捕获异常，因为父类Thread类的run方法没有抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main function:</span></span><br><span class="line"><span class="type">MyThread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">thread1.start();<span class="comment">//线程的start方法调用时，线程启动,且会自动调用该线程的run方法</span></span><br></pre></td></tr></table></figure></li><li><p>解析，当这段程序启动时就启动了一个进程，进程进入main方法后，进程开启了一个主(main)线程，在主线程中创建了一个新的thread1并启动,</p><ul><li>当main线程启动一个子线程 Thread-0 时， 主线程不会阻塞，即不会等待Thread-0执行完成后才执行之后的语句，而是会直接继续执行</li><li>如可以在上述main方法中，thread.start()后添加以下语句,观察输出：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;主线程在执行 ：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;主线程 i = &quot;</span> + i);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>用jconsole工具监视线程：582节</p><ul><li>并不是主线程结束后进程就会结束，main线程可以先于main的子线程结束，main方法只是程序的一个入口，</li><li>两个线程独立运行，只有所有线程运行结束后，进程才会结束</li></ul></li></ul><blockquote><p>为什么在main中调用线程的 start 方法，而不调用重写的 run方法 ，thread1.run() ？<br>若是直接调用run方法，只会在同一个线程中执行该方法，并没有真正启动一个线程，只是一个普通的main线程中方法调用，程序会阻塞在这里，直到这个函数执行结束，此处线程名也是main<br>查看源码，start()中主要是 start0()起作用实现多线程的效果，start0()是(native)本地方法，是JVM调用，底层是C&#x2F;C++ 实现<br><img src="/images/java_base4/01.png" alt="img"></p></blockquote></li><li><p>实现Runnable接口创建线程</p><ul><li><p>因为java的单继承机制，则已有父类的类无法继承Thread类来创建线程，故通过实现Runnable接口再创建线程</p></li><li><p>例：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main:</span></span><br><span class="line"><span class="type">MyThread2</span> <span class="variable">myThread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread2</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myThread2) ; </span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure></li><li><p>此处myThread2 不能直接调用start方法，因为Runnable接口中只有run方法</p></li><li><p>调用Thread的有参构造函数，传入一个实现了Runnable接口的类的对象。</p></li><li><p><strong>Runnable 接口是函数式接口</strong>，可以使用Lambda表达式简化这个实现接口的过程</p></li><li><p>这里底层使用了设计模式（代理模式）</p></li><li><p>线程代理类，模拟极简Thread类（对比Thread类源码）:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadProxy</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(target != <span class="literal">null</span>)&#123;</span><br><span class="line">            target.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadProxy</span><span class="params">(Runnable target)</span>&#123;<span class="comment">//Runnable类型参数</span></span><br><span class="line">        <span class="built_in">this</span>.target = target ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        start0() ;<span class="comment">//这个方法真正实现多线程方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>&#123;</span><br><span class="line">        run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>继承 Thread 与实现 Runnable 的区别</p><ul><li>从java的设计来看，通过继承Thread或实现Runnable来创建线程 从本质上没有区别，从jdk文档我们可以看到Thread类本身就实现了Runnable接口</li><li>实现Runnable接口方式更适合多个线程共享一个资源的情况，并且避免了单继承的限制，同时把并行运行的任务与多线程运行机制解耦。</li><li>建议使用Runnable接口方式</li></ul></li><li><p>多线程的问题： 586节例，当多个线程同时进入run操作同一块数据，可能会造成数据的越界，（比如票只有一张时，两个线程同时进入了卖票的代码，于是他们都判断为可以继续售票，于是两个线程都出售了票，票数变为-1）</p></li><li><p>线程终止</p><ul><li>当线程完成任务后，会自动退出</li><li>还可以通过使用变量来控制run方法退出的方式停止线程，即<u>通知方式</u></li><li>例：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(loop)&#123;</span><br><span class="line">            <span class="comment">//执行语句</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLoop</span><span class="params">(<span class="type">boolean</span> loop)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.loop = loop ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main:</span></span><br><span class="line"><span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">Thread.sleep(<span class="number">10</span>*<span class="number">1000</span>);<span class="comment">//主线程休眠十秒</span></span><br><span class="line">myThread.setLoop(<span class="literal">false</span>) ;<span class="comment">//由此可以在主线程中控制子线程的终止</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="线程的调度"><a href="#线程的调度" class="headerlink" title="线程的调度"></a>线程的调度</h2><ul><li><p>在计算机中，线程调度有两种模型，分时调度模型和抢占式调度模型</p><ul><li>分时调度模型：是指让所有的线程轮流获得CPUDB使用权，并且平均分配每个线程占用的CPU的时间片。</li><li>抢占式调度模型：是指让可运行池中优先级高的线程优先使用CPU，而对于优先级相同的线程，随机选择一个线程使其占用CPU，它执行完任务后，在随机选择其他线程获取CPU资源。</li><li>java虚拟机默认采用抢占式调度模型</li></ul></li><li><p>线程的优先级，对线程进行调度根据线程的优先级，优先级越高的线程获取CPU执行的机会越大</p><ul><li>线程的优先级范围： 查看源码，默认优先级是5，最低优先级是1，最高优先级是10<ul><li>Thread类中提供的是哪个静态常量表示线程的优先级  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示线程的最低优先级，值为1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MIN_PRIORITY</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">//表示线程的默认普通优先级，值为5</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NORM_PRIORITY</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">//表示线程的最高优先级，值为10</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAX_PRIORITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li>线程的优先级并不是一成不变的，可以通过Thread类的 setPriority() 方法设置</li></ul></li></ul><blockquote><p>虽然java中提供了10个线程优先级，但是这些优先级需要操作系统的支持。不同的操作系统对优先级的支持不同，不会与java线程优先级一一对应。<strong>因此在设计多线程应用程序时，其功能的实现一定不能依赖与优先级，而只能把线程优先级作为一种提高程序效率的手段。</strong></p></blockquote><h2 id="线程的声明周期"><a href="#线程的声明周期" class="headerlink" title="线程的声明周期"></a>线程的声明周期</h2><ul><li><p>JDK中用Thread.State枚举表示了线程的几种状态：<br><img src="/images/java_base4/02.png" alt="img"></p></li><li><p>有时称线程的七种状态是指将Runnable状态分为，ready（可执行但还未执行状态）和running (正在运行状态)  ，线程是否进入running状态取决于线程是否被调度器选中，获取CPU资源并执行<br><img src="/images/java_base4/03.png" alt="img"></p></li></ul><h2 id="线程常用方法："><a href="#线程常用方法：" class="headerlink" title="线程常用方法："></a>线程常用方法：</h2><p>- </p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>void setName(String name)</td><td>设置线程名称</td></tr><tr><td>String getName()</td><td>获得线程名称</td></tr><tr><td>void start()</td><td>使线程开始执行，底层调用该线程的start0()方法</td></tr><tr><td>void run()</td><td>调用该线程的run方法</td></tr><tr><td>void setPriority(int newPriority)</td><td>更改线程的优先级</td></tr><tr><td>int getPriority()</td><td>获取线程的优先级</td></tr><tr><td>public static native void sleep(long millis)</td><td>在指定的毫秒数内让当前正在执行的线程休眠，暂停执行</td></tr><tr><td>public void interrupt()</td><td>中断线程，底层调用该线程的interrupt0()方法</td></tr></tbody></table><ul><li><p>细节：</p><ul><li><p>currentThread() ： Thread的静态方法，用于返回当前正在执行的线程</p></li><li><p>start 底层启动建新的线程，调用run，run只是一个简单的方法调用，不会启动新线程</p></li><li><p>interrupt，中断线程，但并没有真正结束线程，故一般用于中断正在休眠的线程，提前结束休眠，并不是终止线程</p></li><li><p>sleep() ：线程中的静态方法，使当前线程休眠（只能控制正在运行的线程休眠，而不能控制其他线程休眠。当休眠结束后线程会返回到ready状态，而不是立即进入running）</p></li></ul></li><li><p>常用方法2：</p><ul><li><p>yield() ：<u>Thread类的静态方法</u>，是当前<strong>线程的“让步”</strong>,当前正在运行的线程暂停 ，释放自己拥有的CPU，线程进入就绪状态当某个线程调用了yield()方法之后，只有与当前线程优先级相同或更高的线程才有获得执行的机会。</p><ul><li>但是，并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权；也有可能是当前线程又进入到“运行状态”继续运行。这取决于当前线程资源是否紧张，cpu资源丰富时，yield不一定成功</li><li>yield()与sleep()有些类似，都可以让当前正在运行的线程暂停，区别在于yield()不会阻塞该线程，它只是将线程转化为 就绪状态，让系统的调度器重新调度一次</li></ul></li><li><p>join() :线程的插队。插队的线程一旦插队成功，则肯定先<strong>执行完</strong>插入线程的所有任务。当某个线程中调用其他线程的join()方法时，调用的线程将被阻塞，直到被join()方法加入的线程执行完后它才会继续执行。<a href="https://zhuanlan.zhihu.com/p/258581678">相关解析</a></p></li></ul></li></ul><h2 id="用户线程和守护线程"><a href="#用户线程和守护线程" class="headerlink" title="用户线程和守护线程"></a>用户线程和守护线程</h2><ul><li><p>用户线程：也叫工作线程，当线程的任务执行完或通知结束</p></li><li><p>守护线程：一般是为工作线程服务的，当所有的用户线程结束，守护线程自动结束</p></li><li><p>线程的setDaemon(true)，将线程设置为守护线程，且要在该线程start()之前设置,当所有线程结束后守护线程才会结束。</p></li><li><p>常见的守护线程：垃圾回收工作机制</p></li><li><p><a href="https://www.twle.cn/c/yufei/javatm/javatm-basic-daemon-thread.html">相关文章</a></p></li></ul><h2 id="线程的同步机制"><a href="#线程的同步机制" class="headerlink" title="线程的同步机制"></a>线程的同步机制</h2><ul><li><p>为了解决如之前提到的多线程买票发生的线程安全问题，引入线程同步机制</p></li><li><p>同步机制简介：</p><ul><li>在多线程编程中，一些敏感数据不允许被多个线程同时访问，此时就是用同步访问技术，保证在任何同一时刻，最多有一个线程访问，以保证数据的完整性</li><li>线程同步，即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作</li></ul></li><li><p>同步具体方法：<strong>synchronized</strong></p><ul><li><p>1 同步代码块：  当多个线程使用同一个共享资源时，可以将处理共享资源的diamante放在一个使用synchronized关键字来修饰的代码块中  ，这个代码块被称作同步代码块</p><ul><li>语法如下：<br>  synchronized ( lock ){&#x2F;&#x2F;lock是一个锁对象，它是同步代码块的关键<br>  &#x2F;&#x2F;需要被同步的代码，操作共享资源块<br>  }</li><li>例：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mythred</span>() ;</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable) ;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable) ;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable) ;</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line">    thread3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mythred</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>() ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">            <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                <span class="keyword">if</span>(num &gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    num -- ;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 票还有&quot;</span> + num);</span><br><span class="line">                    <span class="keyword">return</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;sold out&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上述代码的中lock是一互斥锁对象。同一时间只能有一个线程执行同步代码块，当某个线程获得lock锁后，执行同步代码块，其他线程无法执行当前同步代码块，发生阻塞。等当前线程执行完同步代码块归还lock后，所有在等待lock的线程开始抢夺lock，抢到lock的线程将进入同步代码块，执行其中的代码。<br>同步代码块的锁对象可以是任意类型的对象，<strong>但多个线程共享的锁对象必须是唯一的</strong>。锁对象的创建代码不能放到run()方法中，否则每个线程运行到run()方法时都会创建一个新对象，这样每个线程都会有一个不同的锁，每个锁有自己的标志位，这样线程之间不能产生同步的效果。</p></blockquote></li></ul></li><li><p>2 同步方法：  被synchronized修饰的方法在某一时刻只允许一个线程访问，访问该方法的其他线程都会发生阻塞，直到当前线程访问完毕后，其他线程才有机会执行该方法</p><ul><li>语法：<br>  public synchronized void funtionName(){<br>  &#x2F;&#x2F;需要被同步的代码<br>  } </li><li>例：（注意不要给run方法设置synchronized，否则只会有一个线程进入run方法，执行对应的sell直到结束）  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mythred</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                sell();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num &gt;<span class="number">0</span>)&#123;</span><br><span class="line">            num -- ;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 票还有&quot;</span> + num);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;sold out&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="互斥锁："><a href="#互斥锁：" class="headerlink" title="互斥锁："></a>互斥锁：</h2><ul><li><p>java中引入互斥锁的概念，来保证共享数据操作的完整性</p></li><li><p>每一个<strong>对象</strong>都对应一个称为”互斥锁”的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象</p></li><li><p>关键字synchronized 来与对象的互斥锁联系。当某个对象用synchronized修饰时，表明该对象任一时刻只能有一个线程访问</p></li><li><p>synchronized关键字可以用在方法或代码块中，<strong>被锁定的是对象，而不是代码</strong>。当一个线程进入被synchronized锁定的代码块时，其他线程将被阻塞，直到当前线程释放锁定。</p></li><li><p>同步的局限性：导致程序的执行效率要降低</p></li><li><p>同步方法(非静态)的锁可以是this（当前对象），也可以是其他对象（要求是同一个对象）</p><ul><li>例如：public synchronized void sell(){},就是一个同步方法，这时锁在this对象上<ul><li>上代码示例中锁就在runnable 对象上，若是三个线程用不同的Runnable对象初始化，则不能实现同步</li></ul></li><li>同步代码块，一般互斥锁仍使用this对象<ul><li>例：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;<span class="comment">//</span></span><br><span class="line">        <span class="comment">//sell执行语句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>同步方法(静态)的锁为该方法所在类的class对象。</p><ul><li>例：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">a1</span><span class="params">()</span>&#123;&#125;<span class="comment">//同步方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">a2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(A.class)&#123;<span class="comment">//这里同步代码块要用当前类作为锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>注意事项:</p><ul><li><p>同步方法如果没有使用static修饰，默认锁对象为this</p></li><li><p>如果方法使用static修饰，则默认锁对象：当前类.class</p><ul><li>.class 是当前类对应的Class对象（Class是一个类），这个Class对象是在运行时保存类信息的对象，类加载时由JVM创建。</li></ul></li><li><p>实现的落地步骤</p><ul><li>先分析上锁的代码</li><li>尽量选择同步代码块</li><li>要求实现线程同步的多个线程锁对象要为同一个<ul><li>即多个线程对象同步操作，访问同步的方法时，互斥锁对象this要是同一个对象</li></ul></li></ul></li><li><p>例：此时用MyThread创建多个线程，即使sell方法加上了synchronized，也无法实现同步，这里通过继承Thread类创建Mythread对象,每个线程的锁为当前Mythread对象，锁的对象不同无法直接实现同步：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mythread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            sell();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &gt;<span class="number">0</span>)&#123;</span><br><span class="line">        num -- ;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 票还有&quot;</span> + num);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;sold out&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main:</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mythread</span>() ;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mythread</span>() ;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mythread</span>() ;</span><br><span class="line">thread1.start();</span><br><span class="line">thread2.start();</span><br><span class="line">thread3.start();</span><br></pre></td></tr></table></figure></li><li><p>改进：使不同Mythread对象的锁对象相同</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mythread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">oj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>() ;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            sell();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (oj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            num--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 票还有&quot;</span> + num);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;sold out&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>也可以将sell该为static synchronized方法，此时锁都是Mythread.class ,总之要使多个线程的操作共享资源的代码块的锁对象相同才能实现同步~</li></ul></li></ul><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><ul><li><p>简介：多个线程互相持有对方所需要的资源时，两个线程在运行时都在等待对方的锁释放，这样造成了程序的停滞，这种现象叫死锁。因此，在使用互斥锁时需要特别注意避免死锁的发生。</p></li><li><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HHHH</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">DeadLockThread</span>(<span class="number">1</span>)).start();</span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">DeadLockThread</span>(<span class="number">0</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">DeadLockThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> flag ;</span><br><span class="line">    DeadLockThread(<span class="type">int</span> flag)&#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = flag ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程1执行&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (lock1)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1要获得lock2才能继续执行&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);<span class="comment">//此线程获得lock1后，等待线程2获得lock2</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// System.out.println(&quot;线程1，wait并释放锁lock1&quot;);</span></span><br><span class="line">                <span class="comment">// try &#123;</span></span><br><span class="line">                        <span class="comment">//使持有lock1锁的线程释放锁</span></span><br><span class="line">                <span class="comment">//     lock1.wait(3000);</span></span><br><span class="line">                <span class="comment">// &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line">                <span class="comment">//     throw new RuntimeException(e);</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                <span class="keyword">synchronized</span> ((lock2))&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程1获得到了lock2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程2执行&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (lock2)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2要获得lock1才能继续执行&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> ((lock1))&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程2获得到了lock1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>锁的释放</p><ul><li>当前线程的同步方法，同步代码块执行结束</li><li>当前线程在同步代码块，同步方法中遇到break，return</li><li>当前线程在同步代码块，同步方法中出现了未处理的Error或Exception，导致异常结束</li><li>当前线程在同步代码块同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁<ul><li>可以在上述代码中调用wait方法，释放锁，解除死锁</li><li>上述死锁代码中加入被 &#x2F;&#x2F; 的部分，发现过三秒之后线程成功运行并结束</li><li>注意不要直接调用 Thread.currentThread().wait(),<a href="https://blog.csdn.net/fangaiming1/article/details/107532472">简单解析</a>，<a href="https://cloud.tencent.com/developer/article/1636718">相关</a></li></ul></li></ul></li><li><p>注意，程序调用Thread.sleep(),Thread.yield()方法暂停当前线程的执行，不会释放锁</p></li></ul><h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><ul><li><p>文件就是保存数据的东西，如txt文件，视频，音频文件等</p></li><li><p>文件流 ： 文件在程序中是以流的形式来操作的：<br><img src="/images/java_base4/04.png" alt="img"></p><ul><li>流：数据在数据源(文件)和程序(内存)之间经历的路程</li><li>输入流：数据从数据源到程序的路径</li><li>输出流：数据从程序到数据源的路径</li></ul></li><li><p>File 类： public class File extends Object<br> implements Serializable, Comparable&lt; File &gt;</p><ul><li>File类继承Object类并实现了Serializable 和 Comparable接口</li></ul></li><li><p>常用的文件操作;</p><ul><li><p>创建文件对象相关构造器和方法：</p><ul><li><p><img src="/images/java_base4/05.png" alt="img"></p></li><li><p>注意：<strong>此处文件路径格式，目录之间\\不要留有空格</strong>，</p><ul><li>例如”d:\\hello.txt”,而若是使用”d:_\\hello.txt”,则会出现FileNotFoundException(这里用下划线表示空格位置)</li><li>而若是用”d:\_hello.txt”则会创建一个新的名为”_hello.txt”的文件</li></ul></li><li><p>例：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">createFile1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据路径，在D盘下新建一个new.txt文件</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;d:\\ new.txt&quot;</span> ;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">File</span>(filePath).createNewFile();</span><br><span class="line">        <span class="comment">//只有执行createNewFile方法，文件才会真正的加入到电脑磁盘中，否则只是在程序中创建了一个File对象</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createFile2</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">parentFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\&quot;</span>);<span class="comment">//根据父目录文件和子文件路径创建</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;new2.txt&quot;</span> ;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">File</span>(parentFile , fileName).createNewFile();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createFile2</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;<span class="comment">//根据父目录 + 子文件路径创建</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">parentPath</span> <span class="operator">=</span> <span class="string">&quot;d:\\&quot;</span> ;<span class="comment">//第一个 \ 表示转义字符</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;new2.txt&quot;</span> ;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">File</span>(parentPath , fileName).createNewFile();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>获取文件的信息：</p><ul><li>getName():返回由此抽象路径名表示的文件或目录的名称</li><li>getAbsolutePath():返回此抽象路径名的绝对路径名字符串。</li><li>getPath():将此抽象路径名转换为路径名字符串</li><li>getParent():返回此抽象路径名的父 null的路径名字符串，如果此路径名未命名为父目录，则返回null。 </li><li>length():返回由此抽象路径名表示的文件的长度。</li><li>exits(): 测试此抽象路径名表示的文件或目录是否存在。</li><li>isFile():测试此抽象路径名表示的文件是否为普通文件。 </li><li>isDirctory():测试此抽象路径名表示的文件是否为目录.</li></ul></li><li><p>目录的操作和文件删除</p><ul><li>mkdir():创建一级目录</li><li>mkdirs():创建多级目录</li><li>delete():删除空目录或文件<blockquote><p>需要注意的是，在java编程中，目录也被当做一种文件来处理</p></blockquote></li></ul></li></ul></li></ul><h2 id="IO流原理及流的分类"><a href="#IO流原理及流的分类" class="headerlink" title="IO流原理及流的分类"></a>IO流原理及流的分类</h2><ul><li><p>java IO流原理：</p><ul><li>I&#x2F;O是指Input&#x2F;Output，I&#x2F;O技术用于处理数据传输，如读写文件，网络通讯等</li><li>java中对于数据的输入&#x2F;输出操作以“流(stream)” 的方式进行数据传输</li><li>java.io包下提供了各种”流”类和接口，用以获取不同种类的数据并通过方法输入或输出数据</li></ul></li><li><p>流的分类：</p><ul><li><p>按操作数据单位不同分为：字节流（8bit），字符流（按字符）</p><ul><li>对于<strong>文本文件</strong>（.txt，.java，.c，.cpp），<strong>使用字符流处理</strong></li><li>对于<strong>非文本文件</strong>（.jpg，.mp3，.mp4，.avi，.doc，.ppt，…），<strong>使用字节流处理</strong></li></ul></li><li><p>按数据流的流向不同分为：输入流，输出流</p><ul><li>input（输入）：读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中。</li><li>output（输出）：将程序（内存）数据输出到磁盘、光盘等存储设备中。<blockquote><p>注意：<strong>这里的输入输出的对象是指当前java程序</strong>，input是指从文件或其他方式获取信息输入到java程序中，output是指当前java程序向文件或其他输出信息</p></blockquote></li></ul></li><li><p>按流的角色不同分为：节点流，包装流&#x2F;处理流</p><ul><li><p>节点流：直接从数据源或目的地读写数据。    </p></li><li><p>处理流：不直接连接到数据源，而是“连接”在已存在的流（节点流或处理流）之上，通过对数据的处理为程序提供更为强大的读写功能。</p></li></ul></li><li><p>流的分类图示：<br>  <img src="/images/java_base4/08.png" alt="img"></p></li><li><table><thead><tr><th>抽象基类</th><th>字节流</th><th>字符流</th></tr></thead><tbody><tr><td>输入流</td><td>InputStream</td><td>Reader</td></tr><tr><td>输出流</td><td>OutputStream</td><td>Writer</td></tr></tbody></table><ul><li>java的IO流共涉及40多个类，实际上非常规则，都是从如上四个抽象基类派生的</li><li>由着四个类派生出来的子类名称都是以其父类名作为子类名的后缀</li></ul></li></ul></li><li><p>IO流体系图：<br><img src="/images/java_base4/09.png" alt="img"></p><blockquote><p>红色框为4个抽象基类，蓝色背景框为常用IO流<br>FilterInputStream 是指过滤输入流，是BufferedInputStream的直接父类</p></blockquote></li></ul><h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><ul><li>常用于处理非文本文件</li></ul><h3 id="InputStream：字节输入流"><a href="#InputStream：字节输入流" class="headerlink" title="InputStream：字节输入流"></a>InputStream：字节输入流</h3><ul><li><p>InputStream 抽象类是所有类字节输入流的超类</p></li><li><p>InputStream常用子类：</p><ul><li>FileInputStream：文件输入流</li><li>BufferedInputStream:缓冲字节输入流</li><li>ObjectInputStream:对象字节输入流</li></ul></li><li><p>常用方法：</p><ul><li><p>int read()：从输入流中读取数据的下一个字节，返回0到255范围内的int字节值。如果因为已经到达流末尾而没有可用的字节，则返回值-1。</p></li><li><p>int read(byte[] b)，从此输入流中将最多b.length个字节的数据读入一个byte数组中。如果因为已经到达流末尾而没有可用的字节，则返回值-1，否则以整数形式返回实际读取的字节数。</p></li><li><p>int read(byte[] b,int off,int len)，将输入流中最多len个数据字节读入byte数组。尝试读取len个字节，但读取的字节也可能小于该值。以整数形式返回实际读取的字节数。如果因为流位于文件末尾而没有可用的字节，则返回值-1。</p></li><li><p>void close() ，关闭此输入流并释放与该流关联的所有系统资源。</p></li></ul></li></ul><h4 id="FileInputStream-文件输入流"><a href="#FileInputStream-文件输入流" class="headerlink" title="FileInputStream 文件输入流"></a>FileInputStream 文件输入流</h4><ul><li><p>介绍： </p><ul><li>public class FileInputStream extends InputStream       </li><li>A FileInputStream从文件系统中的文件获取输入字节。 什么文件可用取决于主机环境。          </li><li>FileInputStream用于读取诸如图像数据的原始字节流。 要阅读字符串，请考虑使用FileReader 。</li></ul></li><li><p>构造方法：<br>  <img src="/images/java_base4/11.png" alt="img"></p></li><li><p>方法摘要<br>  <img src="/images/java_base4/12.png" alt="img"></p><blockquote><p>使用read(byte[] b) 指定读入字节数组，效率要明显高于read()读入单个字节</p></blockquote></li><li><p>例：使用FileInputStream 读取hello.txt文件，并将文件内容显示到控制台</p><ul><li>读取汉字显示为乱码，(在UTF-8编码中，一个汉字占三个字节)</li><li>读取字节文件<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> read ;</span><br><span class="line"><span class="type">int</span> readLength ;</span><br><span class="line"><span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>] ;<span class="comment">//一次读取八个字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在这里定义对象并置为空是为了扩大作用域，否则在finally中访问不到fileInputStream对象</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(filePath)) ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方案一：循环，每次读出一个字节的数据，作为char输出,返回-1表示读取完毕</span></span><br><span class="line">    <span class="comment">//这里fileInputStream.read()中是有一个指针指向文件开头，每次调用read后会自动移到下一个字节位置，下次读取的指针也从这里开始</span></span><br><span class="line">    <span class="keyword">while</span>((read = fileInputStream.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.print((<span class="type">char</span>)read);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方案二：每次读出一个字节数组，返回值为每次实际读取到的字节数，返回-1表示读取完毕</span></span><br><span class="line">    <span class="comment">//每次调用read(bytes)后,文件指针会自动向后移动bytes</span></span><br><span class="line">    <span class="keyword">while</span>((readLength = fileInputStream.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里利用String的一个构造器，0值作为offset,值从字节数组第0的位置开始，读取readLength长个字节</span></span><br><span class="line">        System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(bytes , <span class="number">0</span> , readLength));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在finally中关闭文件流，释放资源</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">            fileInputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="OutputStream-字节输出流"><a href="#OutputStream-字节输出流" class="headerlink" title="OutputStream 字节输出流"></a>OutputStream 字节输出流</h3><ul><li><p>介绍：</p><ul><li><p>public abstract class OutputStream extends Object implements Closeable, Flushable</p></li><li><p>OutputStream 抽象类是所有类字节输出流的超类</p></li><li><p>这个抽象类是表示字节输出流的所有类的超类。 输出流接收输出字节并将其发送到某个接收器。 </p></li><li><p>需要定义OutputStream子类的应用OutputStream必须至少提供一个写入一个字节输出的方法。</p></li></ul></li><li><p>OutputStream常用子类：</p><ul><li>FileOutputStream：文件输出流</li><li>FilterOutputStream:过滤字节输出流</li></ul></li><li><p>常用方法：</p><ul><li><p>void write(int b)：将指定的字节写入此输出流。 write的常规协定是：向输出流写入一个字节。要写入的字节是参数b的八个低位。b的24个高位将被忽略。即写入0~255范围的</p></li><li><p>void write(byte[] b) ：将b.length个字节从指定的byte数组写入此输出流。write(b)的常规协定是：应该与调用wite(b, 0, b.length)的效果完全相同。</p></li><li><p>void write(byte[] b, int off, int len)：将指定byte数组中从偏移量off开始的len个字节写入此输出流。</p></li><li><p>void flush()：刷新此输出流并强制写出所有缓冲的输出字节，调用此方法指示应将这些字节立即写入它们预期的目标。</p></li><li><p>void close()：关闭此输岀流并释放与该流关联的所有系统资源</p></li></ul></li></ul><h4 id="FileOutputStream-文件输出流"><a href="#FileOutputStream-文件输出流" class="headerlink" title="FileOutputStream 文件输出流"></a>FileOutputStream 文件输出流</h4><ul><li><p>介绍：</p><ul><li><p>public class FileOutputStream extends OutputStream</p></li><li><p>文件输出流是用于将数据写入到输出流File或一个FileDescriptor 。 文件是否可用或可能被创建取决于底层平台。 特别是某些平台允许一次只能打开一个文件来写入一个FileOutputStream （或其他文件写入对象）。 在这种情况下，如果所涉及的文件已经打开，则此类中的构造函数将失败。 </p></li><li><p>FileOutputStream用于写入诸如图像数据的原始<strong>字节流</strong>。 对于写入字符流，请考虑使用FileWriter 。</p></li></ul></li><li><p>构造方法：<br>  <img src="/images/java_base4/13.png" alt="img"></p></li><li><p>方法摘要<br>  <img src="/images/java_base4/14.png" alt="img"></p></li><li><p>例：在hello.txt文件中写入”hello world!”，(注意：如果要写入的文件不保存则会创建该文件，前提是目录已存在)</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;hello world!&quot;</span> ;</span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fileOutputStream2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//创建FileOutputStream类对象需要对应文件路径最为参数</span></span><br><span class="line">    <span class="comment">//注意，使用这种创建方式时，第一次写入的内容会覆盖原来的内容</span></span><br><span class="line">    fileOutputStream = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filePath);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//写入一个字节，</span></span><br><span class="line">    fileOutputStream.write(<span class="string">&#x27;H&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入字节数组,利用String 的getBytes数组将字符串转化为字符数组</span></span><br><span class="line">    fileOutputStream.write(content.getBytes());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//或用另一个重载的write方法，从指定的字节数组写入 len个字节，从偏移 off开始输出到此输出流</span></span><br><span class="line">    fileOutputStream.write(content.getBytes(),<span class="number">0</span>,content.length());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若想要在文件后追加内容而不是覆盖时，调用FileOutputStream(File file, boolean append)</span></span><br><span class="line">    fileOutputStream2 = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filePath,<span class="literal">true</span>) ;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//此时会在文件后追加内容</span></span><br><span class="line">    fileOutputStream2.write(content.getBytes()) ;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//结束流，释放资源</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现文件拷贝操作："><a href="#实现文件拷贝操作：" class="headerlink" title="实现文件拷贝操作："></a>实现文件拷贝操作：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;D:\\kaori.jpg&quot;</span> ;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">destFilePath</span> <span class="operator">=</span> <span class="string">&quot;D:\\Program Files\\kaori.jpg&quot;</span> ;</span><br><span class="line"></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line"></span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> readLength ;</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] bytes =  <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>] ;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line"></span><br><span class="line">    fileOutputStream = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFilePath,<span class="literal">true</span>) ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((readLength = fileInputStream.read(bytes)) != -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将读入的字节数组写入目标文件中去</span></span><br><span class="line">        <span class="comment">//此处必须使用这种write方法，可能最后一次读入的字节不满足1024，为保证数据的完整性使用该write方法，根据每次实际读出的字节数写入文件</span></span><br><span class="line">        fileOutputStream.write(bytes,<span class="number">0</span>,readLength);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进行流的结束，资源释放</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(fileOutputStream!=<span class="literal">null</span>)</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">        <span class="keyword">if</span>(fileOutputStream != <span class="literal">null</span>)</span><br><span class="line">            fileOutputStream.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><ul><li><p>Reader 和 Writer 是字符操作流的抽象基类</p></li><li><p>字符流常用于处理文本文件</p></li><li><p>FileReader 和FileWriter 是字符流，即按照字符来操作IO</p></li></ul><h3 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h3><ul><li><p>public class FileReader extends InputStreamReader</p></li><li><p>FileReader是用于读取字符流。 要读取原始字节流，请考虑使用FileInputStream 。</p></li><li><p>FileReader 相关方法：</p><ul><li>new FileReader(File&#x2F;String)</li><li>read() : 从输入流中读取数据的下一个字符，返回该字符的int字节值。如果因为已经到达流末尾而没有可用的字节，则返回值-1。</li><li>read( char[] ):批量读入多个字符到数组，返回读取到的子读书，如果到文件末尾返回 -1</li><li>相关API：<ul><li>new String(char[] ) :将char[] 转换成String</li><li>new String(char[] , off , len ):将 char[]的指定部分转换成String</li></ul></li></ul></li><li><p>例：读取并在控制台输出指定文件内容（注意在输出中文时若是出现奇怪的字符一般是文件的编码方式有关）</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;D:\\hello.txt&quot;</span> ;</span><br><span class="line">        </span><br><span class="line"><span class="type">int</span> read ;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">8</span>] ;</span><br><span class="line"></span><br><span class="line">FileReader fileReader;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    fileReader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(filePath);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每次读取单个字符</span></span><br><span class="line">    <span class="keyword">while</span>((read = fileReader.read()) != -<span class="number">1</span>)</span><br><span class="line">    System.out.print((<span class="type">char</span>)read);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每次读取指定个字符到字符数组中</span></span><br><span class="line">    <span class="keyword">while</span>((read = fileReader.read(chars)) != -<span class="number">1</span>)</span><br><span class="line">        System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(chars));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h3><ul><li><p>public class FileWriter extends OutputStreamWriter</p></li><li><p>FileWriter是用于写入字符流。 要编写原始字节流，请考虑使用FileOutputStream 。</p></li><li><p>FileWriter 常用方法</p><ul><li><p>new FileWriter(File&#x2F;String):根据文件或指定路径来创建对象，覆盖模式，相当于流的指针在文件首段</p></li><li><p>new FileWriter(File&#x2F;String , true) :追加模式，相当于流的指针在文件的末端</p></li><li><p>write(int):写入单个字符</p></li><li><p>writer(char[] ) : 写入指定字符数组</p></li><li><p>write(char[] , off , len):写入字符数组的指定部分</p></li><li><p>write(String) ；写入整个字符串</p></li><li><p>write(String ,off,len) : 写入字符串的指定部分</p></li><li><p>相关API： String类的 toCharArray():将String转换成char[]</p></li></ul></li><li><p>注意：<strong>FileWriter 使用后，必须要关闭(close)或刷新(flush),否则内容写入不到指定文件</strong>,可追源码，620节</p></li><li><p>例：将一个字符串写入文件中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileWriter</span> <span class="variable">fileWriter</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line"></span><br><span class="line"><span class="type">FileWriter</span> <span class="variable">fileWriter2</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;完蛋，我被美女包围了！&quot;</span> ;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>[] chars = content.toCharArray();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> write ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//该种构造器构造对象在向文件中写入时为覆盖</span></span><br><span class="line">fileWriter = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(filePath) ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入一个字符数组的内容</span></span><br><span class="line">fileWriter.write(chars);</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时在文件中写入内容时为从文件末尾添加</span></span><br><span class="line">fileWriter2 = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(filePath , <span class="literal">true</span>) ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入一个字符串</span></span><br><span class="line">fileWriter2.write(content);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(fileWriter != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果不关闭该流对象，则不会将内容写入文件</span></span><br><span class="line">            fileWriter.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="FileReader和FileWriter拷贝文件"><a href="#FileReader和FileWriter拷贝文件" class="headerlink" title="FileReader和FileWriter拷贝文件"></a>FileReader和FileWriter拷贝文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line"></span><br><span class="line">   <span class="type">FileWriter</span> <span class="variable">fileWriter</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line"></span><br><span class="line">   <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>] ;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">       fileReader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(filePath) ;</span><br><span class="line"></span><br><span class="line">       fileWriter = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(destPath) ;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> <span class="variable">readLength</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span>((readLength = fileReader.read(chars)) != -<span class="number">1</span> ) &#123;</span><br><span class="line"></span><br><span class="line">           fileWriter.write(chars , <span class="number">0</span> , readLength);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">   &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (fileWriter != <span class="literal">null</span>)</span><br><span class="line">               fileWriter.close();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>(fileReader != <span class="literal">null</span>)</span><br><span class="line">               fileWriter.close();</span><br><span class="line"></span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h2><ul><li><p>节点流：节点流可以从一个特定的数据源<strong>读写数据</strong>，如FileReader，FileWriter。</p><ul><li><p><img src="/images/java_base4/06.png" alt="img"></p></li><li><p>如FileReader，从数据源(存放数据的地方)，从以字节流的形式读取数据</p></li></ul></li><li><p>处理流：不直接连接到数据源，而是“连接”在已存在的流（节点流或处理流）之上，为程序提供更为强大的读写功能，也更加灵活。 </p><ul><li><p><img src="/images/java_base4/07.png" alt="img"></p></li><li><p>如BufferedReader ,查看源码其类中有属性Reader类的对象，即可以封装一个节点流，_该节点流可以是任意的Reader子类对象_（向上造型，修饰者模式）</p></li><li><p>创建处理流对象要传入一个对应的节点流对象</p></li></ul></li><li><p>分类图：<br><img src="/images/java_base4/15.png" alt="img"></p></li><li><p>节点流和处理流的区别和联系</p><ul><li><p>节点流是底层流&#x2F;低级流，直接跟数据源相连</p></li><li><p>处理流包装节点流，既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入输出</p></li><li><p>处理流(也叫包装流)对节点流进行包装，使用了修饰器设计者模式，不会直接与数据源相连</p></li></ul></li><li><p>处理流功能主要体现在以下</p><ul><li><p>性能的提高：主要以增加缓冲的方式来提高输入输出的效率</p></li><li><p>操作的便捷，处理流可能提供了一系列便捷的方法来一次输入输出大批量的数据，使用更加灵活方便</p></li></ul></li></ul><h3 id="缓冲处理流"><a href="#缓冲处理流" class="headerlink" title="缓冲处理流"></a>缓冲处理流</h3><p>缓冲字符处理流 </p><ul><li><p>BufferedReader 和 BufferedWriter属于字符流，是按照<strong>字符</strong>来读取数据的</p></li><li><p>注意不要用他们来操作二进制文件(如视频，pdf文件等)，会发生文件损失</p></li><li><p>关闭处理流时，只需要关闭外层流即可 (处理流只是对节点流的包装，内部调用节点流，在关闭处理流时底层会自动关闭包装的内部的节点流,)</p><ul><li>源码处in.close()，这里的in 就是传入处理流中的节点流对象</li></ul></li><li><p>BufferedReader:（为简化代码以后直接将异常抛出）</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用Reader的子类对象，创建BufferedReader ,</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(filePath)) ;</span><br><span class="line"></span><br><span class="line">String line ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取，按行读取效率高</span></span><br><span class="line"><span class="comment">//readLine()函数返回读取的文件内容，当返回null时表示文件读取完毕</span></span><br><span class="line"><span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">    System.out.println(line);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//但readLine()读取一行内容，并不包括换行符,没读取一次输出换行符</span></span><br><span class="line">    System.out.println() ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里只需要关闭BufferedReader，底层会自动关闭内部节点流，</span></span><br><span class="line">bufferedReader.close();</span><br></pre></td></tr></table></figure><ul><li>BufferedWriter 的使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用Writer的子类对象，创建BufferedWriter ,此时为覆盖方式写入内容</span></span><br><span class="line"><span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(filePath) );</span><br><span class="line"></span><br><span class="line"><span class="comment">//当需要以追加方式来写入信息时，要将加入处理流的节点流设置为追加模式</span></span><br><span class="line"><span class="type">BufferedWriter</span> <span class="variable">bufferedWriter2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(filePath ,<span class="literal">true</span>) );</span><br><span class="line"></span><br><span class="line">bufferedWriter.write(<span class="string">&quot;hhhh&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入一个和系统相关的换行</span></span><br><span class="line">bufferedWriter.newLine();</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭处理流即可</span></span><br><span class="line">bufferedWriter.close();</span><br></pre></td></tr></table></figure><ul><li>实现文件复制</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(filePath)) ;</span><br><span class="line">        </span><br><span class="line"><span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(destPath) );</span><br><span class="line"></span><br><span class="line">String line ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    bufferedWriter.write(line);</span><br><span class="line">    <span class="comment">//readline不包括换行符，故此处没读取一行要向文件中写入一个和系统相关的换行</span></span><br><span class="line">    bufferedWriter.newLine();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(bufferedWriter != <span class="literal">null</span>)</span><br><span class="line">bufferedWriter.close();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bufferedReader != <span class="literal">null</span>)</span><br><span class="line">bufferedReader.close();</span><br></pre></td></tr></table></figure><p> 缓冲字节处理流 </p><ul><li><p>缓冲字节输入流 BufferedInputStream 继承自FilterInputStream ，获得父类的属性 ，InputStream in .作为内部节点流</p><ul><li>是字节流，在创建BufferedInputStream时会创建一个内部缓冲区数组</li></ul></li><li><p>缓冲字节输出流 BufferedOutputStream 继承自FilterOutputStream ，获得父类的属性 ，OutputStream out .作为内部节点流</p><ul><li>是字节流，实现缓冲的输出流，可以将多个字节写入底层输出流中，而不必对每次字节写入调用底层系统</li></ul></li><li><p>体现出处理流特点，修饰器模式</p></li><li><p>方法操作类似上述处理流</p></li></ul><h3 id="对象处理流"><a href="#对象处理流" class="headerlink" title="对象处理流"></a>对象处理流</h3><ul><li><p>需求引入</p><ul><li>将int num &#x3D; 100 这个int数据保存到文件中，确保这个100 一定是int类型的数字，不是String”100”,不是1，0，0数字组合，能够从文件中直接恢复 int 100</li><li>将 Dog dog &#x3D; new Dog(“大黄”) ;这个dog对象保存到文件中，并且能从文件中恢复该对象。</li></ul></li><li><p>上诉要求，就是能够<strong>将基本数据类型或者对象进行序列化和反序列化操作</strong>。</p></li></ul><blockquote><p>序列化和反序列化</p><ul><li><strong>序列化</strong>就是在保存数据时，<strong>保存数据的值和数据类型</strong></li><li><strong>反序列化</strong>就是在恢复数据时，<strong>恢复数据的值和数据类型</strong></li><li>需要让某个对象支持序列化机制，则必须让其类时可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一：<ul><li>Serializable (这是一个标记接口，没有任何方法)</li><li>Externalizable (该接口有方法需要实现，一般不实现该接口)</li></ul></li></ul></blockquote><ul><li><p>ObjectInputStream 和 ObjectOutputStream</p><ul><li><p>是一种处理流</p></li><li><p>功能：提供了对基本类型或对象类型的序列化和反序列化的方法</p></li><li><p>ObjectOutputStream 提供 序列化功能</p><ul><li>构造方法需要传入一个OutputStream类的对象</li></ul></li><li><p>ObjectInputStream 提供 反序列化功能</p><ul><li>构造方法需要传入一个InputStream类的对象</li></ul></li></ul></li><li><p>实现数据的序列化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;<span class="comment">//内容及构造函数省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main中：</span></span><br><span class="line"><span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;D:\\data.dat&quot;</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//序列化数据到d:\data.dat</span></span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filePath));</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为此处会会发生自动装箱，Integer实现了Serializable接口，保存数据的同时会将数据类型也保存</span></span><br><span class="line">objectOutputStream.writeInt(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//boolean -&gt; Boolean ,类似的还有char,double</span></span><br><span class="line">objectOutputStream.writeBoolean(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串序列化需要writeUTF()方法</span></span><br><span class="line">objectOutputStream.writeUTF(<span class="string">&quot;Mike&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果要序列化某个类的对象，则这个类必须实现Serializable接口</span></span><br><span class="line">objectOutputStream.writeObject(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;jack&quot;</span>,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭流，释放资源</span></span><br><span class="line">objectOutputStream.close();</span><br></pre></td></tr></table></figure></li><li><p>反序列化：使用ObejctInputStream 读取data.dat并反序列化恢复数据</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath)) ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取(反序列化)数据的顺序要和保存(序列化)数据的顺序一致</span></span><br><span class="line">System.out.println(objectInputStream.readInt());</span><br><span class="line">System.out.println(objectInputStream.readBoolean());</span><br><span class="line">System.out.println(objectInputStream.readUTF());</span><br><span class="line"></span><br><span class="line"><span class="comment">//此处要抛出一个ClassNotFoundException</span></span><br><span class="line">System.out.println(objectInputStream.readObject().getClass());</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意当更改类内信息时，数据要重新序列化，原来的数据反序列化则会出现异常</span></span><br><span class="line"><span class="comment">//比如在将Dog类中加入一个方法，而原来在.dat中的储存的dog类对象信息中不包含这个新的方法，故要重新序列化</span></span><br><span class="line"><span class="comment">//即更新类信息时需要重新序列化类对象数据</span></span><br><span class="line"></span><br><span class="line">objectInputStream.close() ;</span><br></pre></td></tr></table></figure><ul><li><p>630讲的没太听懂啥意思，讲的挺混乱的感觉，，，</p></li><li><p><strong>注意事项</strong>：</p><ul><li><p>读写顺序要一致</p></li><li><p>要求实现序列化或反序列化对象，类要实现Seriializable</p></li><li><p>序列化的类中建议添加SerialVersionUID属性(序列化版本化)，为了提高版本的兼容性</p><ul><li>在序列化的类中加入private static final long serialVersionUID &#x3D; 1L ;</li><li>当加入该属性后，在进行类信息的修改时，虚拟机会认为这与之前是同一个类，只是版本的修改，并不会认为这是一个与之前完全不同的类</li><li>此时在更新类信息时，不用重新序列化对象也能正确识别</li><li>虚拟机在底层比对文件中的对象的类信息，与当前可访问的类文件进行比对的时候就是比较他们的serialVersionUID</li></ul></li><li><p>序列化对象时，默认将里面的所有属性都进行序列化，但除了static或transient修饰的成员</p></li><li><p>序列化对象时，要求里面属性的类型也需要实现序列化接口</p></li><li><p>序列化具备可继承性，即如果某类实现了序列化，则它的所有子类也默认实现序列化</p></li></ul></li></ul><h3 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a>标准输入输出流</h3><table><thead><tr><th></th><th>类型</th><th>默认设备</th></tr></thead><tbody><tr><td>System.in 标准输入流</td><td>InputStream</td><td>键盘</td></tr><tr><td>System.out 标准输出流</td><td>PrintStream</td><td>显示器</td></tr></tbody></table><ul><li><p>System.in</p><ul><li>public final static InputStream in &#x3D; null;</li><li>可以通过输出System.in.getClass()获取 System.in的运行类型，是BufferedInputStream</li><li>在初始化扫描器scanner时，传入System.in，故scanner会到键盘的标准输入中获得数据</li></ul></li><li><p>System.out</p><ul><li>public final static InputStream in &#x3D; null;</li><li>编译类型 PrintStream，运行类型 PrintStream</li><li>System.out.println(“”)就是将其中的字符串输出到标准输出位置，即显示器</li></ul></li></ul><h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h3><ul><li><p>不同文件有不同的编码方式，而读取文件是按系统默认的编码方式，有时读取文字文件时可能会读出乱码，这时需要指定读取文件的编码方式</p></li><li><p>转换流可以将字节流转换成字符流，而我们可以指定读取字节流的编码方式</p></li><li><p>当处理纯文本数据时，如果使用字符流效率更高，并且可以有效解决中文乱码问题，建议将字节流转换成字符流</p></li><li><p>InputStreamReader 和 OuputStreamWriter</p></li><li><p>InputStreamReader ：</p><ul><li><p>public class InputStreamReader extends Reader</p></li><li><p>是Reader 的子类，可以将InputStream(字节流)，包装成Reader(字符流)</p></li><li><p>构造方法 ： InputStreamReader(InputStream in, Charset cs)<br>   传入一个InputStream类的对象 ，创建一个使用指定处理编码的InputStreamReader对象(如 utf-8,gbk,gb2312等)。</p></li><li><p>例：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//此处若直接用字节流读取中文会出现乱码</span></span><br><span class="line"><span class="comment">//        int read ;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        while((read = fileInputStream.read()) != -1 )&#123;</span></span><br><span class="line"><span class="comment">//            System.out.print((char)read);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将一个InputSream类转换成字符流Reader</span></span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">inputStreamReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fileInputStream,<span class="string">&quot;gbk&quot;</span>) ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了最大的读取效率，考虑在BufferedReader中包装一个InputStreamReader</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(inputStreamReader) ;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line"><span class="keyword">while</span>((string = bufferedReader.readLine()) != <span class="literal">null</span> )</span><br><span class="line">    System.out.println(string);</span><br><span class="line"></span><br><span class="line"><span class="comment">//只需要关闭最外层的流，其余流会依次自动关闭</span></span><br><span class="line">bufferedReader.close();</span><br></pre></td></tr></table></figure></li></ul></li><li><p>OutputStreamWriter ： Writer的子类，实现将OutputStream(字节流)包装成Writer(字符流)</p><ul><li><p>public class OutputStreamWriter extends Writer</p></li><li><p>是Writer 的子类，可以将OutputStream(字节流)，包装成Writer(字符流)</p></li><li><p>构造方法 ： OutputStreamWriter(OutputStream out, Charset cs)<br>   传入一个OutputStream类的对象 ，创建一个使用指定处理编码的OutputStreamWriter对象,若不指定则为默认字符编码格式。</p></li><li><p>例：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定写入文件的编码形式</span></span><br><span class="line"><span class="type">OutputStreamWriter</span> <span class="variable">outputStreamWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filePath),<span class="string">&quot;gbk&quot;</span>) ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为提升效率，在BufferedWriter中包装一个OutputStreamWriter，以避免频繁的转换器调用</span></span><br><span class="line"><span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(outputStreamWriter) ;</span><br><span class="line"></span><br><span class="line">bufferedWriter.write(<span class="string">&quot;hhh,原神启动！&quot;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">//若没有关闭缓冲写入流，缓冲区的字符则不会被写入到文件中去</span></span><br><span class="line">bufferedWriter.close();</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><ul><li><p>PrintStream 和 PrintWriter </p></li><li><p>打印流只有输出流，没有输入流，因为打印流作用是将信息打印到指定位置(显示器，文件等)</p></li><li><p>PrintStream </p><ul><li><p>public class PrintStream extends FilterOutputStream implements Appendable, Closeable</p></li><li><p>System.out 就是一个PrintStream类对象</p></li><li><p>例：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//System.out默认输出数据的位置是标准输出，即显示器</span></span><br><span class="line">    <span class="type">PrintStream</span> <span class="variable">out</span> <span class="operator">=</span> System.out ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以设置/修改打印流输出的位置，例，输出到文件中</span></span><br><span class="line">    <span class="comment">//System.setOut()是System类中的一个方法，用于修改类中属性 out</span></span><br><span class="line">    System.setOut(<span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;d:\\hello.txt&quot;</span>));</span><br><span class="line">    out.print(<span class="string">&quot;hhh&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//print底层代码如下，实际是在调用PrintStream中私有的write(String)</span></span><br><span class="line"><span class="comment">//        public void print(String s) &#123;</span></span><br><span class="line"><span class="comment">//            if (s == null) &#123;</span></span><br><span class="line"><span class="comment">//                s = &quot;null&quot;;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            write(s);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//故print非空字符串效果等同于：out.write(&quot;hhh&quot;.getBytes());</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>PrintWriter </p><ul><li><p>public class PrintWriter extends Writer</p></li><li><p>构造方法多种，可以传入一个Writer对象，OutputStream对象，也可以指定编码方法</p></li><li><p>例：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此时默认输出到显示器</span></span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">printWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(System.out) ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时输出到对应文件中,重定向</span></span><br><span class="line">printWriter = <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;d:\\hello.txt&quot;</span>)) ;</span><br><span class="line">printWriter.println(<span class="string">&quot;原神启动！&quot;</span>);</span><br><span class="line">printWriter.close();</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Properties类"><a href="#Properties类" class="headerlink" title="Properties类"></a>Properties类</h2><p>常用 .properties文件储存文件配置信息</p><p>而使用java中的 Propertites类可以方便用于配置文件内容的读取更改（引入：638节）</p><ul><li><p>基本介绍</p><ul><li><p>public class Properties extends Hashtable&lt; Object,Object &gt;</p></li><li><p>专门用于读写配置文件的集合类      </p></li><li><p>配置文件格式：<br>  键&#x3D;值<br>  键&#x3D;值</p></li><li><p>注意 ： 键值对不需要有空格，只不需要用引号引起来，默认类型是String</p></li><li><p>例：mysql.properties文件内容：</p>  <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ip</span>=<span class="string">192.168.00.100</span></span><br><span class="line"><span class="attr">user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">pwd</span>=<span class="string">12345</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Properties的常见方法</p><ul><li><p>load: 加载配置文件的键值对到Properties对象</p></li><li><p>list: 将数据显示到指定设备</p></li><li><p>getProperty(key)：根据键获取值</p></li><li><p>setProperty(key,value): 设置键值对到Properties对象</p></li><li><p>store: 将Property 中的键值对储存到配置文件，在idea中，保存信息到配置文件，如果含有中文，会存储为Unicode码</p></li></ul></li><li><p>Properties的使用</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Propertites对象</span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载指定文件,当前工程项目src下test包中的propertites文件</span></span><br><span class="line">properties.load(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;src\\test\\mysql.properties&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出键值对,需要传入一个PrintStream或PrintWriter类对象</span></span><br><span class="line"><span class="comment">//这里传入System.out，表示在控制台输出文件内容</span></span><br><span class="line">properties.list(System.out);</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据key 获取对应的值</span></span><br><span class="line">System.out.println(properties.getProperty(<span class="string">&quot;user&quot;</span>));</span><br></pre></td></tr></table></figure><ul><li>使用Properties类创建配置文件，修改配置文件内容：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>() ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建键值对，输入两个String，因为继承自HashTable，不允许存入两个相同的key</span></span><br><span class="line"><span class="comment">//如果该key不存在，则在文件中创建该键值对，如果不存在则修改键值对的值(与HashTable的方法相对应)</span></span><br><span class="line">properties.setProperty(<span class="string">&quot;usr&quot;</span> , <span class="string">&quot;Mike&quot;</span>) ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将键值对储存到properties文件中,这里第二个参数是该配置文件的注释</span></span><br><span class="line">properties.store(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;src\\mysql2.properties&quot;</span>),<span class="literal">null</span>);</span><br></pre></td></tr></table></figure></li></ul><h1 id="java-图形界面"><a href="#java-图形界面" class="headerlink" title="java 图形界面"></a>java 图形界面</h1><h2 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span>  &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="type">PaintTest1</span> <span class="variable">paintTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PaintTest1</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承JPanel类，面板类，可以在面板上画图形</span></span><br><span class="line"><span class="comment">//JPanel是Component 类的子类，Component提供了两个和绘图最相关的方法：</span></span><br><span class="line"><span class="comment">//paint(Graphics g) 绘制组件的外观</span></span><br><span class="line"><span class="comment">//repaint() 刷新组件的外观</span></span><br><span class="line"><span class="comment">//当组件在第一次屏幕显示程序会自动调用paint()方法来绘制组件，以下情况paint方法会被调用：</span></span><br><span class="line"><span class="comment">//1 窗口的最小化，再最大化 2 窗口的大小发生变化(底层有监听机制，可以发现窗口的大小变化) 3 repaint 函数被调用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPanel</span> <span class="keyword">extends</span> <span class="title class_">JPanel</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">(Graphics g)</span> &#123;<span class="comment">//paint()绘图方法</span></span><br><span class="line">        <span class="comment">//MyPanel对象就是一个画板</span></span><br><span class="line">        <span class="comment">//Graphics g 把 g理解成一支画笔</span></span><br><span class="line">        <span class="comment">//Graphics 提供了很多绘图方法</span></span><br><span class="line">        <span class="built_in">super</span>.paint(g);<span class="comment">//调用父类的方法完成初始化，不能删去</span></span><br><span class="line"></span><br><span class="line">        g.drawOval(<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>);<span class="comment">//绘图板的原点在左上方，所绘制图形的起始点也在左上方</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;paint被调用&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//画线段，起点坐标到终点坐标</span></span><br><span class="line">        g.drawLine(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//画矩形边框</span></span><br><span class="line">        g.drawRect(<span class="number">10</span>,<span class="number">10</span>,<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置画笔颜色</span></span><br><span class="line">        g.setColor(Color.cyan);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//填充矩形</span></span><br><span class="line">        g.fillRect(<span class="number">10</span>,<span class="number">100</span> , <span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//画图片</span></span><br><span class="line">        <span class="comment">// 1.获取图片资源</span></span><br><span class="line">        <span class="comment">//  “/head_sculpture.jpg”表示在当前项目的根目录去获取这个jpg图片</span></span><br><span class="line">        <span class="type">Image</span> <span class="variable">image</span> <span class="operator">=</span> Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class="string">&quot;/head_sculpture.jpg&quot;</span>)) ;</span><br><span class="line">        <span class="comment">// 2.画图片</span></span><br><span class="line">        g.drawImage(image ,<span class="number">10</span> , <span class="number">10</span> , <span class="number">38</span>, <span class="number">21</span>,<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写字： （属性：字体，是否是初体，大小）</span></span><br><span class="line">        g.setFont(<span class="keyword">new</span> <span class="title class_">Font</span>(<span class="string">&quot;行书&quot;</span> ,Font.BOLD ,<span class="number">50</span>));</span><br><span class="line">        g.drawString(<span class="string">&quot;你好啊！&quot;</span> ,<span class="number">100</span>,<span class="number">100</span>);<span class="comment">//这时x,y为字符串左下角坐标</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Frame框架，JFrame对应窗口，也就是一个画框</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PaintTest</span> <span class="keyword">extends</span> <span class="title class_">JFrame</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">MyPanel1</span> <span class="variable">myPanel</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PaintTest</span><span class="params">()</span>  &#123;</span><br><span class="line">        <span class="comment">//初始化面板</span></span><br><span class="line">        myPanel = <span class="keyword">new</span> <span class="title class_">MyPanel1</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把面板加入窗口</span></span><br><span class="line">        <span class="built_in">this</span>.add(myPanel) ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置窗口的大小</span></span><br><span class="line">        <span class="built_in">this</span>.setSize(<span class="number">600</span>,<span class="number">700</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置为点击关闭窗口就退出程序</span></span><br><span class="line">        <span class="built_in">this</span>.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置为可以显示</span></span><br><span class="line">        <span class="built_in">this</span>.setVisible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更改窗口大小</span></span><br><span class="line">        <span class="built_in">this</span>.setSize(<span class="number">500</span>,<span class="number">400</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件处理机制"><a href="#事件处理机制" class="headerlink" title="事件处理机制"></a>事件处理机制</h2><ul><li><p>例：小球移动案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BallMove</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyFrame</span> <span class="variable">myFrame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyFrame</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MyPanel 实现KeyListener,KeyListener 是监听器，可以监听键盘行为</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPanel</span> <span class="keyword">extends</span> <span class="title class_">JPanel</span> <span class="keyword">implements</span> <span class="title class_">KeyListener</span>  &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span>  <span class="operator">=</span> <span class="number">10</span> ;</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">10</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">(Graphics g)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.paint(g);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//填充一个圆，默认是黑色</span></span><br><span class="line">        g.fillOval(x,y,<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//有字符输出时，该方法就会触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keyTyped</span><span class="params">(KeyEvent e)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当某个键被按下，该方法就会触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keyPressed</span><span class="params">(KeyEvent e)</span> &#123;</span><br><span class="line"><span class="comment">//        System.out.println((char)e.getKeyCode() + &quot;被按下了&quot;);</span></span><br><span class="line">        <span class="comment">//根据用户按下的键不同来处理小球的上下移动</span></span><br><span class="line">        <span class="comment">//java中会给每一个键分配一个值，其实就是对应的ASCII码的值，即如下的KeyEvent.Vk_DOWN</span></span><br><span class="line">        <span class="keyword">if</span>(e.getKeyCode() == KeyEvent.VK_DOWN)&#123;</span><br><span class="line">            y++ ;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(e.getKeyCode() == KeyEvent.VK_LEFT)&#123;</span><br><span class="line">            x-- ;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(e.getKeyCode() == KeyEvent.VK_RIGHT)&#123;</span><br><span class="line">            x++ ;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(e.getKeyCode() == KeyEvent.VK_UP)&#123;</span><br><span class="line">            y-- ;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//让面板重绘，刷新面板,才会显示小球移动的效果</span></span><br><span class="line">        <span class="built_in">this</span>.repaint();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当某个键被释放，该方法会触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keyReleased</span><span class="params">(KeyEvent e)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java事件处理机制</p></li><li><p>java事件处理是采取 **”委派事件模型”**。当事件发生时，产生事件的对象，会把此”信息”传递给”事件的监听者”处理,这里所说的信息实际上就是 java.awt.event事件类库里某个类所创建的对象，把它称为”事件的对象”。</p><ul><li>上述示例中：当我们产生键盘键的按下时，这个动作被 KeyListener 监听到，并产生KeyEvent类对象</li><li>事件源发生事件时会传递一个 事件对象 给监听者，事件监听者会根据发生的事件做出相应的事件处理方法<br>  <img src="/images/java_base4/10.png" alt="img"></li></ul></li><li><p>相关概念</p><ul><li>事件源：事件源是一个产生事件的对象，比如按钮，窗口等。</li><li>事件 ：事件就是承载事件源状态改变时的对象，比如 键盘事件，鼠标事件，窗口事件等，就会生成一个事件对象，该对象保存着当前事件的很多信息，使用get方法获取信息，比如KeyEvent对象有含被按下键的Code值。。java.awt.event包和javax.swing.event包中定义了各种事件类型</li></ul></li><li><p>事件监听器接口：</p><ul><li>当事件源产生一个事件，可以传送给事件监听者处理</li><li>事件监听者实际上就是一个类，该类实现了某个事件监听器的接口比如案例中的MyPanel类 实现了KeyListener接口，它就可以作为一个事件监听者对接受的事件进行处理</li><li>事件监听器接口有多重，不同的事件监听器接口可以监听不同的事件，一个类可以实现多个监听接口</li><li>这些接口在java.awt.event包和javax.swing.event中定义，可查看jdk文档</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;泛型&quot;&gt;&lt;a href=&quot;#泛型&quot; class=&quot;headerlink&quot; title=&quot;泛型&quot;&gt;&lt;/a&gt;泛型&lt;/h1&gt;&lt;h2 id=&quot;泛型引入：&quot;&gt;&lt;a href=&quot;#泛型引入：&quot; class=&quot;headerlink&quot; title=&quot;泛型</summary>
      
    
    
    
    
    <category term="java" scheme="https://pengzhanyi.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="https://pengzhanyi.github.io/2023/09/26/data-structure/"/>
    <id>https://pengzhanyi.github.io/2023/09/26/data-structure/</id>
    <published>2023-09-26T14:39:14.000Z</published>
    <updated>2023-09-26T15:04:51.826Z</updated>
    
    
    
    
    
    <category term="408基础" scheme="https://pengzhanyi.github.io/tags/408%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>java基础- 基于面向对象的应用_1</title>
    <link href="https://pengzhanyi.github.io/2023/09/24/java-base3/"/>
    <id>https://pengzhanyi.github.io/2023/09/24/java-base3/</id>
    <published>2023-09-24T08:50:40.000Z</published>
    <updated>2023-11-18T14:50:20.149Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="枚举和注解"><a href="#枚举和注解" class="headerlink" title="枚举和注解"></a>枚举和注解</h1><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><ul><li><p>基本介绍：</p><ul><li>枚举对应英文enumeration,简写enum</li><li>枚举是一组常量的集合</li><li>可以理解为枚举属于一种特殊的类，<u>里面只包含一组有限的特定的对象</u></li></ul></li><li><p>枚举实现方式</p><ul><li>1 自定义实现枚举</li><li>2 使用enum关键字实现枚举</li></ul></li></ul><h3 id="自定义实现枚举"><a href="#自定义实现枚举" class="headerlink" title="自定义实现枚举"></a>自定义实现枚举</h3><ul><li>自定义枚举类特点<ul><li>构造器私有化</li><li>对枚举对象&#x2F;属性使用final + static 共同修饰，实现底层优化</li><li>不需要提供类属性的set方法，因为枚举对象值通常为只读,可以提供get方法</li><li>对外暴露枚举对象，<u>设置对象为<strong>public static final</strong></u></li><li>枚举对象名通常使用全部大写，常量的命名规范</li><li>枚举对象根据需要，也可以有多个属性</li></ul></li><li>例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">private</span> String desc ;<span class="comment">//描述</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name , String desc)</span>&#123;</span><br><span class="line">        <span class="comment">//构造器设置为私有化防止外部直接实例化</span></span><br><span class="line">        <span class="built_in">this</span>.name = name ;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//去掉set方法防止属性被修改</span></span><br><span class="line">    <span class="comment">//在类内部直接创建固定的对象，public static final</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span> , <span class="string">&quot;温暖&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span> , <span class="string">&quot;炎热&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span> , <span class="string">&quot;凉爽&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span> , <span class="string">&quot;寒冷&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h3 id="enum关键字实现枚举"><a href="#enum关键字实现枚举" class="headerlink" title="enum关键字实现枚举"></a>enum关键字实现枚举</h3><ul><li><p>实现具体过程</p><ul><li>使用关键字enum来代替class</li><li>public static final 对象名 &#x3D; new 枚举类名（参数列表） 定义枚举变量的方式变为直接用  <strong>变量名（参数列表）</strong></li><li>如果有多个常量（对象），使用 ， 间隔即可</li><li>如果<strong>使用enum来实现枚举，要求必须将定义常量对象写在类的最前面</strong></li><li>例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    Season(<span class="string">&quot;春天&quot;</span> , <span class="string">&quot;温暖&quot;</span>) ,SUMMER (<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;炎热&quot;</span>) ,</span><br><span class="line">    AUTUMN (<span class="string">&quot;秋天&quot;</span> , <span class="string">&quot;凉爽&quot;</span>),WINTER  (<span class="string">&quot;冬天&quot;</span> , <span class="string">&quot;寒冷&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">private</span> String desc ;<span class="comment">//描述</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name , String desc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name ;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name + <span class="built_in">this</span>.desc ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>enum关键字实现枚举注意事项     </p><ul><li>简化的定义枚举类变量的方式： 变量名（参数列表） 形式，这里必须知道它调用的是哪个构造器</li><li>当使用无参构造器创建枚举对象，则实参列表和小括号都可以省略</li><li>当有多个枚举对象时，使用 , 间隔，最后一个由分号结尾</li><li>枚举类对象必须放在枚举类的行首</li></ul></li><li><p>补充</p><ul><li><p>输出enum的对象时会调用enum的toString方法，返回该枚举对象名，具体内容可查看Enum类源码 </p></li><li><p>当使用enum关键字定义类时，这个类会默认继承Enum类，所以子类会获得Enum中的各种方法</p><ul><li><p>因为已经默认Enum类，因为java的单继承机制，故枚举类不能再继承别的类，但可以实现接口</p></li><li><p>可以用javap反编译.class文件以显示对应源码中隐藏的细节，通过这种方法来证明，枚举类继承Enum类,而且是一个final类</p><ul><li><img src="/images/java_base3_01.png" alt="img"></li></ul></li><li><p>或在idea中利用Ctrl + Alt + U来查看类的继承关系</p><ul><li><img src="/images/java_base3_02.png" alt="img"></li></ul></li></ul></li><li><p>enum类常用方法</p><ul><li>toString：Enum类已经重写过了，返回当前对象名，子类可以根据需要重写方法</li><li>name ： 返回当前对象名（常量名），是final的方法，子类中不能重写</li><li>ordinal :返回当前对象的位置号，默认从0开始</li><li>values:返回当前枚举类中的所有常量<ul><li>隐藏起来了，在反编译中可以查看到，返回类型为该枚举类的数组</li></ul></li><li>valueOf：返回具有指定名称的指定枚举类型的枚举常量，要求字符串必须为已有的常量名，否则报异常<ul><li>就是在已有的枚举常量对象中寻找，并不会创建新的枚举对象</li></ul></li><li>compareTo ： 比较两个枚举常量，比较的就是位置号 </li><li>例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>) ， SUMMER(<span class="string">&quot;夏天&quot;</span>) ，AUTUMN(<span class="string">&quot;秋天&quot;</span>) ,WINTER(<span class="string">&quot;冬天&quot;</span>);</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showElements</span><span class="params">()</span>&#123;</span><br><span class="line">        Season[] array = Season.values();</span><br><span class="line">        <span class="comment">//使用values方法获得枚举类数组</span></span><br><span class="line">        <span class="keyword">for</span>(Season element : array)&#123;</span><br><span class="line">            System.out.println(element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name + <span class="built_in">this</span>.desc ;</span><br><span class="line">        <span class="comment">//根据需要重写toString方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><ul><li><p>注解介绍</p><ul><li><p>注解（Annotation）也被称为元数据（Metadata），用于修饰解释，包，类，方法，属性，构造器局部变量等数据信息</p></li><li><p>和注释一样，注解不影响程序逻辑，但注解可以被编译运行，相当于嵌入在代码中的补充信息</p></li><li><p>在JavaSE中，，注解的使用目的很简单，例如标记过时的功能，忽略警告等。但在javaEE中，注解很重要，例如用来配置应用程序的任何切面，代替javaEE旧版所一流的繁荣代码和XML配置等</p></li></ul></li><li><p>基本的Annotation介绍：  </p><ul><li>在使用注解时要在其前面增加@符号，并把该Annotation当成一个修饰符使用。用于修饰它支持的程序元素.</li><li><strong>注解的作用在于编译器会根据注解的内容进行语法校验</strong><ul><li>例如若在方法前加上@override，则在编译时，编译器会去检查该方法是否时真的是重写了父类中的函数或实现接口中的函数，若没有，则编译不能通过</li></ul></li></ul></li><li><p>三种基本注解类型</p><ul><li><p>@Override : 限定某个方法，表示重写父类方法，该注释只能用于方法</p><ul><li>@Override表示指定重写父类的方法（从编译层面验证），</li><li>若不写@Override注解，而父类有public的同名同返回类型的方法，仍然构成重写</li><li>@Override只能修饰方法，不能修饰类，包，属性等</li><li>查看@Override的源码为： @Target(ElementType.METHOD)，表示只能修饰方法</li><li>@Target是修饰注解的注解，称为元注解</li></ul></li><li><p>@Deprecated: 用于表示某个程序元素（类，方法）已经过时</p><ul><li>表示该类，方法，元素已过时，不推荐使用，但仍可以使用</li><li>可以做到新旧版本的兼容和过度</li></ul></li><li><p>@SuppressWarnings:抑制编译器警告</p><ul><li>当不希望看到警告时可以用@SuppressWarings</li><li>使用方法： @SuppressWarnings({ “ “}),在其中写入希望抑制的警告信息<ul><li>例：抑制所有警告 @SuppressWarings( { “ all “ } )</li><li>具体的警告类型可以自己查询 ， 例如”unused” , “unchecked”</li><li>@SuppressWarings 范围与放置的位置相关，可以放在类前，方法前等</li></ul></li><li>查看源码，该注解类有字符串数组参数String[] value(),用于输入多个警告信息</li></ul></li></ul></li></ul><blockquote><p>查看Override源码， @interface表示是一个注解，而不是接口</p></blockquote><ul><li><p>元注解<br>JDK的元Annotation用于修饰其他Annotation<br>元注解作用不大，了解即可，可多看源码</p><ul><li>元注解的种类<ul><li><p>Retention &#x2F;&#x2F;指定注解的作用范围，三种 SOURCE，CLASS，RUNTIME</p><ul><li>例如@Override的作用域在SOURCE，当编译器编译时生效，不会写入.class文件，也不会在Runtime（运行时）生效</li></ul></li><li><p>Target &#x2F;&#x2F;指定注解可以在哪些地方使用</p><ul><li>@Override的 @Target(ElementType.METHOD)，只能作用于方法</li><li>@SuppressWarings 的@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE}) ，可作用方法，变量等</li></ul></li><li><p>Document &#x2F;&#x2F;指定注解是否在javadoc中体现</p><ul><li>注解中加入@Documented 表示该注解会被保存在javadoc文档中</li></ul></li><li><p>Inherited &#x2F;&#x2F;子类会继承父类注解</p></li></ul></li></ul></li></ul><h1 id="异常和异常处理"><a href="#异常和异常处理" class="headerlink" title="异常和异常处理"></a>异常和异常处理</h1><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul><li><p>基本概念</p><ul><li>java语言中，将程序执行中发生的不正常情况称为“异常” ，</li><li>注意：开发过程中的语法错误和逻辑错误不是异常</li></ul></li><li><p>执行过程中的异常事件主要分为两类</p><ul><li><p>Error（错误）：java虚拟机无法解决的严重的问题，例如JVM系统内部错误，资源耗尽的严重情况。如StackOverflowError[栈溢出] ，Error是严重错误，程序会崩溃</p></li><li><p>Exception : 其他因编程错误或偶然外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如NullPointerException[空指针访问] 等</p><ul><li>Exception可以分为两大类<ul><li><p><strong>运行时异常</strong> ，程序运行时发生的异常，</p></li><li><p><strong>编译时异常</strong> ， 编译时，编译器检查出的异常</p></li></ul></li></ul></li></ul></li><li><p>异常体系图</p><ul><li><p>下列图中列举一些常见异常的继承关系图</p><ul><li>注，绿色虚线代表实现接口，蓝色实线代表类的继承</li></ul></li><li><p><img src="/images/java_base3_04.png" alt="img"></p></li><li><p>总结 ：</p><ul><li><p>异常分为两大类，运行时异常和编译时异常</p></li><li><p>运行时异常，编译器不要求强制处理的异常。一般是指编程时的逻辑错误，程序员应该避免其出现的异常。java.lang.RuntimeException类及他的子类都是运行时异常</p></li><li><p>编译时异常是编译器要求必须处理的异常，Exception中除了RuntimeException和其子类，其余都是编译时异常</p></li></ul></li></ul></li></ul><h3 id="简单的异常捕获机制try-catch"><a href="#简单的异常捕获机制try-catch" class="headerlink" title="简单的异常捕获机制try-catch"></a>简单的异常捕获机制try-catch</h3><ul><li><p>对异常进行捕获，保证程序在遇到异常仍可以继续运行，不会直接崩溃，保证程序健壮性</p></li><li><p>当程序员认为一段代码可能出现异常时，可以用try-catch异常处理机制来解决问题</p></li><li><p>try-catch异常处理机制</p><ul><li><p>语法：  </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;<span class="comment">/*可能产生异常的代码*/</span>&#125;</span><br><span class="line">    <span class="keyword">catch</span>(Typel id1)</span><br><span class="line">    &#123;<span class="comment">/*处理Typel异常的代码*/</span>&#125;</span><br><span class="line">    <span class="keyword">catch</span>(Type2 id1)</span><br><span class="line">    &#123;/处理Type2异常的代码*/&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>在idea中，选中代码块， 快捷键 Ctrl + Alt + t ， 选中try - catch</strong></p></li><li><p>示例：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num3</span> <span class="operator">=</span> num1 / num2 ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception e)</span><br><span class="line">    &#123;<span class="comment">/*处理Typel异常的代码*/</span></span><br><span class="line">        e.printStackTrace();<span class="comment">//打印异常相关信息</span></span><br><span class="line">        System.out.println(e.getMessage);<span class="comment">//打印出现异常的原因</span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="常见的运行时异常"><a href="#常见的运行时异常" class="headerlink" title="常见的运行时异常"></a>常见的运行时异常</h3><ul><li><p>NullPointerException空指针异常</p><ul><li>当应用程序试图在需要对象的地方使用NULL时，抛出该异常</li><li>例: <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object[] array = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">10</span>];</span><br><span class="line">System.out.println(array[<span class="number">1</span>].getClass());</span><br><span class="line"><span class="comment">//创建对象数组时，记得要将数组内每个对象引用都初始化指向实例对象</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>ArithmeticException数学运算异常</p><ul><li>当出现异常的运算条件时，抛出此异常，如将一个整数除以零</li></ul></li><li><p>ArrayIndexOutOfBoundsException数组下标越界异常</p><ul><li>用非法索引访问数组时抛出的异常，如果索引为负或大于等于数组大小，则该索引为非法索引</li></ul></li><li><p>ClassCastException类型转换异常</p><ul><li>当试图将对象强制转换为不是实例的子类时，抛出该异常</li><li>例  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="comment">//main方法中：</span></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> (B) a ;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>NumberFormatException数字格式不正常异常</p><ul><li>当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当形式时，抛出该异常，使用时可以确保我们输入满足条件的字符串</li><li>例 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">test</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span> ;</span><br><span class="line">        Integer.parseInt(test);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="编译异常"><a href="#编译异常" class="headerlink" title="编译异常"></a>编译异常</h3><ul><li><p>概念 ：编译异常是指在编译期间就必须处理的异常，否则代码不能通过编译</p></li><li><p>常见的编译异常：</p><ul><li>SQLException ：操纵数据库时，查询表可能发生异常</li><li>IOEException：操纵文件时繁盛的异常</li><li>FileNotFound：当操纵一个不存在的文件时，发生异常</li><li>ClassNotFoundException：加载类时而该类不存在时，异常</li><li>EOFException : 操纵文件，到文件末尾时，发生异常</li><li>IIIegalArgumentException:参数异常</li></ul></li></ul><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><ul><li><p>基本介绍：<br>异常处理就是当异常发生时，对异常处理的方式</p></li><li><p>异常处理的方式：  </p><ul><li>try-catch-finally</li><li>throws</li></ul></li></ul><h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h3><p>用于程序员捕获在代码中发生异常，自行处理</p><ul><li><p>语法：   </p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//可能有异常的代码</span></span><br><span class="line"><span class="comment">//当异常发生时将异常封装成Exception对象,传递给catch </span></span><br><span class="line">&#125;   </span><br><span class="line"><span class="keyword">catch</span> (Type id) &#123; <span class="comment">//这里的Type是指异常的类，可以根据需要填入不同的异常类   </span></span><br><span class="line"><span class="comment">// 得到异常对象后，处理异常 handle exception ，未发现异常则不执行catch中代码 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;    </span><br><span class="line"><span class="comment">//不管是否发现异常，必须执行finally内的代码块，故通常将释放资源的代码放再finally中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意事项：</p><ul><li><p><u>如果异常发生了，则异常后的代码不会执行，直接进入到catch块</u></p></li><li><p><u>如果异常没有发生，则顺序执行try的代码，不会进入到catch块</u></p></li><li><p>如果希望不管是否发生异常，都执行某段代码块（比如关闭连接，释放资源等）则使用finally</p><ul><li>即使在catch中执行了 return 语句结束 ，finally中的代码仍会执行</li><li>只有当在catch中执行了System.exit(0) ，关闭了jvm，则任何代码都不再执行</li></ul></li><li><p>可以有多个catch语句，捕获不同的异常（针对不同的异常进行不同的业务处理）</p><ul><li><strong>如果发生异常只会匹配一个catch</strong></li><li><strong>要求父类异常在前，子类异常在后</strong>，比如Exception在后，NullPointerException在前）<ul><li>因为父类异常在前，父类exception会捕获所有的子类异常，具体的子类异常处理语句永远无法到达</li></ul></li><li>例：                 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">0</span> ;</span><br><span class="line">&#125; <span class="keyword">catch</span>(NullPointerException e)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是空指针异常&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(ArithmeticException e)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是算数异常&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(RuntimeException e)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;这是运行时异常&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;<span class="comment">//Exception是所有异常的父类</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>可以进行try-finally配合使用，这种用法<strong>相当于没有捕获异常，因此程序会直接崩掉</strong>。</p><ul><li>应用场景是执行一段代码，不管是否发生异常都必须执行某个业务逻辑，执行完finally内的语句后程序会崩掉</li></ul></li></ul></li></ul><h3 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h3><p> 将发生的异常抛出，交给调用者（方法）来处理，最顶级的处理者就是JVM</p><ul><li><p>基本介绍：</p><ul><li>如果一个方法中可能存在某种异常，但是并不能确定如何处理这种异常，则此方法声明应该显示地声明抛出异常，表明方法将不对这些异常进行处理，而<strong>由该方法的调用者负责</strong><ul><li>在方法声明中用throws语句可以声明抛出异常的列表，即抛出多个异常</li><li>throws后面的异常类型可以是方法中产生的具体异常类型，也可以是该异常类型的父类</li></ul></li></ul></li><li><p>基本语法 ：<br>  方法修饰符 + 方法名（） + throws + 该函数中出现的异常{}</p><ul><li>例：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Func</span> <span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">    <span class="comment">//这里可以直接抛出具体的异常，也可以是该异常的父类Exception</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;C:// aa.txt&quot;</span>);</span><br><span class="line">&#125;<span class="comment">//使用throws，抛出异常，让调用Func方法的调用者处理</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>throws使用细节</p><ul><li><p>对于编译异常，程序中必须处理，如try-catch或throws</p></li><li><p><strong>对于运行时异常</strong>，程序中如果没有处理，<u>默认就是throws的方式处理</u></p><ul><li>运行时异常可以不处理，java不强制要求处理，因为运行时异常有默认处理机制</li></ul></li><li><p>在throws过程中，如果有方法 try-catch ，就相当于处理，就可以不必throws</p></li><li><p>子类重写父类方法时，对抛出的异常的规定：子类重写的方法，所抛出的异常类型要么和父类抛出的异常一致，要么为父类抛出的异常的类型的子类型 </p><ul><li><p>即<strong>子类重写的抛出的异常的类型范围不能大于父类异常</strong> </p></li><li><p>父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出</p></li><li><p>例</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;<span class="comment">//发生编译错误</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Father</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            a.method();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RunTimeException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> <span class="keyword">throws</span> RuntimeException&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解析：</p><ul><li>1 因为java的多态机制，在main方法中a.method()实际会调用Son中重写的method()方法</li><li>2 实际在try-catch中时针对父类的method方法做出的捕获，实际却调用子类的method方法，子类重写的方法抛出的异常是Exception，显然用于捕获父类异常的RunTimeException无法捕获该异常，可能会导致不可预测的错误</li><li>3 故在java中，子类重写父类的方法时，子类如果选择抛出异常，那么抛出的异常类型不能大于父类的异常类型</li></ul></li><li><p>这是遵循了java异常处理的多态性原则，确保在子类中重写的方法不会引入比父类更多的异常情况，以确保代码的稳定性和一致性</p></li></ul></li></ul></li></ul><blockquote><p>发生异常时以上两种方案二选一就可，要么在当前函数使用try-catch-finally处理异常，要么继续将异常抛出给调用当前函数的函数让其处理<br>    - 最顶级的异常处理<strong>JVM处理异常的方式是直接输出异常信息，退出程序</strong><br>    - 若无显示处理运行时异常，程序默认采用throws方法</p></blockquote><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><ul><li><p>自定义异常步骤：</p><ul><li>1 定义类： 自定义异常类名 ，继承Exception或RuntimeException</li><li>2 如果继承Exception，一般来说属于编译异常</li><li>3 如果继承RuntimeException ， 属于运行异常（一般来说，继承RuntimeException）  <ul><li>即把自定义异常做成运行时异常，好处在于可以使用运行时异常的默认处理机制</li></ul></li></ul></li><li><p>自定义异常使用实例：</p><ul><li>要求输入一个大于0，小于120的数字，否则抛出异常</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="title function_">MyException</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="comment">//这里的message参数是指该异常相关信息</span></span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="comment">//无参构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main方法中</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">180</span> ;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(num &gt; <span class="number">0</span> &amp;&amp; num &lt; <span class="number">120</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;错啦，数字输入不对&quot;</span>) ;</span><br><span class="line">            <span class="comment">//这里相当于创建一个MyException的匿名对象</span></span><br><span class="line">            <span class="comment">//通过 throw 将异常抛出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>throw 和 throws 的区别</strong></p></li></ul><table><thead><tr><th></th><th>意义</th><th>位置</th><th>后面跟的东西</th></tr></thead><tbody><tr><td>throws</td><td>异常处理的一种方式</td><td>方法声明处</td><td>异常类型</td></tr><tr><td>throw</td><td>是手动生成异常对象的关键字</td><td>方法体中</td><td>异常对象</td></tr></tbody></table><h1 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h1><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><ul><li><p>包装类的分类(Wrapper)</p><ul><li>针对八种基本定义类型的引用类型——包装类</li><li>有了类的特点就可以调用类中的方法  </li><li>包装类都是Object类的子类，实现了Serializable接口，部分实现了Compareable接口</li></ul></li><li><p>基本包装类：</p><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>booelan</td><td>Boolean</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr></tbody></table></li><li><p>包装类与基本数据类型的区别（以int和Integer为例）</p><ul><li>数据类型不同 ，int是基础数据类型，而Integer是包装数据类型</li><li>默认值不同：int的默认值是0，而Integer的默认值是null<ul><li>包装类类型未付初值时的null值，更好表示出该变量当前状态</li></ul></li><li>内存中的储存方式不同：<ul><li>int 在内存中直接储存的是数据值</li><li>Integer实际存储的是对象引用，当new一个Integer时实际上是生成一个指针指向此对象</li></ul></li><li>实例化方式不同：Integer必须实例化才可以使用，而int不需要</li><li>变量的比较方式不同<ul><li>int可以直接用 &#x3D;&#x3D; 来比较两个变量是否相等</li><li>Integer是引用类型 ，必须要用equals来比较两个变量值是否相等，<ul><li>（因为常量池的存在数值在-128-127 之间的Integer对象可以用 &#x3D;&#x3D; 来比较，但超出这个范围就不行）</li></ul></li></ul></li></ul></li><li><p>包装类和基本数据的转换</p><ul><li><p>手动装箱和拆箱演示：以int与Integer转化为例</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"><span class="comment">//基本类型——&gt;包装类型[手动装箱]</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> Integer.valueOf(i);<span class="comment">//包装类内置static函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//包装类型——&gt;基本类型[手动拆箱]</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">99</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">j1</span> <span class="operator">=</span> j.intValue() ;</span><br></pre></td></tr></table></figure></li><li><p>自动装箱（JDK5以后）：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">M</span> <span class="operator">=</span> m ;<span class="comment">//自动装箱，底层是使用valueOf()方法，</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2</span>);<span class="comment">//自动拆箱,底层是使用inValue()方法</span></span><br></pre></td></tr></table></figure></li><li><p>例题：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="literal">true</span> ? <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>) : <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">2.0</span>) ;</span><br><span class="line">System.out.println(obj1) ;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意,此处输出为 1.0 ,并不是 1 。</strong>，根据 Java 语言规范，在这种情况下，需要进行类型转换以使得两个表达式具有相同的类型。Integer 和 Double 是不同的类型。在三元运算符中，为了满足类型一致性的要求，会发生自动类型提升，Integer 会自动转换为更高精度的类型 Double。因此，即使条件为 true，返回的值是 Integer(1)，但最终结果会被自动转换为 Double 类型。因此，最终的输出结果是 1.0 而不是 1。</p></blockquote></li></ul></li><li><p>包装类和String类型的相互转换</p><ul><li><p>包装类转String：（以Integer的转换为例）</p><ul><li>实例：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"><span class="comment">//方案一:字符串拼接</span></span><br><span class="line"><span class="type">String</span> <span class="variable">string1</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span> + num;</span><br><span class="line"><span class="comment">//方案二：调用toString()方法 </span></span><br><span class="line"><span class="type">String</span> <span class="variable">string2</span> <span class="operator">=</span> num.toString();</span><br><span class="line"><span class="comment">//方案三:使用valueOf()方法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">string3</span> <span class="operator">=</span> String.valueOf(num);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>String转包装类：（以Integer的转换为例）</p><ul><li>实例：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span> ;</span><br><span class="line"><span class="comment">//方案一：使用包装类的parse函数</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">num1</span> <span class="operator">=</span> Integer.parseInt(string);<span class="comment">//此处也会发生自动装箱</span></span><br><span class="line"><span class="comment">//方案二：构造器,包装类有多个构造器，可按需调用</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(string);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>一些常用的包装类方法和属性</p><ul><li>继承Number类的数字相关包装类的MaxValue和MinValue值;</li><li>Character.isDigit()判断是不是字母 <ul><li>isLetter(),判断是不是字母</li><li>isUppercase()判断是不是大写字母 </li><li>isLowercase()判断是不是小写字母</li><li>toUppercase()转换成大写字母 </li><li>toLowercase()转换成小写字母</li></ul></li></ul></li><li><p>经典例题：Integer的创建方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>) ;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>) ;</span><br><span class="line">System.out.println( a == b) ;</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line">System.out.println( c == d );</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">e</span> <span class="operator">=</span> <span class="number">128</span> ;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">128</span> ;</span><br><span class="line">System.out.println( e == f );</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">128</span> ;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">128</span> ;</span><br><span class="line">System.out.println( x == y );</span><br></pre></td></tr></table></figure></li><li><p>第一处对比会输出false，因为创建了两个不同的对象，a,b引用指向不同对象</p></li><li><p>第二处对比会输出true；</p><ul><li>底层自动装包会使用valueOf()方法</li><li>查看valueOf()底层源码，发现在值在-127 - 128 时，会从对象数组中直接返回对象，在值不在该范围时才会创建新的对象</li><li>源码分析：IntegerCache是Integer的一个内部类，其中有静态属性cache，是一个Integer类型数组，里面保存了值为-127-128的Integer对象，  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>故此处两个对象引用指向同一个对象，输出true</li></ul></li><li><p>第三处对比会输出false，结合上文介绍，因为128不在设定范围内 故此处会创建两个不同对象。</p></li><li><p>第四处输出true，<u>只要有基本数据类型，判断的是值是否相等</u>，此处会把包装类自动拆箱。</p></li></ul><blockquote><p>这里用到了<strong>享元模式</strong>的设计，享元模式的核心思想是<strong>通过复用对象减少对象的创建数量，从而减少内存的占用和提升性能</strong></p></blockquote><h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><ul><li><a href="https://www.cnblogs.com/xiuzhublog/p/12823838.html">String类详解文章</a></li></ul><h3 id="String-基础"><a href="#String-基础" class="headerlink" title="String 基础"></a>String 基础</h3><ul><li>String类基本介绍<ul><li><p>String对象用于保存字符串，也就是一组字符序列</p><ul><li>String类实现了Serialzable接口，Comparable接口，CharSequeance接口</li><li>实现了Serialzable接口，说明该类可以串行化，该类对象可以在网络上传输</li><li>实现了Comparable接口，说明该类实现了compareTo方法，该类对象之间可以相互比较大小</li></ul></li><li><p>字符串是不可变的。一个字符串对象一旦被分配，其内容是不可变的</p></li><li><p>字符串字符使用Unicode字符编码，<u>一个字符占两个字节</u></p></li><li><p>String 类常用构造器</p><ul><li>new String()</li><li>new String(String original)</li><li>new String(char a[])</li><li>new String(byte[] b)</li></ul></li><li><p>String 类是final的类，不可被继承</p></li><li><p>String中有属性：private final char value[]，用于存放字符串内容</p><ul><li>这个value数组是final类型 ， 赋值后就不能再修改，即value作为引用的存放的地址不能修改, 也即是value的指向不能再修改 </li><li>可查看源码了解</li></ul></li></ul></li></ul><h3 id="String创建机制"><a href="#String创建机制" class="headerlink" title="String创建机制"></a>String创建机制</h3><ul><li><strong>创建String对象的两种方式</strong><ul><li><p>一 .直接赋值 String s &#x3D; “hello” ;</p><ul><li>使用直接赋值时 ，会先从常量池查看是否已有”hello”的数据空间，如果有则直接指向该位置 ； 若是没有则在常量池中重新创建，然后指向常量池中该数据位置，故s最终指向仍是常量池的空间</li></ul></li><li><p>二 .调用构造器 String s &#x3D; new String(“abc”);</p><ul><li><p>这个过程中生成一个或两个对象，取决于常量池是否有该字符串</p></li><li><p><a href="https://cloud.tencent.com/developer/article/1686226">相关解析</a></p></li><li><p>Object类中对String的解释：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(String original)</span> &#123;<span class="number">3</span></span><br><span class="line">    <span class="built_in">this</span>.value = original.value;<span class="comment">//只是引用的传递，并没有在堆中开辟新的空间</span></span><br><span class="line">    <span class="built_in">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么不再在字符串常量池创建该字符串对象，在堆中创建String对象，让栈中的String引用变量s管理该String对象，然后堆中String的属性value指向常量池中的内容</p></li><li><p>如果用String创建的字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中，然后进行如上操作。</p></li><li><p>s最终指向是堆中的空间，(是指向堆中创建的String对象,String对象中的value指向常量池中的数据)</p><ul><li>故如果new两个String &#x3D; “hello”,则两个String的value数组引用中存放的地址相同，即都是常量池中的“hello”。</li></ul></li><li><p><img src="/images/java_base3_05.png" alt="img"></p></li></ul></li><li><p>补充：String的intern()函数</p><ul><li><p>当调用intern方法时，如果池已经包含一个等于此String对象的字符串（用equals(Object)方法确定），则返回来自池的字符串。否则，此String对象将添加到池中，并返回对此String对象的引用</p></li><li><p>即intern()方法最终是返回在常量池中的地址</p></li><li><p>相关实例：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">            <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">            System.out.println(a == b);<span class="comment">//T</span></span><br><span class="line">    </span><br><span class="line">            <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>) ;</span><br><span class="line">            <span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">            System.out.println(c == d);<span class="comment">//F</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​            </span><br><span class="line">            System.out.println(a == d.intern());<span class="comment">//T</span></span><br><span class="line">            System.out.println(c == d.intern());<span class="comment">//F</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>创建字符串对象例题分析：</p><ul><li><p>String a &#x3D; “hello” + “abc”;</p><ul><li>这个过程中创建了一个对象</li><li>编译器会做优化，判断创建的常量池对象是否有引用指向</li><li>故最终优化为String a &#x3D; “helloabc”；</li></ul></li><li><p>String str &#x3D; “hello” + new String(“abc”);</p><ul><li><p>debug跟踪步骤 </p><ul><li>创建一个StringBulider sb &#x3D; new StringBulider();</li><li>执行sb.append(“hello”);</li><li>执行sb.append(“abc”);</li><li>调用sb.toString()<ul><li>这个过程中是创建了新的String对象，以“helloabc”初始化;</li><li>StringBulider的toString方法：返回一个在堆中创建的String对象  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Create a copy, don&#x27;t share the array</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(value, <span class="number">0</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在常量池中创建“helloabc”</li><li>将该String对象返回给c</li></ul></li></ul></li><li><p>这个过程创建了五个对象</p><ul><li><p>常量池中“hello”</p></li><li><p>常量池中“abc”</p></li><li><p>new String(“abc”)匿名对象</p></li><li><p>StringBulider对象sb，用于拼接字符串</p></li><li><p>一个字符串对象，指向堆中的helloabc，交给str管理</p><ul><li>注：StringBuilder内部是可变的字符数组，因为可变，故其不会存放在常量池中，而是在堆中某位置。</li></ul></li></ul></li></ul></li><li><p>总结：</p><ul><li>String c &#x3D; “hello” + “abc”常量相加，c直接指向池</li><li>String c &#x3D; a + b;变量相加， c会指向在堆中创建的String对象</li><li>StringBuilder，StringBuffer等创建的可变字符序列不会放在常量池中</li></ul></li><li><p>补充：</p><ul><li>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</li><li>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码</li></ul></li></ul></li></ul></li></ul><h3 id="String类常用方法"><a href="#String类常用方法" class="headerlink" title="String类常用方法"></a>String类常用方法</h3><p> String类只能保存字符串常量，每次更新都需要重新开辟空间，效率低，因此java设计者还提供了StringBuffer和StringBuider，注意对字符串操作后返回的是全新的字符串，对原字符串没有任何影响</p><ul><li><p>length ,获取字符的个数，字符串长度</p></li><li><p>equals(),判断内容是否相等，区分大小写</p></li><li><p>equalsIgnoreCase(),忽略大小写判断内容是否相等</p></li><li><p>indexOf() ,获取字符在字符串中第一次出现的位置索引，索引从零开始，如果没找到，返回-1</p></li><li><p>lastIndexOf(),获取字符在字符串中最后一次出现的索引，如果没找到，返回-1</p></li><li><p>substring()，截取指定范围的子串</p></li><li><p>trim()，截取前后空格</p></li><li><p>spilt() , 以参数字符串作为标准分割字符串，返回一个字符串数组</p></li><li><p>charAt:获取某索引出的字符，注意不能使用Str[index]这种方式取出字符串的字符</p></li><li><p>format：作为输出的模板</p><ul><li>例：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> String.format(<span class="string">&quot;姓名是%s , 体重是 %.2f&quot;</span>,<span class="string">&quot;hello&quot;</span> , <span class="number">12.012</span>);</span><br><span class="line">System.out.println(info);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> <span class="string">&quot;姓名是%s , 体重是 %.2f&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">info2</span> <span class="operator">=</span> String.format(d , <span class="string">&quot;hello&quot;</span> , <span class="number">12.012</span> )</span><br><span class="line"></span><br><span class="line">System.out.println(info2);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>还有很多字符串函数，根据需要查询</p></li></ul><h2 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h2><ul><li><p>基本介绍</p><ul><li><p>特性</p><ul><li><p>java.lang.StringBuffer代表可变的字符序列，可以对字符串内容进行增删</p></li><li><p>很多方法与String相同，但StringBuffer是可变长度的</p></li><li><p>StringBuffer是一个容器</p></li></ul></li><li><p>结构剖析</p><ul><li><p>StringBuffer的直接父类是 <u>抽象类AbstractStringBuilder</u></p><ul><li>父类中有属性，char[] value ,用于存放字符串内容，因为不是final的，故该value字符数组存放在堆中</li></ul></li><li><p>StringBuffer实现了Serializable接口，即可以串行化</p></li></ul></li><li><p>StringBuffer的构造器</p><ul><li><p>StringBuffer()&#x2F;&#x2F;查看源码发现创建一个长度为16的字符数组 用于存放字符内容</p></li><li><p>StringBuffer(int capacity)&#x2F;&#x2F;创建长度为capacity的字符数组</p></li><li><p>StringBuffer(String str)&#x2F;&#x2F;以str初始化字符数组，创建长度为str.length + 16 的字符数组</p></li><li><p>StringBuffer(CharSequence seq)&#x2F;&#x2F;构造一个字符串缓冲区，它包含与指定的CharSequence相同的字符</p></li></ul></li><li><p>String 与StringBuffer类对比</p><ul><li><p>String保存的是字符串常量，里面的值不能更改，每次String类的更新实际上就是更改地址，效率叫低&#x2F;&#x2F;private final char value[]</p></li><li><p>StringBuffer保存的是字符串常量，里面的值可以更改，每次StringBuffer的更新实际上可以更新内容，不用每次创建新的对象并更新地址，效率高&#x2F;&#x2F;char[] value放在堆中</p></li></ul></li><li><p>String与StringBuffer类的相互转换</p><ul><li><p>String -&gt; StringBuffer</p><ul><li><p>1 使用StringBuffer的构造器：new StringBuffer(str)</p></li><li><p>2 先创建一个空的StringBuffer对象，再使用其提供的append函数将字符串添加近这个对象中</p></li></ul></li><li><p>StringBuffer-&gt; String</p><ul><li><p>1 使用StringBuffer提供的toString()方法</p></li><li><p>2 使用String的构造器在，new String(stringBuffer)</p></li></ul></li></ul></li></ul></li><li><p>StringBuffer常用方法</p><ul><li><p>增： append() &#x2F;&#x2F;有多个append方法，</p></li><li><p>删 delete(start , end) &#x2F;&#x2F;</p></li><li><p>查 indexOf() &#x2F;&#x2F;查找字串在字符串第一次出现的索引如果找不到返回 -1</p></li><li><p>改 replace(start ， end , string) &#x2F;&#x2F;将start-end中的内容替换掉，<u>且不含end</u></p></li><li><p>插入 insert()</p></li><li><p>获取长度length</p></li></ul></li><li><p>实例分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">sb.append(str);</span><br><span class="line">System.out.println(sb.length());<span class="comment">//结果为4</span></span><br><span class="line"><span class="comment">//debug跟踪查看源码，底层用到是AbstractStringBuilder的appendNull方法，将null转化为字符串&quot;null&quot;加入字符串中</span></span><br><span class="line"></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(str);</span><br><span class="line"><span class="comment">//此处调用StringBuffer(String str)构造器，底层会调用str.length ,此处会直接发生异常，抛出NullpointerException</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h2><ul><li><p>基本介绍 </p><ul><li><p>StringBuilder是个可变的的字符序列，此类提供一个与StringBuffer兼容的API，但不保证同步(StringBuilder不是线程安全的)。</p></li><li><p>该类被设计用作StringBuffer的一个简易替换，<strong>用在字符串缓冲区被单个线程使用的时候</strong></p></li><li><p>如果可能，建议优先采用该类，在大多数实现中，它比StringBuffer要快</p></li><li><p>在StringBuilder上的主要操作的是append和insert方法，重载的这些方法可以接受很多类型的数据作为参数</p></li></ul></li><li><p>结构剖析</p><ul><li><p>StringBuilder是final的 ， 不能被继承</p></li><li><p>StringBuilder继承了AbstractStringBuilder属性char value[],对象的字符序列内容存到该value，故也是存放在堆中</p></li><li><p>实现了Serializable接口，说明StringBuilder的对象可以串行化（对象可以网络传输，可以保存到文件）</p></li><li><p>StringBuilder的方法没有做互斥的处理，即没有synchronized关键字，因此最好只在单线程情况下使用StringBuilder</p></li></ul></li><li><p>常用方法：与StringBuffer的方法相近，不在赘述，根据需要查看源码和API文档</p></li></ul><h2 id="String-，-StringBuffer-，-StringBuilder比较"><a href="#String-，-StringBuffer-，-StringBuilder比较" class="headerlink" title="String ， StringBuffer ， StringBuilder比较"></a>String ， StringBuffer ， StringBuilder比较</h2><ul><li><p>String，StringBuilder，StringBuffer非常类似，均代表字符序列，而且方法也大都一样</p><ul><li><p>String：不可变字符序列，效率低，但是也因其不可变特性，使之非常安全且复用率高。</p></li><li><p>StringBuffer:可变字符序列，效率较高（增删），是线程安全的（StringBuffer的方法大都使用了synchronized同步）</p></li><li><p>StringBuilder：可变字符序列，效率最高，但是<u>线程不安全</u></p></li></ul></li><li><p><strong>效率：StringBulider &gt; StringBuffer &gt; String</strong></p><ul><li>验证：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> <span class="number">0L</span> ;</span><br><span class="line">    <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> <span class="number">0L</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span>  <span class="operator">=</span> <span class="string">&quot; &quot;</span>;</span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">70000</span> ; i++)&#123;</span><br><span class="line">        str = str + <span class="string">&quot;i&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    endTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;String的运行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(str);</span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">70000</span> ; i++)&#123;</span><br><span class="line">        sb.append(<span class="string">&#x27;i&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    endTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;StringBuffer的运行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sbd</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">70000</span> ; i++)&#123;</span><br><span class="line">        sbd.append(<span class="string">&#x27;i&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    endTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;StringBuilder的运行时间：&quot;</span> + (endTime - startTime));</span><br></pre></td></tr></table></figure></li></ul></li><li><p>String使用注意：</p><ul><li>String s &#x3D; “a” ; s +&#x3D; “b”; 实际上原来的”a”字符对象已经丢弃了，现在有创建了一个新的字符串”ab”</li><li>如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率，如果这样的操作放到循环中会极大影响程序的性能</li><li>故如果要对字符串做大量修改，不要使用String</li></ul></li><li><p>结论：</p><ul><li>如果字符串存在大量修改操作，用StringBuilder或StringBuffer</li><li>如果字符串存在大量修改操作且在单线程情况下，用StringBuilder</li><li>如果字符串存在大量修改操作且在多线程情况下，用StringBuffer</li><li>如果字符串很少修改，且被多个对象引用，使用String，比如配置信息等</li></ul></li></ul><h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><ul><li><p>Math的主要运用是其中的static方法，具体用法可根据需要查询API文档或查看源码</p><ul><li><p>abs（求绝对值）</p></li><li><p>pow（求幂）</p></li><li><p>ceil（向上取整）</p></li><li><p>floor（向下取整）</p></li><li><p>round（四舍五入）</p></li><li><p>sqrt（求开方）</p></li><li><p>random（返回一个0-1之间的随机数，<u>包括0但不包括1</u>）</p><ul><li>例：获取a - b 之间的一个随机数</li><li>(int)(a + Math.random() * (b - a + 1 ) )</li></ul></li><li><p>补充：Random类：</p><ul><li><p>在java.util包中有一个Random类，它可以在指定的取值范围内随机产生数字</p></li><li><p>构造方法：</p><ul><li>Random() ,无参构造器用于创建一个伪随机数生成器，通过它创建的Random实例对象每次使用的种子是随机的（实际上系统会以当前时间戳作为种子）</li><li>Random(long seed),构造方法使用一个long型的seed种子创建伪随机数生成器</li></ul></li><li><p>特点： 当创建Random类的实例对象时，如果指定了相同的种子，则每个实例对象产生的随机数具有相同的序列</p></li><li><p>Random类常用方法：</p><ul><li>boolean newBoolean() 随机生成boolean类型的随机数</li><li>double nextDouble() 随机生成double类型的随机数</li><li>int nextInt() 随机生成int类型的随机数</li><li>int nextInt(int n ) 随机生成 0 ~ n之间的int类型的随机数（<strong>包括0，不包括n</strong>）</li></ul></li></ul></li></ul></li></ul><h2 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h2><ul><li><p>Arrays中包含了一系列静态方法，用于管理或操作数组（比如排序和搜索）</p><ul><li><p>toString()返回数组的字符串形式</p><ul><li>Arrays.toString(arr);</li></ul></li><li><p>sort()排序 （自然排序和定制排序）</p><ul><li><p>因为数组是引用类型，通过数组排序后会直接影响到实参</p></li><li><p>sort是重载的，可以通过传入接口Comparator实现定制排序</p></li><li><p>自然排序：</p><ul><li><p>若是调用Arrays.sort()没有传入Comparator对象指定排序方法，就会调用其内部的自然排序方法</p></li><li><p>源码实现</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NaturalOrder</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Object&gt; &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object first, Object second)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((Comparable&lt;Object&gt;)first).compareTo(second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">NaturalOrder</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NaturalOrder</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>分析源码，</p><ul><li><p>这里在Arrays类内部创建了一个NaturalOrder内部类，实现了Comparator接口，重写compare函数，并在内部提供了一个返回NaturalOrder对象的静态方法</p></li><li><p>注意这里会将传入的Object对象first强转为Comparable类对象,并会动态调用first的运行类型的CompareTo()方法，若是传入的是自定义的类，这个类若是没有实现Comparable接口则会发生.ClassCastException</p></li><li><p>例：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="type">int</span> num ;<span class="comment">//为了简化代码这里设置为public</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.num = num ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main中：</span></span><br><span class="line">Car[] cars = <span class="keyword">new</span> <span class="title class_">Car</span>[<span class="number">3</span>];</span><br><span class="line">cars[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="number">1</span>) ;</span><br><span class="line">cars[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="number">2</span>) ;</span><br><span class="line">cars[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="number">3</span>) ;</span><br><span class="line">Arrays.sort(cars);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>可定制排序方法，传入实例化的Comparator接口的匿名对象&#x2F;&#x2F;482节,484</p><ul><li><p>public static <T> void sort(T[] a, Comparator&lt;? super T&gt; c)</p></li><li><p>涉及接口编程，匿名内部类，动态绑定&#x2F;&#x2F;具体在hspjava481节</p></li><li><p>注意compare方法返回值是int类型</p></li><li><p>例：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr , Comparator c)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; arr.length ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; arr.length - i - <span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c.compare(arr[j] , arr[ j + <span class="number">1</span> ]) &gt; <span class="number">0</span> )&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j] ;</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>] ;</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main中：</span></span><br><span class="line">Integer[] arr = &#123; <span class="number">1</span> , <span class="number">3</span> , <span class="number">2</span> , <span class="number">4</span> &#125;;</span><br><span class="line">bubbleSort(arr, <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((Integer) o1) - ((Integer) o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//或直接利用Arrays.sort(),但只能接受Obeject类的数组</span></span><br><span class="line">Arrays.sort(arr, <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((Integer) o1) - ((Integer) o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(Arrays.toString( arr ) );</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>binarySearch 通过二分搜索进行查找，要求必须排好序</p><ul><li>如果数组中不存在该元素会返回 (-1)*（ 该元素应该在的位置下标 + 1 ）</li><li>细节查看源码，或查看483节</li></ul></li><li><p>copyof(&lt;&gt;[] array , int length) 数组元素的复制</p><ul><li>复制数组array从数组开头长度为length的内容</li><li>如果length &gt; array.length ,会以null&#x2F;空&#x2F;0等补齐，</li><li>如果length &lt; 0 抛出异常</li></ul></li><li><p>fill 数组元素的填充</p></li><li><p>equals 比较两个数组的元素内容是否完全一致，包括内容和顺序</p></li><li><p>asList 将一组值转换成为List</p><ul><li>List是一个接口，此处返回的List的运行类型是Arrays#ArrayList<ul><li>此处 # 表示ArrayList是Arrays的一个内部类</li></ul></li><li>例：List <Integer> aslist &#x3D; Arrays.asList(2,3,4,5);</li></ul></li></ul></li></ul><h2 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h2><ul><li><p>System常见方法</p><ul><li><p>exit(int status) 退出当前程序</p><ul><li>一般status为0 ， 表示正常退出</li></ul></li><li><p>arraycopy(Object src, int srcPos, Object dest, int destPos,int length) 复制数组元素，比较适合底层调用，一般使用Arrays.copy()完成数组复制</p></li><li><p>currentTimeMillens() 返回当前时间距离 1970 - 1 - 1 的毫秒数</p></li><li><p>gc() 运行垃圾回收机制</p></li></ul></li></ul><h2 id="BigInteger和BigDecimal类"><a href="#BigInteger和BigDecimal类" class="headerlink" title="BigInteger和BigDecimal类"></a>BigInteger和BigDecimal类</h2><ul><li><p>BigInteger</p><ul><li><p>用于大数据处理，保存很大的整形</p></li><li><p>在对BigInteger惊醒加减乘除的时候要使用对应的方法不能直接加减，要创建一个需要操作的BigInteger调用相关方法</p></li><li><p>创建： new BigInteger(“”);</p><ul><li>传入参数要为字符串，底层是当做字符串来处理</li></ul></li><li><p>常见方法</p><ul><li>add 加</li><li>subtract 减</li><li>multiply 乘</li><li>divide 除</li></ul></li></ul></li><li><p>BigDecimal</p><ul><li><p>用于保存处理一个精度很高的浮点型</p></li><li><p>在对BigDecimal惊醒加减乘除的时候要使用对应的方法不能直接加减，要创建一个 BigDecimal 对象，调用相关方法</p></li><li><p>创建； 同样要传入字符串作为构造函数的参数</p></li><li><p>常见方法同上</p><ul><li>但注意在divide时可能产生无限循环小数，抛出ArithmeticException</li><li>解决方法：在调用divide方法时指定精度即可<ul><li>System.out.pritln(bigdecimal.divide(bigdecimal2 , BigDecimal.ROUND_CEILING));</li><li>表示在结果为无限不循环小数时，保留到分子的精度</li></ul></li></ul></li></ul></li></ul><h2 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h2><p> 了解知道即可</p><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><ul><li><p>Date： 精确到毫秒，代表特定的2023年10月4日17:12:17</p></li><li><p>SimpleFormat：格式和解析日期的具体类，它允许进行格式化（日期-&gt;文本），解析（文本-&gt;日期）和规范化</p></li><li><p>具体内容看示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();<span class="comment">//获取当前系统时间</span></span><br><span class="line">System.out.println(<span class="string">&quot;当前日期是:&quot;</span> + d1);<span class="comment">//这是默认日期输出格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建SimpleFormat对象可以指定日期输出格式</span></span><br><span class="line"><span class="comment">//这里的格式是规定好的，具体格式要求在API文档的SimpleFormat类中</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 hh:mm:ss E&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> simpleDateFormat.format(d1) ;<span class="comment">//将日期转换为指定格式字符串</span></span><br><span class="line">System.out.println(<span class="string">&quot;当前日期是:&quot;</span> + format);</span><br><span class="line"><span class="comment">//也可把一个格式化的String转成对应的Date,得到的Date输出还是按照默认模式，如果希望指定格式需要转换</span></span><br><span class="line"><span class="comment">//在String-&gt;Date时，String内容格式要和自定义格式完全匹配，否则抛出异常</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;1996年01月01日 10:20:30 星期一&quot;</span>;</span><br><span class="line"><span class="type">Date</span> <span class="variable">parse</span> <span class="operator">=</span> simpleDateFormat.parse(s) ;</span><br><span class="line">System.out.println(simplrDateFormat(parse.format(parse)));</span><br></pre></td></tr></table></figure></li></ul><h3 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h3><ul><li><p>第二代日期类，Calendar类（日历）</p></li><li><p>Calendar是一个抽象类，它为特定瞬间与一组诸如YEAR，MONTH，DAY_OF_MONTH，HOUR等日期字段之间的转换提供了一些方法，并未操作日历字段提供了一些方法</p></li><li><p>Calendar的构造器是私有的，要使用Calendar.getInstance()函数获取实例，类似于单例设计模式的理念</p></li><li><p>具体使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">cld</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        </span><br><span class="line">System.out.println(cld.get(Calendar.YEAR));<span class="comment">//获取年份</span></span><br><span class="line">System.out.println(cld.get(Calendar.DAY_OF_YEAR));<span class="comment">//当年的第__天</span></span><br><span class="line">System.out.println(cld.get(Calendar.MONTH) + <span class="number">1</span> );<span class="comment">//要加一，因为MONTH从零开始编号</span></span><br><span class="line">System.out.println(cld.get(Calendar.DAY_OF_MONTH));<span class="comment">//该月的第__天</span></span><br><span class="line">System.out.println(cld.get(Calendar.HOUR));</span><br><span class="line"><span class="comment">//Calendar没有专门的格式化方法，要自己组合</span></span><br><span class="line">System.out.println(<span class="string">&quot;今天是&quot;</span> + cld.get(Calendar.YEAR) + <span class="string">&quot;年&quot;</span> + cld.get(Calendar.MONTH) </span><br><span class="line">+<span class="string">&quot;月&quot;</span> + cld.get(Calendar.DAY_OF_MONTH) + <span class="string">&quot;日&quot;</span>);</span><br><span class="line"><span class="comment">//默认是12小时制，若要使用24小时制，将Calendar.HOUR -&gt; Calendar.HOUR_OF_DAY 即可</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="第三代日期类"><a href="#第三代日期类" class="headerlink" title="第三代日期类"></a>第三代日期类</h3><p>因前两代日期类的不足，在JDK8中创建新的日期类</p><ul><li><p>第三代日期类</p><ul><li><p>LocalDate （日期&#x2F;年月日）</p><ul><li>只包含日期，可以获得日期字段</li></ul></li><li><p>LocalTime （时间&#x2F;时分秒）</p><ul><li>只包含时间，可以获取时间字段</li></ul></li><li><p>LocaleDateTime（日期时间&#x2F;年月日时分秒）</p><ul><li>包含时间+日期，可以获得日期和时间字段</li></ul></li></ul></li><li><p>DateTimeFormate格式日期类</p><ul><li>类似于SimpleDateFormat</li><li>DateTimeFormat dtf &#x3D; DateTimeFormatter.ofPattern(格式);</li></ul></li><li><p>Instant 时间戳</p></li><li><p>第三代日期还有很多方法，按需查询即可，不用都记住</p></li><li><p>具体示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="comment">//使用now()返回表示当前日期时间的对象，可以获取年月日时分秒</span></span><br><span class="line">System.out.println(ldt);<span class="comment">//直接输出具体日期时间</span></span><br><span class="line">ldt.getYear();<span class="comment">//获取ldt的年份字段</span></span><br><span class="line">ldt.getMonth();</span><br><span class="line">ldt.getMonthValue();</span><br><span class="line">ldt.getDayOfMonth();</span><br><span class="line"><span class="comment">//关于DateTimeFormatter的格式参数要查看jdk8及以后JDK版本的文档</span></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日 HH小时mm分钟ss秒&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">strDate</span> <span class="operator">=</span> dtf.format(ldt);</span><br><span class="line">System.out.println(strDate);</span><br></pre></td></tr></table></figure></li></ul><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><ul><li><p>保存多个数据用数组有许多不便之处</p><ul><li>长度必须提前指定，且一旦指定无法更改</li><li>保存的必须为同一类型的元素</li><li>使用数组进行元素增加的代码比较复杂</li></ul></li><li><p>引入集合，<a href="https://www.cnblogs.com/xiaoxi/p/6089984.html">相关内容</a></p></li><li><p>集合</p><ul><li>可以动态保存任意多个对象，使用方便</li><li>提供了一系列方便的 操作对象的方法：add ， remove，set，get等</li><li>使用集合添加删除新元素的代码简洁明了</li></ul></li></ul><h2 id="集合的框架体系"><a href="#集合的框架体系" class="headerlink" title="集合的框架体系"></a>集合的框架体系</h2><ul><li><p>java集合框架图</p><ul><li><img src="/images/java_base3_06.png" alt="img"></li></ul></li><li><p>java集合主要分为两大类（单列和双列集合），如图</p><ul><li>Collection类<ul><li><p>Collection接口有两个重要子接口List 和Set，他们的实现子类都是单列集合</p></li><li><p><img src="/images/java_base3_07.png" alt="img"></p></li></ul></li><li>Map类<ul><li>Map的接口的实现子类是双列集合，存放<em>K-V数据</em></li><li><img src="/images/java_base3_08.png" alt="img"></li></ul></li></ul></li></ul><h2 id="Collection-接口"><a href="#Collection-接口" class="headerlink" title="Collection 接口"></a>Collection 接口</h2><ul><li><p>Collection: 单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要子接口List和Set</p></li><li><p>Collection简介      </p><ul><li><p>public interface Collection<E> extends Iterable<E>{}</p></li><li><p>Collection实现子类可以存放多个元素，每个元素可以是Object</p></li><li><p><strong>Collection接口没有直接的实现子类，是通过它的子接口Set和List来实现的</strong></p><ul><li>List的特点是元素有序，可重复</li><li>Set的特点是元素无序，且不可重复</li></ul></li></ul></li><li><p>Collection常用方法（以实现子类ArrayList为例）</p><ul><li><p>add 添加单个元素</p></li><li><p>remove 删除指定元素</p></li><li><p>contains 查找元素是否存在</p></li><li><p>size 获取元素的个数</p></li><li><p>isEmpty 判断是否为空</p></li><li><p>clear 清空</p></li><li><p>addAll 添加多个元素</p></li><li><p>containsAll 查找多个元素是否都存在</p></li><li><p>removeAll 删除多个元素</p></li><li><p>例：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>() ;</span><br><span class="line">list.add(<span class="string">&quot;hello &quot;</span>);</span><br><span class="line">list.add(<span class="number">1</span>) ; <span class="comment">//本质上是发生了list.add(Integer.valueOf(1))</span></span><br><span class="line">System.out.println(list);</span><br><span class="line">System.out.println(list.contains(<span class="number">1</span>)); <span class="comment">//参数是一个Object对象</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><blockquote><ul><li>迭代器Iterator</li><li>迭代器基本介绍<ul><li>Iterator对象成为迭代器，主要用于遍历Collection集合中的元素</li><li>所有实现了Collection接口的集合类都有一个Iterator()方法，用以返回一个实现了Iterator接口的对象，即可以返回一个迭代器<ul><li>因为Collection继承了Iterable接口，也继承其中的iterator()抽象方法，用于返回一个迭代器对象</li></ul></li><li>Iterator仅用于遍历集合，Iterator本身并不存放对象</li></ul></li><li>Iterator 结构<ul><li>Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素</li><li><img src="/images/java_base3_10.png" alt="img"></li></ul></li><li>Itertor接口的方法：<ul><li><img src="/images/java_base3_09.png" alt="img"></li><li>在调用Iterator方法前，迭代器索引位于第一个元素之前，不指向任何元素</li><li>每一次调用next()方法，迭代器会指向下一个数据所在区域并返回该位置的数据</li><li>注意： 在调用Iterator.next()方法前必须要先调用Iterator.hasNext()进行检测，若不调用，且下一条记录无效，直接调用.next()会抛出NoSuchElementException异常</li></ul></li><li>迭代器对象获取集合中的元素时，都会将这些元素当做Object类型来看待，如果想要得到特定类型的元素需要进行强制类型转换</li></ul></blockquote><ul><li><p>Colection接口实现子类的遍历元素方式 ：</p><ol><li><p>使用Iterator(迭代器)遍历</p><ul><li><p>代码示例：（可快捷键“ itit ”直接生成，Ctrl+J显示所有模板快捷键）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//希望遍历上诉代码演示中的list集合</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> list.iterator();<span class="comment">//得到list对应的迭代器</span></span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;<span class="comment">//判断是否还有数据</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    System.out.println(<span class="string">&quot;obj = &quot;</span> + obj );</span><br><span class="line">    <span class="comment">//默认调用toString方法，根据动态绑定机制会找到obj运行类型重写的toString方法</span></span><br><span class="line">&#125;<span class="comment">//当退出while循环时，iterator迭代器指向最后一个元素，若是此时调用iterator.next()会抛出异常</span></span><br><span class="line"><span class="comment">//如果希望再次遍历则需要重置迭代器list。调用list.iterator();</span></span><br></pre></td></tr></table></figure></li><li><p>补充：<strong>在使用Iterator迭代器对集合中的元素进行迭代时，如果调用了集合对象的remove方法删除元素后，继续使用迭代器遍历元素可能会出现异常</strong></p><ul><li>发生了并发修改异常ConcurrentModificationException，这个异常迭代器对象抛出的，出现异常的原因是集合中删除了元素会导致迭代器预期的迭代次数发生改变，导致迭代器的结果不准确</li><li>解决方式：在集合迭代期间删除集合中的元素，可以使用迭代器本身的删除方法：it.remove();<ul><li>例：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> list.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;jack&quot;</span>.equals(obj))</span><br><span class="line">        iterator.remove();</span><br><span class="line">&#125;<span class="comment">//调用迭代器对象的remove方法删除元素导致的迭代次数变化对于迭代器对象本身来说是可预知的</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li><li><p>使用增强for循环</p><ul><li><p>基本介绍</p><ul><li>增强for循环，可以代替iterator迭代器，特点：增强for就是简化版的iterator，本质一样，只能用于遍历集合或是<u>数组</u></li></ul></li><li><p>基本语法：</p><ul><li><p>for(元素类型 元素名 ： 集合名或数组名){    </p><p> &#x2F;&#x2F;访问元素操作</p></li></ul><p>  }  </p></li><li><p>案例演示：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Object obj : list)&#123;<span class="comment">//上述演示中的list集合</span></span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当使用foreach循环遍历集合和数组时，只能访问集合中的元素，而不能对集合中的元素进行修改</p></li></ul></li></ol><ul><li>3 使用普通for循环</li></ul></li></ul><h3 id="List-接口"><a href="#List-接口" class="headerlink" title="List 接口"></a>List 接口</h3><ul><li><p>List接口基本介绍</p><ul><li><p>List是Collection的子接口</p></li><li><p><strong>List集合类中元素有序</strong>（即添加顺序和取出顺序一致），且List内元素可重复</p></li><li><p>List集合中每个元素都有其对应的顺序索引，即支持索引</p><ul><li>索引从零开始</li><li>使用list的get(int index)方法取出</li></ul></li><li><p>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素</p></li><li><p>实现List接口的常用类有：</p><ul><li>ArrayList</li><li>LinkedList</li><li>Vector</li><li>Stack ，等</li></ul></li></ul></li><li><p>List接口常用方法(以ArrayList为例)</p><ul><li><p>void add(int index,Object ele):在index位置插入ele元素，若不加index，则默认插入在List的最后</p></li><li><p>boolean addAll(int index,Collection eles):从index位置开始将eles中的所有元素添加进来</p></li><li><p>boolean remove(Object o)：在ArrayList中查找并删除该对象，如果删除成功（ArrayList中的elementData数组后面的元素后自动前移补充空位）</p></li><li><p>Object get(int index): 获取指定index位置的元素</p><ul><li>取出的数据编译类型是Object，根据需要强转</li></ul></li><li><p>int indexOf(Object obj):返回obj在集合中首次出现的位置</p></li><li><p>int lastIndexOf(Object obj):返回obj在当前集合中最后一次出现的位置</p></li><li><p>Object set(int index , Object ele): 设置指定index位置的元素为ele，替换</p></li><li><p>List subList(int fromIndex , int toIndex):返回从fromIndex到toIndex位置的集合，包括formIndex位置，不包括toIndex位置</p></li><li><p><strong>public void sort(Comparator&lt;? super E&gt; c) ：将list内元素按传入的Comparator方法进行定制排序</strong></p></li></ul></li><li><p>List 的三种遍历方式</p><ul><li><p>List继承Collection接口，其实现子类ArrayList ， LinkedList , Vector等遍历方式与上述Collection实现子类遍历方式相同</p></li><li><p>例：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="comment">//List的实现子类都可以采用已下遍历方式</span></span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;__&quot;</span>);</span><br><span class="line">list.add( <span class="number">1</span> );</span><br><span class="line"><span class="comment">//Iterator迭代器遍历</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> list.iterator() ;</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//增强for循环遍历</span></span><br><span class="line"><span class="keyword">for</span> (Object ele : list)&#123;</span><br><span class="line">    System.out.println(ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通for循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="ArrayList底层结构和源码分析"><a href="#ArrayList底层结构和源码分析" class="headerlink" title="ArrayList底层结构和源码分析"></a>ArrayList底层结构和源码分析</h4><ul><li><p>ArrayList注意事项</p><ul><li><p>permits all elements ,including null,ArrayList可以加入null，并且可以放入多个空值</p></li><li><p>ArrayList是由数组来实现数据储存的</p></li><li><p>ArrayList基本等同于Vector，但ArrayList是线程不安全的（但执行效率高），看源码，多线程情况下不建议使用ArrayList</p><ul><li>ArrayList是线程不安全的，源码里，ArrayList方法等没有synchronized修饰</li></ul></li></ul></li><li><p>ArrayList 底层结构和源码分析</p><ul><li><p>ArrayList中维护了一个Object类型的数组elementData</p><ul><li>源码  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"><span class="comment">//transient 表示瞬间，短暂的，表示是该属性不会被序列化</span></span><br><span class="line"><span class="comment">//设置为非私有以简化嵌套类访问</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>当创建ArrayList对象时，如果使用的是无参构造器，则初始elementData容量为0，第一次添加，则扩容elementData为10，如需再次扩容，则扩容elementData为1.5倍</p><ul><li>无参构造器返回一个静态为空的Object数组</li><li>源码：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">//默认无参构造器：</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//add函数中:先判断容量是否够继续增加元素，若是list为空则增加一个最小容量的Object数组,size为10</span></span><br><span class="line"><span class="comment">//ensureExplictCapacity()方法中的modCount++ 是用于记录当前集合被修改次数，防止多线程操作发生异常</span></span><br><span class="line"><span class="comment">//内部若是容量不够则执行grow()方法扩容</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数组增长扩容函数grow()部分内容：</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line"><span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//第二次及以后扩容为1.5倍</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)<span class="comment">//若newCpacity小于10,则赋值为10 ，第一次扩容为10</span></span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line"><span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line"><span class="comment">//使用Arrays.copyOf()执行数组扩容，可以保留原集合元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>如果使用的是自定义大小的构造器，则初始化elementData容量为自定义大小，如果需要扩容则直接扩容elementData为1.5倍</p></li><li><p>底层是使用<strong>Arrays.copyof()函数扩容</strong></p></li><li><p>具体内容可查看510节</p></li></ul></li></ul><h4 id="Vector-底层结构和源码剖析"><a href="#Vector-底层结构和源码剖析" class="headerlink" title="Vector 底层结构和源码剖析"></a>Vector 底层结构和源码剖析</h4><ul><li><p>Vector类基本介绍</p><ul><li><p>定义说明：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vector</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure></li><li><p>Vector底层也是一个对象数组，protected Object[] elementData ;</p></li><li><p>Vector是线程同步的，即线程安全的，Vector类的操作方法带有<strong>synchronized</strong></p></li><li><p>在开发中，需要线程同步安全时，考虑使用Vector</p></li></ul></li><li><p>Vector底层结构</p><ul><li>Vector和ArrayList的比较：</li></ul><table><thead><tr><th></th><th>底层结构</th><th>线程安全（同步），效率</th><th>扩容倍数</th></tr></thead><tbody><tr><td>ArrayList</td><td>可变数组</td><td>不安全，效率高</td><td>如果是有参构造，扩容1.5倍.无参构造第一次为10，从第二次开始1.5倍扩容</td></tr><tr><td>Vector</td><td>可变数组Object[]</td><td>安全，效率不高</td><td>有参构造，扩容2倍。如果是无参，默认为10，之后每次按两倍扩容</td></tr></tbody></table><ul><li><p>源码分析与ArrayList相似，具体可debug追踪</p><ul><li>注意Vector的扩容机制：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line"><span class="comment">// overflow-conscious code</span></span><br><span class="line"><span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                 capacityIncrement : oldCapacity);<span class="comment">//此处为主要扩容操作  </span></span><br><span class="line"><span class="comment">//capacityIncrement默认是0，可以在构造器中传入，指定每次扩容增加量，否则默认扩双倍</span></span><br><span class="line"><span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = minCapacity;</span><br><span class="line"><span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h4 id="LinkedList-底层结构和源码剖析"><a href="#LinkedList-底层结构和源码剖析" class="headerlink" title="LinkedList 底层结构和源码剖析"></a>LinkedList 底层结构和源码剖析</h4><ul><li><p>LinkedList全面说明</p><ul><li>LinkedList底层实现了双向循环链表</li><li>可以添加任意元素（元素可以重复），包括null</li><li>线程不安全，没有实现同步</li></ul></li><li><p>LinkedList的底层操作机制</p><ul><li>LinkedList底层维护了一个双向链表</li><li>LinkedList中维护了两个属性first和last分别指向首节点和为节点</li><li>每个节点（Node对象），里又维护了prev，next，item三个属性其中通过prev指向前一个，通过next指向后一个节点，最终实现双向链表</li><li>故LinkedList的元素添加和删除通过修改节点之间引用关系即可，相对来说效率较高</li></ul></li><li><p>源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;<span class="comment">//LinkedList维护了一个名为Node的成员内部类，该内部类作为双向链表的节点类</span></span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//LinkedList内部属性：用于储存双向链表的相关属性</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;<span class="comment">//指向双向链表第一个节点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;<span class="comment">//指向双向链表最后一个节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;<span class="comment">//添加链表元素</span></span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;<span class="comment">//添加节点功能实现的主要代码</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line">E <span class="title function_">unlink</span><span class="params">(Node&lt;E&gt; x)</span> &#123;<span class="comment">//实现节点删除功能的主要代码</span></span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="literal">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类似的可多debug跟踪，多注意其中的异常处理内容</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="ArrayList和LinkedList比较"><a href="#ArrayList和LinkedList比较" class="headerlink" title="ArrayList和LinkedList比较"></a>ArrayList和LinkedList比较</h4><table><thead><tr><th></th><th>底层结构</th><th>增删效率</th><th>查改效率</th></tr></thead><tbody><tr><td>ArrayList</td><td>可变数组</td><td>较低，在增加节点过程中发生数组扩容</td><td>较高</td></tr><tr><td>LinkedList</td><td>双向链表</td><td>较高，通过在链表追加节点</td><td>较低</td></tr></tbody></table><ul><li>总结：<ul><li>如果查改操作较多，选择ArrayList</li><li>如果增删操作多，选择LinkedList</li><li>一般来说在程序中大部分都是查询，因此大部分情况下选择ArrayList</li><li>在一个项目中，根据业务灵活选择，不同模块可采用不同的结构</li></ul></li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ul><li><p>Set接口基本介绍</p><ul><li><p><strong>无序</strong>（添加和取出的顺序不能保证一致），没有索引，取出的顺序虽然不同于添加的顺序，但是仍是按某固定的算法控制输出的顺序，不会相同内容每次输出的顺序都不同</p></li><li><p><strong>不允许重复元素</strong>，故最多包含一个null，实现Set接口类的类的实例对象不允许存放重复的元素</p></li><li><p>实现类常用的有：</p><ul><li>HashSet</li><li>TreeSet</li><li>其他可查看API文档</li></ul></li></ul></li><li><p>Set接口的常用方法     </p><ul><li>和List接口一样，Set接口也是Collection的子接口因此，常用方法和Collection接口相同</li><li>因Set的无序性，Set中没有get(int index)方法，也不存在索引值一说</li></ul></li><li><p>Set接口的遍历方式</p><ul><li>同Collection的变能力方式相同，因为Set接口时Collection接口的子接口可以使用迭代器</li><li>增强for</li><li>不能通过索引的方式实现普通for循环遍历</li></ul></li></ul><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><ul><li>HashSet简介<ul><li><p>HashSet实现了Set接口</p></li><li><p>HashSet实际上是HashMap：源码：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;<span class="comment">//HashSet默认构造器</span></span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//Constructs a new, empty set; the backing HashMap instance </span></span><br><span class="line">    <span class="comment">//has default initial capacity (16) and load factor (0.75)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以存放null值，但是只能有一个null</p></li><li><p>HashSet不保证元素是有序的，元素的顺序取决于求hash值后再确定索引的结果</p></li><li><p><strong>不能有重复的元素&#x2F;对象</strong></p><ul><li>例1：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HashSet</span> <span class="variable">hashSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">hashSet.add(<span class="string">&quot;hello&quot;</span>) ;</span><br><span class="line">hashSet.add(<span class="literal">null</span>);</span><br><span class="line">System.out.println(hashSet.add(<span class="string">&quot;hello&quot;</span>));<span class="comment">//此处会输出false</span></span><br><span class="line">System.out.println(hashSet);<span class="comment">//输出结果中只有一个hello </span></span><br></pre></td></tr></table></figure></li><li>例2：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Book</span><span class="params">(String name )</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main中：</span></span><br><span class="line"><span class="type">HashSet</span> <span class="variable">hashSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">hashSet.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;百年孤独&quot;</span>)) ;</span><br><span class="line">System.out.println(hashSet.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;百年孤独&quot;</span>)));<span class="comment">//此处输出true</span></span><br><span class="line">System.out.println(hashSet);<span class="comment">//此处打印出了两个Book对象</span></span><br></pre></td></tr></table></figure></li><li>例3：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HashSet</span> <span class="variable">hashSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">hashSet.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>)) ;</span><br><span class="line">hashSet.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>));<span class="comment">//此处会？</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>  如何理解HashSet不能添加相同的元素&#x2F;对象（跟踪源码）</p><ul><li><p>HashSet底层是HashMap，HashMap底层是数组+链表+红黑树</p></li><li><p>HashMap结构示例图：<br><img src="/images/java_base3_11.png" alt="img">  </p></li><li><p>模拟一个简易的MyHashSet（也就是HashMap），拉链法实现散列表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line"> Object item ;<span class="comment">//存放数据</span></span><br><span class="line"> Node next ;<span class="comment">//存放下一个节点</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Object item, Node next)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.item = item;</span><br><span class="line">      <span class="built_in">this</span>.next = next;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//main中模拟HashMap加入节点的过程</span></span><br><span class="line"> Node[] table = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">16</span>];</span><br><span class="line"> <span class="type">Node</span> <span class="variable">node1</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;hello&quot;</span> , <span class="literal">null</span>) ;</span><br><span class="line"> table[<span class="number">1</span>] = node1 ;<span class="comment">//table的索引为 1 处指向节点node1</span></span><br><span class="line"> <span class="type">Node</span> <span class="variable">node2</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;hi&quot;</span> , <span class="literal">null</span>) ;</span><br><span class="line"> node1.next = node2 ;<span class="comment">//将hi节点挂载在hello节点</span></span><br><span class="line"> <span class="comment">//此时table[1]处便连接一个链表</span></span><br></pre></td></tr></table></figure></li></ul><p>HashSet 的添加元素判断机制：<strong>（hash() + equals()）</strong></p><ul><li>HashSet底层是HashMap</li><li>添加一个元素时，先得到hash()值，会经过运算转化成索引值<ul><li><strong>此处的hash值不完全等于该元素的hashcode()，而是经过一定处理得到</strong>       </li><li>hash算法：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;<span class="comment">//key就是添加的对象</span></span><br><span class="line">    <span class="type">int</span> h;   </span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);  </span><br><span class="line">&#125;<span class="comment">//该算法的作用在于尽量让不同的key得到不同的hash值，尽量避免hash碰撞</span></span><br></pre></td></tr></table></figure></li></ul></li><li>在存储数据表table中看这个索引位置是否已经有存放的元素</li><li>如果没有直接加入</li><li>如果有，调用equals()比较  (此处程序员可通过重写equals方法来控制比较标准) ，如果相同就放弃添加，如果不同则添加到该索引处链表最后</li><li>在java8中，<strong>当如果一条链表长度达到8（TREEIFY_THRESHOLD），且table大小达到64（MIN_TREEIFY_CAPACITY），就会树化（红黑树）</strong></li></ul></blockquote><ul><li>判断新节点是否能加入的代码HashMap的putVal()方法分析：</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">           <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    n = (tab = resize()).length;<span class="comment">//如果table数组为空则创建table数组，并由tab临时变量指向table数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line"><span class="comment">//此处计算要插入的key在table数组中下标索引并赋给临时变量i: i = (n - 1) &amp; hash，同一索引值的节点连接在一个数组后形成链表</span></span><br><span class="line"><span class="comment">//此处中p是putVal方法中定义的临时辅助变量，p指向table数组中key的索引位置后</span></span><br><span class="line"><span class="comment">//如果p指向位置为空，即table[i]后续没有节点，则直接将该key对象加入table[i]后</span></span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//若p的指向table数组的位置后不为空，即table数组该索引位置后有节点</span></span><br><span class="line">    Node&lt;K,V&gt; e; K k;</span><br><span class="line">    <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">        ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">        <span class="comment">//这个判断条件用于确保在 HashMap 中没有重复的键。如果存在重复键，则需要进行覆盖操作，如果不存在则进行插入操作。</span></span><br><span class="line">        e = p;<span class="comment">//辅助变量e指向要传入的节点对应索引位置第一个节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">        e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">    <span class="comment">//判断要key插入的位置后的链表是不是已经被红黑树化，其中调用大量红黑树相关方法</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;<span class="comment">//死循环逐个判断要传入的节点与该索引后链表中节点是否“相同”</span></span><br><span class="line">            <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;<span class="comment">//发现链表中没有“相同”节点，则将该节点加入到链表最后</span></span><br><span class="line">                p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                <span class="comment">//添加节点后立刻判断当前链表是否已经达到8个节点，达到则调用treeifyBin函数，其中还会判断该table数组大小是否超过64</span></span><br><span class="line">                    treeifyBin(tab, hash);</span><br><span class="line">                <span class="comment">// if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span></span><br><span class="line">                <span class="comment">//只有当上述判断条件不成立时才进行树化，否则只是扩容</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//如果发现该链表中有节点和要传入的节点“相同”，则key不能加入，直接跳出循环</span></span><br><span class="line">            p = e;<span class="comment">//节点后移操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">        <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;<span class="comment">//这里的value就是HashSet中的静态成员PRESENT，所有HashSet中节点的Value值都相同</span></span><br><span class="line">        <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">            e.value = value;</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">        <span class="comment">//返回null，表示已经添加成功，在HashSet的add函数中还有一层返回语句如下：</span></span><br><span class="line">        <span class="comment">//return map.put(e, PRESENT)==null;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">++modCount;</span><br><span class="line"><span class="keyword">if</span> (++size &gt; threshold)<span class="comment">//size是HashMap类的属性，如果size大于阈值就扩容</span></span><br><span class="line">    resize();</span><br><span class="line">afterNodeInsertion(evict);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 源码解读看521 - 524节 ，仔细分析HashSet添加元素时调用的HashMap的putVal()方法，</span></span><br></pre></td></tr></table></figure><ul><li><p>补充：</p><ul><li><p>hash值的计算</p><ul><li>此处的hash值不完全等于该元素的hashcode()值，而是经过一定处理得到</li><li>自定义类hashcode方法可由程序员控制，一般重写Object类的hashCode方法用如下形式：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hash();<span class="comment">//Objects.hash()中是可变参数列表</span></span><br><span class="line">&#125;<span class="comment">//利用Objects工具类中的hash函数，参数列表为类中的属性，根据对象中的属性值求出hash值，</span></span><br></pre></td></tr></table></figure><ul><li>利用这种方式重写hashCode()可以保证根据不同的属性内容，计算出的hashCode值也不相同</li></ul></li></ul></li><li><p>i &#x3D; (n - 1) &amp; hash</p><ul><li>这是根据hash值计算key在table数组下标的算法</li><li>在这个表达式中，n 是 HashMap 的容量，而 hash 是键的散列码。&amp; 是位运算符中的按位与运算符。</li><li>由于 n 是HashMap的容量，通常会选择一个2的幂作为容量值（比如16、32、64等），这样可以确保 n - 1 的二进制表示最后m位全是1，其他位都是o0 到 n - 1 的范围内。</li><li>即：（n-1）&amp;hash &#x3D; hash % n</li></ul></li><li><p>if (p.hash &#x3D;&#x3D; hash &amp;&amp;<br>  ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</p><ul><li>p.hash &#x3D;&#x3D; hash 检查当前节点 p 的 hash 值是否与待插入节点的 hash 值相等。这是为了确保hash值相同的对象被散列到相同的桶中</li><li>由于HashMap采用了数组+链表&#x2F;红黑树的存储方式来处理哈希冲突，当发生哈希碰撞时，会将具有相同散列码的键值对放入同一个链表或红黑树中。因此，为了检查待插入的键值对是否需要放入已有的链表或红黑树中，就需要通过比较散列码来确认它们是否应该放在同一个桶中。</li><li>如果 p.hash 和 hash 不相等，那么说明待插入的键值对与已有的键值对散列码不同，它们不应该放在同一个桶中，因此就不需要执行后续的键相等性检查。</li><li>((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))) 则是用来检查键是否已经存在。在这里，首先将当前节点 p 的键存储在临时变量 k 中，然后与待插入键 key 进行比较。</li><li>k &#x3D;&#x3D; key 检查两个键是否是同一对象的引用。如果是，则说明键已经存在于 HashMap 中。</li><li>(key !&#x3D; null &amp;&amp; key.equals(k)) 是更一般化的检查。首先确保待插入键不为 null，然后调用待插入键的 equals 方法来检查是否与当前节点 p 的键相等。这是因为即使两个键不是同一对象的引用，但如果它们在逻辑上相等，则也应视为键已存在于 HashMap 中，会动态绑定调用要比较对象类内的equals方法</li></ul></li></ul></li><li><p>HashSet扩容机制：523-524节</p><ul><li><p>HashSet底层是HashMap，扩容机制主要在HashMap的resize方法中。- 第一次添加时，table数组扩容到16，临界值（threshold）&#x3D; 16 * 加载因子</p><ul><li>static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4; &#x2F;&#x2F; aka 16</li><li>static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;</li></ul></li><li><p>如果<strong>table中加入节点总元素个数</strong>，到了临界值12，就会扩容到16 * 2 &#x3D; 32，新的临界值就是32 * 0.75 &#x3D; 24， 以此类推</p></li><li><p>在添加节点的过程中，若是某个链表长度达到了8，则进入treeifyBin函数，判断<strong>table数组长度</strong>是否大于64，若否，则将该数组扩容两倍，若是则将该链表树化</p></li></ul></li></ul></li><li><p>上述三个HashSet添加元素例子分析：  </p><ul><li>判断标准：if (p.hash &#x3D;&#x3D; hash &amp;&amp;<br>  ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</li></ul><ol><li><p>两次加入的”hello”字符串都是存放在常量池中的同一对象，</p><ul><li>判断1 ：两次加入是同一对象，hash一定相同，为true</li><li>判断2 ：两次加入对象实际就是同一个对象，为true，故上诉判断语句结果为true，无法加入</li></ul></li><li><p>两次加入的是属性name相同的不同的Book对象，</p><ul><li>Book类没有重写hashCode方法，Object中hashCode方法是根据对象的地址来运算得到的，这里是不同对象，hash值不同，故求出的对应索引位置也不同，两个Book对象会加入table数组的不同索引位置后</li></ul></li><li><p>两次加入的是储存字符序列相同的String对象</p><ul><li><p>判断1 ：此处会动态绑定调用String重写的hashCode方法，内容完全相同的字符串返回的hashCode值一定相同，结果为true</p></li><li><p>判断2 ：两次加入的String对象是存放在堆中的不同对象，结果为false</p></li><li><p>判断3：两个String对象进行equals判断，这里会动态调用要判断对象类型的equals函数，String类中重写了Object中的equals函数，判断标准是两个String的内容是否完全相同，结果为true</p></li><li><p>结果为（true&amp;&amp;（false||true）） &#x3D; （true&amp;&amp;true） &#x3D; true，在函数最终结果是不能加入</p></li></ul></li></ol></li><li><p>总结：</p><ul><li><p>调用hashCode()方法来计算对象的哈希值从而确定元素的储存位置，重写hashcode()保证内容相同的对象的hashcode值一定相同，在插入HashMap时会被插入到同一索引位置后以进行后续判断</p></li><li><p>重写equals()保证会根据对象的内容进行判断，防止内容重复对象再次加入HashMap</p></li><li><p>equals函数和hashCode函数都要重写才能确保能按程序员希望的需求进行正确的判断去重，<a href="https://blog.csdn.net/qq_45427600/article/details/113484445">相关解析文章1</a>,<a href="https://cloud.tencent.com/developer/article/1910930">相关解析文章2</a></p></li></ul></li></ul></li></ul><p>​        </p><pre><code>- 例题分析：看551节例题分析：分析如下程序输出结果：    - 这个题还挺恶心的，可以帮助更好了解底层<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//已知Person类按照id和name重写了hashCode和equals方法</span></span><br><span class="line"><span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;AA&quot;</span>) ;</span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1002</span>,<span class="string">&quot;BB&quot;</span>) ;</span><br><span class="line">set.add(p1);</span><br><span class="line">set.add(p2);</span><br><span class="line">p1.name = <span class="string">&quot;CC&quot;</span> ;</span><br><span class="line">set.remove(p1) ;</span><br><span class="line">System.out.println(set);</span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;CC&quot;</span>));</span><br><span class="line">System.out.println(set) ;</span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;AA&quot;</span>));</span><br><span class="line">System.out.println(set) ;</span><br></pre></td></tr></table></figure>- 提示：注意p1的hashcode值的变化- 若是没有重写hashCode和equal结果是什么样的？- 补充：HashMap的table为什么是transient的：    - [相关内容](https://www.cnblogs.com/xrq730/p/5030920.html)-懒    - public native int hashCode();</code></pre><h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><ul><li><p>LinkedHashSet基本介绍：</p><ul><li>LinkedHashSet是 HashSet 的子类</li><li>LinkedHashSet底层是一个LinkedHashMap，底层维护了一个 <strong>数组 + 双向链表</strong></li><li>LinkedHashSet 根据元素的hashCode值来决定元素的储存位置，同时<u>使用双向链表维护元素的次序，这使得元素看起是以插入顺序保存的</u></li><li>LinkedHashSet 不允许添加重复元素</li><li>LinkedHashSet示例结构图：<br>  <img src="/images/java_base3_12.png" alt="img"></li></ul></li><li><p>源码解读：</p><ul><li><p>在LinkedHashMap中维护了一个hash表和双向链表（LinkedHashMap有head和tail）</p></li><li><p>每一个节点有before和after属性，这样可以形成双向链表</p></li><li><p>在添加一个元素时，先求hash值，再求索引，确定该元素在table的位置，若是成功将该元素添加如table，再将添加的元素加入到双向链表（如果该元素已经存在，不添加，添加原则和hashSet一样）    </p><ul><li>因为LinkedHashSet是HashSet的子类，在调用add函数添加元素时直接调用父类的add函数，但在其中创建新节点时动态绑定调用了在LinkedHashSet中重写的newNode函数</li><li>将新插入hash表节点加入双向链表的代码：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tail.next = newElement;</span><br><span class="line">newElement.pre = tali ;</span><br><span class="line">tail = newElement ;</span><br></pre></td></tr></table></figure></li><li>实际添加过程很复杂，自己再debug一边，写的很NB</li></ul></li><li><p>在第一次添加节点时，直接将数组table扩容到16，tabe是HashMap$Node类型数组，存放的节点是 LinkedHashMap$Entry类型对象</p><ul><li>LinkedHashMap$Entry 是LinkedHashMap类中的一个静态内部类</li><li>LinkedHashMap$Entry 继承了HashMap$Node 类,</li><li>LinkedHashMap将传入的数据保存在LinkedHashMap.Entry类对象中</li><li>LinkedHashMap.Entry定义源码：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Node&lt;K,V&gt; &#123;</span><br><span class="line">Entry&lt;K,V&gt; before, after;</span><br><span class="line">Entry(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    <span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>这样遍历LinkedHashSet也能确保插入顺序和遍历顺序一致</p></li></ul></li></ul><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><ul><li><p>TreeSet底层是TreeMap</p><ul><li><strong>Set的value使用一个常量PRSENT占位，所有set是单列，但底层都是Map</strong></li><li>传入Set的对象传入了Map的Key，而Key不能重复，故Set不能加入重复元素<ul><li>TreeSet添加元素源码：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m.put(e, PRESENT)==<span class="literal">null</span>;<span class="comment">//这里的m是TreeSet中定义的Map的一个子类的实例对象</span></span><br><span class="line">    <span class="comment">//PERSENT定义：private static final Object PRESENT = new Object();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>当使用TreeSet的无参构造器创建TreeSet时，TreeSet看起来好像仍是无序的</p></li><li><p>使用TreeSet 提供的一个构造器，传入一个比较器（匿名内部类），Comparator指定排序规则</p><ul><li><p>例：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TreeSet</span> <span class="variable">treeSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>(<span class="keyword">new</span> <span class="title class_">Comparator</span>()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1 , Object o2)</span>&#123;</span><br><span class="line">        <span class="comment">//按需设置返回值，比如设置按字符串长度排序</span></span><br><span class="line">        <span class="keyword">return</span>  ((String)o1).length - ((String)o2)。length ;</span><br><span class="line">    &#125;<span class="comment">//如之前在Comparator部分说明，这个compare函数会被用作内部排序规则</span></span><br><span class="line">&#125;);</span><br><span class="line">treeSet.add(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">treeSet.add(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">System.out.println(treeSet);<span class="comment">//此处只会输出abcd,因为它把长度相同的字符串都认为是同一个key</span></span><br></pre></td></tr></table></figure></li><li><p>在TreeMap源码中 ， 如果加入的Key用传入Comparator的compare方法比较后发现与已有的Key值相同，则return t.setValue(value); </p><ul><li>从TreeSet加入TreeMap中所有节点的value都相同，相当于没有进行任何操作，该新节点也没有被加入</li><li>若是直接用TreeMap类，两次加入节点的Key值相同，return t.setValue(value); 则会使新加入节点的value值替换原有的value值<ul><li>例：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TreeMap</span>  <span class="variable">treeMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>(<span class="keyword">new</span> <span class="title class_">Comparator</span>()&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1 , Object o2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  ((String)o1).length() - ((String)o2).length() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">treeMap.put(<span class="string">&quot;hah&quot;</span>,<span class="string">&quot;123&quot;</span>);</span><br><span class="line">treeMap.put(<span class="string">&quot;hii&quot;</span> , <span class="string">&quot;234&quot;</span>);<span class="comment">//比较器认为两个对象Key相同，value被新的value替换</span></span><br><span class="line">System.out.println(treeMap);<span class="comment">//此处会输出&#123;hah=234&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>跟踪代码，发现用TreeSet默认构造器构造器TreeSet时，Comparator置为NULL，若Comparator为NULL，进行排序判断时会动态绑定使用 Key 对象类的compareTo方法进行元素的排序，而并不是完全的无序</p></li><li><p>下列代码，出现异常，分析原因</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TreeSet</span> <span class="variable">treeSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>() ;</span><br><span class="line">treeSet.put(<span class="keyword">new</span> <span class="title class_">Person</span>());</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体情况可查看543，544节，或跟踪TreeSet 的源码</p></li><li><p>前面在Arrays.sort()中有类似例子，问题在于Person类没有实现Comparable接口</p></li></ul></li></ul><h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><ul><li><p>Map类基本简介</p><ul><li><p>Map是双列集合的根接口， 它的每个元素都包含一个键对象(key)和值对象(Value),键和值对象之间存在一种对应关系，称为映射，从Map集合中访问元素时，可以通过指定的key找到对应的value。</p></li><li><p>Map接口的主要实现类有HashMap，TreeMap等</p></li></ul></li><li><p>Map接口特点：</p><ul><li><p>Map用于保存具有映射关系的数据：Key——Value ，Key和value之间存在<strong>单向一对一</strong>关系，即通过指定的key总能找到对应的value</p><ul><li>key 可以看做时value的“身份证号”，根据key就一定可以找到它对应的唯一的value（姓名）</li><li>但不同的key可以有相同的value值</li></ul></li><li><p>Map中<u>key和value可以是任何引用类型的数据</u>，<strong>会封装到HashMap$Node对象中</strong></p></li><li><p>Map中的<strong>Key是唯一的</strong>，可以为null,，不允许重复，原因如上在HashSet中的分析</p><ul><li>但是当有相同的key，不同value的节点加入时，会以新加入的节点(value)替换原节点(value)</li><li>即键相同，值覆盖；</li></ul></li><li><p>Map中的value可以为null，可以重复</p><ul><li>例如在HashSet底层是HashMap，就利用该特点，在向HashMap中加入节点时，传入的Key为要插入的对象，value为HashSet中的静态Object变量PRESENT</li><li>HashSet的add函数：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;<span class="comment">//所有加入节点都是PRESENT，即所有节点value值都相同</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//PRESENT定义：</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure></li></ul></li><li><p>HashMap为了方便遍历还会创建EntrySet集合，该集合存放元素类型为Entry,而HashMap$Node实现了Entry接口，故Entry类集合可以存放Node类型节点</p><ul><li><p>final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt;</p></li><li><p>Entry接口</p><ul><li>Entry 是一个Map接口中的内部接口类</li><li>把HashMap$Node对象存放在entrySet中。 EntrySet中存放了Entry类的引用，这些引用指向HashMap中的Node节点</li><li>Entry接口提供了getKey()和getValue()方法</li></ul></li><li><p><strong>Map接口没有迭代器，无法直接遍历Node，这时需要通过转变为Set集合，获取到Iterator对象才能方便遍历</strong></p></li></ul></li><li><p>结构图：（真难画（；——_——））<br>   <img src="/images/java_base3_13.png" alt="img"></p></li><li><p><a href="https://blog.csdn.net/qq_39736597/article/details/113762355">Entry相关</a>,或重新看531-534节</p></li></ul></li><li><p>Map接口常用方法</p><ul><li>put:添加</li><li>remove：根据键值删除映射关系</li><li>get：根据key获取value</li><li>size : 获取元素的个数</li><li>isEmpty：判断元素个数是否为0</li><li>clear：清除</li><li>containsKey：查看键是否存在</li></ul></li><li><p>Map接口遍历方法</p><ul><li><p>相关方法：</p><ul><li>containskey():查找键是否存在</li><li>keySet(): 获取所有的键</li><li>values():获取所有的值</li><li>entrySet()：获取储存在Map中所有映射的set集合<ul><li>Entry是Map接口的内部接口</li></ul></li></ul></li><li><p>方式一 ：取出所有Key，通过Key取出对应的Value</p><ul><li>增强for  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Set</span> <span class="variable">keySet</span> <span class="operator">=</span> map.keySet();</span><br><span class="line"><span class="keyword">for</span>(Object key : keySet)&#123;</span><br><span class="line">    System.out.println(key + <span class="string">&quot;-&quot;</span> + map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>迭代器  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> keyset.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next() ;</span><br><span class="line">    System.out.println(key + <span class="string">&quot;-&quot;</span> + map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>方式二：把所有的value取出</p><ul><li>增强for  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">values</span> <span class="operator">=</span> map.values();</span><br><span class="line"><span class="keyword">for</span>(Object value : values)&#123;</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>迭代器  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> values.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>方式三：<strong>通过EntrySet来获取k-v</strong></p><ul><li>通过Map。Entry的setValue来改变value值</li><li>增强for  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> map.entrySet() ;</span><br><span class="line"><span class="keyword">for</span>(Object entry : entrySet)&#123;</span><br><span class="line">    Map.<span class="type">Entry</span> <span class="variable">temp</span> <span class="operator">=</span> (Map.Entry)entry;</span><br><span class="line">    temp.getKey();</span><br><span class="line">    temp.getValue();</span><br><span class="line">    System.out.println(temp.getClass());<span class="comment">//运行类型是HashMap$Node-&gt;实现Map.Entry(getValue(),getKey())</span></span><br><span class="line">    <span class="comment">//但HashMap$Node是default访问权限，无法访问到，故将其从Object类型强转为Map.Entry类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>迭代器原理同上</li></ul></li></ul></li></ul><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><ul><li><p>HashMap小结：</p><ul><li>Map接口的常用实现类：HashMap，Hashtable和Properties</li><li>HashMap是Map接口使用频率最高的实现类</li><li>HashMap是以key-value对的方式来储存数据<ul><li>（k-v）是一个HashMap$Node，实现了Map.Entry，</li></ul></li><li>key不能重复，但是值可以重复，允许使用null键和null值</li><li>如果添加相同的key，会覆盖原来的key-value，修改value值</li><li>与HashSet一样，不保证顺序，底层是以hash表的方式来储存的<ul><li>jdk8 ， HashMap底层 数组 + 链表 + 红黑树</li></ul></li><li>HashMap没有实现同步，因此是线程不安全的，方法没有做同步互斥的操作，即没有synchronized</li></ul></li><li><p>源码解析</p><ul><li><p>绝大部分同上述在HashSet中分析的：<br>   <img src="/images/java_base3_14.png" alt="img"></p></li><li><p>添加机制</p></li><li><p>扩容机制：</p><ul><li>当HashMap中的元素个数超过临界值时会自动触发扩容</li><li>临界值(threashold) &#x3D; 负载因子(loadFactor) * 容量大小(capacity)</li><li>容量大小默认是16 ，负载因子默认大小是0.75，当元素超过12时或扩容为原来的两倍大小</li><li>由于动态扩容机制的存在，实际应用里需要注意，集合初始化时最好要明确指定集合的大小，避免频繁扩容带来的性能上的影响（比如需要向HashMap中添加1024个元素，在默认容量W为16的情况下完成扩容需要扩容七次，在扩容过程中需要创建新的hash表并且完成数据的迁移，对性能影响极大）</li><li>负载因子是0.75原因：负载因子表示Hash表中元素的填充程度，负载因子值越大意味着触发扩容的元素数量会更大，虽然整体的空间利用率较高，但是发生Hash冲突的概率也会增加，负载因子的值的设置就是冲突概率和对空间利用率之间的平衡。0.75与泊松分布相关，当负载因子为0.75时，链表长度几乎不可能达到8，达到了空间成本和时间成本的平衡</li></ul></li><li><p>debug追踪，看537节</p></li></ul></li></ul><h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><ul><li><p>基本介绍：</p><ul><li>Hashtable实现了Map接口</li><li>存放的元素的键值对：K-V</li><li><u>Hashtable的键和值都不能为null</u>,发生NullPointerException</li><li>Hashtable使用方法基本上和HashMap一样</li><li>Hashtable是线程安全的（synchronized），HashMap是线程不安全的</li><li>Hashtable效率太低，存取元素时速度很慢，基本不使用，常用HashMap</li></ul></li><li><p>源码解读 - 看539  </p><ul><li>扩容机制：<br>  int newCapacity &#x3D; (oldCapacity &lt;&lt; 1) + 1;</li></ul></li></ul><h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><ul><li>基本介绍：<ul><li>Properties类继承自Hashtable类并且实现了Map接口，也是使用键值对的形式来保存数据</li><li>使用特点和Hashtable类似</li><li>Properties还可以从 xxx.properties 文件中加载数据到Properties类对象，并进行读取和修改</li><li>说明：xxx.properties 文件常作为配置文件，与IO流相关内容相关，<a href="https://www.cnblogs.com/xudong-bupt/p/3758136.html">相关文章</a></li></ul></li></ul><h2 id="集合总结"><a href="#集合总结" class="headerlink" title="集合总结"></a>集合总结</h2><ul><li><p>在开发中根据实际业务需求和集合实现类特性选择要使用的集合实现类</p></li><li><p>分析：</p><ul><li><p>先判断储存的数据类型</p></li><li><p>若存储一组对象：Collection接口</p><ul><li><p>允许重复：List</p><ul><li>增删多：LinkedList（底层维护了一个双向链表）</li><li>改查多：ArrayList（底层维护了一个Object类型的可变数组，线程不安全）</li></ul></li><li><p>不允许重复：Set</p><ul><li>无序：HashSet（底层是HashMap，维护了一个哈希表，即数组加链表加红黑树）</li><li>排序：TreeSet（底层是TreeMap）</li><li>插入和取出顺序一致 ： LinkedHashSet（底层是LinkedHashMap，维护了数组+双向链表）</li></ul></li></ul></li><li><p>若存储一组键值对： Map</p><ul><li>键无序： HashMap</li><li>键排序：TreeMap</li><li>键插入和取出顺序一致：LinkedHashMap</li><li>读取文件：Properties</li></ul></li></ul></li></ul><h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h2><ul><li><p>Collections是一个操作Set ，List和Map等集合的工具类</p></li><li><p>Collection是中提供了一系列的静态方法对集合元素进行排序，查询和修改等操作</p><ul><li><p>reverse(List):反转List中元素的顺序</p></li><li><p>shuffle(List):对List集合进行随机排序</p></li><li><p>sort(List)：根据元素的自然顺序对List集合元素按升序排序</p></li><li><p>sort(List ,Comparator)：根据指定的Comparator产生的顺序对List集合元素进行排序</p></li><li><p>swap(List , int i , int j)：将指定list集合中i处元素和j处元素进行交换</p></li><li><p>Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素</p></li><li><p>Object max(Collection , Comparator):根据Comparator执行的顺序，返回给定集合中的最大元素</p><ul><li>类似的还有min方法</li></ul></li><li><p>int frequency(Collection ,Object):返回指定集合中指定元素的出现次数</p></li><li><p>void copy(List dest,List src):将src中的内容复制到dest中</p></li><li><p>boolean replaceAll(List list,Object oldVal,Object newVal):使用新值替换List对象的所有旧值</p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;枚举和注解&quot;&gt;&lt;a href=&quot;#枚举和注解&quot; class=&quot;headerlink&quot; title=&quot;枚举和注解&quot;&gt;&lt;/a&gt;枚举和注解&lt;/h1&gt;&lt;h2 id=&quot;枚举&quot;&gt;&lt;a href=&quot;#枚举&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    
    <category term="java" scheme="https://pengzhanyi.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java基础——面向对象基础</title>
    <link href="https://pengzhanyi.github.io/2023/09/19/java_base2/"/>
    <id>https://pengzhanyi.github.io/2023/09/19/java_base2/</id>
    <published>2023-09-19T13:37:20.000Z</published>
    <updated>2023-11-01T08:41:36.495Z</updated>
    
    <content type="html"><![CDATA[<p>java-面向对象基础</p><p>[toc]</p><h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2><ul><li>类是规范，类是定义了这个类所有对象的属性和操作，可以根据类的定义来创建对象</li></ul><h3 id="类的基本内容"><a href="#类的基本内容" class="headerlink" title="类的基本内容"></a>类的基本内容</h3><ul><li>成员变量</li><li>成员函数</li><li>代码块</li></ul><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><ul><li><p>类定义了对象所具有的变量，这些变量就是成员变量（属性）    </p><ul><li>属性定义： 访问修饰符 + 属性类型 + 属性名<ul><li>类的成员变量一般设置为private属性</li></ul></li><li>成员变量的生存期是对象的生存期，作用域是类内部的成员函数</li><li>定义子啊函数内部的变量是本地变量，生存期也作用域都是函数内部</li></ul><blockquote><p>注意在类中成员变量有对象数组时，<strong>使用对象数组前先将其数组成员指向实例化化对象，因为创建的对象数组只是对象引用，对象数组中成员全是null，并无实例，使用时会发生Nonepointerexception</strong></p></blockquote></li></ul><h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><ul><li>成员函数是类对外提供操纵属性的接口  <ul><li>成员函数定义： <ul><li>public 返回数据类型 方法名 （参数表）{函数体}；</li></ul></li><li>可在成员函数内部直接调用自己的其他函数</li><li>在成员函数的外部要通过对象的名字+.来调用该函数</li><li>this是成员函数的一个特殊的固有的本地变量，它表达了调用这个函数的那个对象</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showprice</span><span class="params">(<span class="type">int</span> price)</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">this</span>.price = price;<span class="comment">//利用this来访问被本地变量覆盖的成员变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><ul><li><p>代码块又称为<strong>初始化块</strong>，属于类中的成员，类似于成员函数</p><ul><li>将逻辑语句封装在方法体中，通过{}包围起来，但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显示调用，而是加载类时，或创建对象时隐式调用。</li></ul></li><li><p>基本语法</p><ul><li><p>[修饰符]{<br>  代码块<br>  };</p></li><li><p>注意：</p><ul><li>修饰符可选，要写也只能写static</li><li>代码块分为静态代码块和普通代码块</li><li>逻辑语句可以为任何逻辑语句</li><li>;可以省略</li></ul></li></ul></li><li><p>作用</p><ul><li>相当于另外一种形式的构造器（对于构造器的补充机制），可以做初始化操作</li><li>若多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的复用性</li><li>当不管调用那哪个构造器创建对象都会先调用代码块中的内容<ul><li>代码块调用顺序先于构造器</li></ul></li></ul></li><li><p>注意事项和细节讨论</p><ul><li><p>static代码块也叫<strong>静态代码块</strong>，作用就是<strong>对类进行初始化</strong>，而且它<strong>在类的加载时执行</strong>，<strong>且只会执行一次</strong></p></li><li><p>如果是<strong>普通代码块</strong>，<strong>每创建一个对象就执行一次</strong>，与类加载无关。</p></li><li><p><strong>类什么时候加载</strong></p><ul><li>1 创建对象实例的时候</li><li>2 创建子类对象实例，父类 也会被加载</li><li>3 使用类的静态成员时（静态方法，静态属性）</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span><span class="comment">//例</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类静态代码块调用，父类加载&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类普通代码块调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subclass</span> <span class="keyword">extends</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类静态代码块调用，子类加载&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类普通代码块调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若是 new Subclass() 会输出什么,顺序是什么样的？</span></span><br></pre></td></tr></table></figure><h3 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h3><p> static 修饰符表示静态的，静止的<br><br></p><ul><li><p>类变量</p><ul><li>在类中定义的成员变量加上static关键字就成为类变量（静态变量）</li><li>类变量属于类，    <ul><li>可以通过类名.变量名直接访问</li><li>也可通过该类的实例对象.变量访问</li><li>或在类内的函数中直接用变量名（没有变量名覆盖的情况下）</li></ul></li><li>该类创造的所有对象都可以访问这个类变量，但是都是同一个，这个<strong>类变量不属于任何对象，它属于这个类</strong>，被该类的所有对象共享   <br></li></ul></li><li><p>类函数</p><ul><li>static修饰成员函数表示这个函数只属于这个类</li><li>类函数调用方法<ul><li>对象.函数名 </li><li>类名.函数名  </li><li>也可以在非静态方法中通过this指针来调用类函数和类变量</li></ul></li><li><strong>static函数只能调用static函数，只能访问static的成员变量</strong>，他们都可以通过类名访问，也可以通过对象访问</li><li>static方法中不能使用this关键字</li><li>不能通过static函数获得具体的对象内的信息</li><li>static变量只会在类进入到程序中的时候（程序装载）被初始化，与具体对象的初始化无关</li></ul></li><li><p>类方法和类变量使用场景</p><ul><li>当方法中不涉及任何和相关对象的成员，则可以将方法设计成静态方法，提高开发效率<ul><li>比如，工具类utils中的Math类，Arrays类等</li></ul></li><li>实际开发自己的工具类时，将一些通用的方法设计成静态方法，这样不需要创建对象就可以使用该方法，如打印数组，排序等，</li></ul></li><li><p>静态代码块</p><ul><li>用static修饰的代码块称为静态代码块</li><li>当类被加载时静态代码块会执行，由于类只加载一次，因此静态代码块只执行一次，在程序中通常会使用静态代码块来对类的成员静态变量进行初始化</li></ul></li><li><p>注意事项</p><ul><li>static关键字只能用于修饰成员变量，不能用于修饰局部变量</li><li>在一个静态方法中只能访问用static修饰的成员，因为非静态成员在为必须要创建对象后的实例化才能访问，而静态成员在被调用时可以不创建对象<ul><li><strong>静态方法只能调用静态成员</strong></li><li><strong>非静态方法可以访问所有成员</strong></li></ul></li></ul></li></ul><p>补充<br>main方法语法分析</p><ul><li>解释main方法的形式：<br> public static void main(String[] args){}  <ul><li>1.jvm需要调用类中的main方法，故该方法的访问权限必须是public</li><li>2.jvm在执行main方法时不必创建对象，所以该方法必须是static  </li><li>3.该方法接受String类型的数组参数，该数组中保存执行java命令时传递给所运行类的参数  </li><li>4.java 执行程序 参数1 参数2 参数3<br> 在命令行中 传入参数后，可以在程序中从args中取出这些参数</li></ul></li><li>java执行class文件对package的路径是强依赖的。<br> 它在执行的时候会严格以当前用户路径为基础，按照package指定的包路径转化为文件路径去搜索class文件。所需要返回package指定的包路径的上一层路径去执行，就不会报错了<br> - 例如执行work包内的Test.class文件则需要返回到上一层路径：输入<br> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java work.Test</span><br></pre></td></tr></table></figure></li></ul><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="对象含义"><a href="#对象含义" class="headerlink" title="对象含义"></a>对象含义</h3><ul><li><p>对象 &#x3D; 数据 + 服务（提供的待使用函数）</p></li><li><p><strong>对象变量只是对象的管理者</strong>，对象变量的赋值在默认情况下是引用传递，赋的值是地址，赋值方式为引用传递</p></li><li><p><strong>对象内部的数据应该被保护起来不对外公开，把数据和对数据的操作放在一起，隐藏方法实现法细节，对外提供操作该对象的接口。这就是封装</strong>。</p></li></ul><h3 id="对象的初始化"><a href="#对象的初始化" class="headerlink" title="对象的初始化"></a>对象的初始化</h3><h4 id="成员变量定义初始化"><a href="#成员变量定义初始化" class="headerlink" title="成员变量定义初始化"></a>成员变量定义初始化</h4><ul><li>成员变量在定义的地方就可给出初始值</li><li>没有给出初始值的成员变量会自动获得零值<ul><li>对象的零值表示没有管理任何对象，也可主动给NULL值</li></ul></li><li>定义初始化可以调用函数甚至可以使用已经定义的成员变量<ul><li>例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> f1();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f1</span><span class="params">()</span>&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><ul><li>基本语法<ul><li>[修饰符] + 方法名 （参数表）{函数体}    <br></li></ul></li><li>构造器特点 <ul><li><strong>这个函数没有返回值类型</strong></li><li><strong>这个函数名字和类的名字完全相同</strong></li><li>在创建这个类的每一个对象的时候会自动调用这个函数</li><li>可通过构造器在创建对象的时候就直接完成对象属性初始化<blockquote><p>构造器的最前面<strong>默认情况下隐含了super函数和调用普通代码块</strong>。</p><ul><li>即构造函数（）<br>{<br>super();<br>调用本类的普通代码块;<br>&#x2F;&#x2F;程序员添加的操作<br>}</li><li>故实际上创建对象时先调用构造函数，后调用普通代码块。  </li><li>但执行其中自己添加的语句的顺序是普通代码块先于构造函数</li><li>debug跟踪发现 在创建对象时先进入构造函数，然后再跳转到普通代码块内（无继承发生的情况下）</li></ul></blockquote></li></ul></li></ul><br>  <ul><li>构造器重载<ul><li>构造函数可以<strong>重载（overload）</strong>，可以由多个构造函数，只需要函数的参数表不同</li><li><u>若程序员没有定义构造器，系统会自动给类生成一个默认的空实现的无参构造器。</u><br>  但一旦为该类提供了构造器，系统就不在提供默认的构造器了。</li><li><strong>如果一个类中定义了有参的构造方法，最好再定义一个无参的构造方法</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">hello</span>&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    hello()&#123;</span><br><span class="line">        value = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    hello(<span class="type">int</span> value)&#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><blockquote><p>javap 是JDK提供的一个命令行工具，能对给定的class文件提供的字节码进行反编译，通过他可以对照源代码和字节码了解编译器的内部工作。<br>使用格式：javap <options> <classes> </p><ul><li>常用：javap -c &#x2F;-v 类名 (-c对代码反汇编，-v输出附加信息)</li></ul></blockquote><h3 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h3><ul><li><p>jvm给每个对象分配this，代表当前对象，用于在方法中访问对象中的其他成员。</p><ul><li><p>通过this可以明确地访问一个类的成员变量，解决与局部变量名称冲突问题</p></li><li><p>通过this调用成员方法</p></li><li><p>通过this可以访问构造器</p><ul><li>访问构造器语法： this（参数列表）; </li><li>但<strong>只能在构造器中调用其他构造器，且只能位于第一行，只能出现一次</strong>。</li></ul></li><li><p>this不能在类定义的外部使用，只能在类定义的方法中使用  </p></li><li><p>this访问属性的规则</p><ul><li>1 先找本类，如果有，则调用</li><li>2 如果没有，则找父类（如果父类有并且可以调用，则调用）</li><li>3 如果父类没有则可以继续找父类的父类直到Object类</li><li>注意:如果查找属性的过程中找到了该属性但没有访问权限，则会报错，cannot access ,并不会继续在父类的父类中继续查找该属性，若查找的过程中没有找到，则提示属性不存在。</li></ul></li></ul>  <br></li></ul><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><ul><li>java中的垃圾回收机制：java虚拟机会自动回收垃圾所占用的内存空间</li><li>也可以通过调用System.gc()方法来通知java虚拟机立即执行垃圾回收<ul><li>当一个对象在内存中被释放时，它的 <strong>finalize()</strong> 方法会被自动调用，故可以在类内定义 finalize()方法来观察对象何时被释放</li></ul></li></ul><h1 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h1><h2 id="public"><a href="#public" class="headerlink" title="public"></a>public</h2><ul><li>public表示被修饰的变量&#x2F;函数是开放的，可随意访问的。</li><li>在class关键字前加public表示任何人都可以用这个类来定义对象，如果类是public则要求该类必须处在一个文件名与类名相同的源代码文件中。</li></ul><h2 id="private"><a href="#private" class="headerlink" title="private"></a>private</h2><ul><li><p>private关键字只能用于成员变量和成员函数</p><ul><li>表示被修饰的变量&#x2F;函数是这个类私有的，<strong>只有在类内才能访问</strong>。</li><li><strong>这个限制是对于类的而不是对对象的。即同一个类的不同对象可以互相访问别人的私有成员</strong>，同一个类的对象共用类内函数，判断是否能被访问仅看作用域是否在定义该成员的类中。<a href="https://blog.csdn.net/fukaibo121/article/details/73611184">相关内容</a> </li><li>例：</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Outer</span> <span class="variable">outer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">    <span class="type">Outer</span> <span class="variable">outer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">    outer1.test(outer2);<span class="comment">//outer可以在自己的函数中直接访问到outer2的私有变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Outer tesOuter)</span>&#123;</span><br><span class="line">        System.out.println(tesOuter.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li><li><p>基本原则是所有的成员变量都设置为私有的，保护这些变量不能被外界随意使用，对外提供相应的函数接口让这个类按设计者意图去被使用。  </p></li><li><p><strong>当一个编译单元中有不止一个类的时候，只有一个类可以是public</strong>    </p></li><li><p>如果一个类前没有public，则这个类只能在当前所在的package中起作用，</p></li></ul><h2 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h2><ul><li>子类和同一个package的其他类可以访问。</li></ul><h2 id="friendly（默认）"><a href="#friendly（默认）" class="headerlink" title="friendly（默认）"></a>friendly（默认）</h2><ul><li><p>如果没有在一个成员前private或public修饰，就是friendly，意思是和该成员位于同一个package的其他类可以访问。</p></li><li><p>总结</p></li></ul><table><thead><tr><th>访问范围</th><th>private</th><th>default</th><th>protected</th><th>public</th></tr></thead><tbody><tr><td>同一类中</td><td>可</td><td>可</td><td>可</td><td>可</td></tr><tr><td>同一包中</td><td></td><td>可</td><td>可</td><td>可</td></tr><tr><td>子类中</td><td></td><td></td><td>可</td><td>可</td></tr><tr><td>全局范围</td><td></td><td></td><td></td><td>可</td></tr></tbody></table><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li>封装就是把数据和对数据的操作放在一起，对象内部的数据应该被保护起来不对外公开，对外提供操作该对象的接口。这就是封装。</li></ul><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li><p>可以对数据进行验证，保证安全合理  </p><br></li><li><p>利用接口和实现聚合</p><ul><li>把实现类内成员变量操作的方法在类内实现，对外隐藏细节</li><li>有效利用容器，提升灵活性</li><li>后面代码如何发展与外部无关，提升代码的可拓展性</li><li>以框架 + 数据来提高可拓展性     <br></li></ul></li><li><p>利用封装来降低耦合</p><ul><li>类和类之间的关系成为耦合</li><li>耦合程度越低越好，保持距离，保证代码的可拓展性是形成良好代码的关键</li><li>最好不要在一个类中直接操作，输出另一个类中的成员变量<blockquote><p>建议：一段代码最好只完成一个最小的功能，降低代码之间的耦合性</p></blockquote></li></ul></li></ul><h3 id="封装的实现"><a href="#封装的实现" class="headerlink" title="封装的实现"></a>封装的实现</h3><ul><li>1  将属性进行私有化，保证外部不可随意修改查看属性</li><li>2  提供public的get 和 set方法用于获得和修改属性的值（一般get方法要有返回值，set可以设置为boolean的返回类型）<ul><li>把数据验证和权限判断的代码封装在成员函数内部</li><li>将构造器与set函数结合起来，set方法放入构造器中</li></ul></li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="继承语法"><a href="#继承语法" class="headerlink" title="继承语法"></a>继承语法</h2><ul><li>class 子类 extends 父类{}<ul><li>子类就会自动拥有父类定义的属性和方法</li><li>父类也叫超类 ， 基类</li><li>子类也叫派生类</li></ul></li></ul><h2 id="继承作用"><a href="#继承作用" class="headerlink" title="继承作用"></a>继承作用</h2><ul><li>通过继承可以解决代码复用，</li><li>当多个类中存在相同的属性和方法是，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有子类只需通过<strong>extends</strong>来声明继承父类即可，而不需要子类重新定义这些属性和方法。</li></ul><h2 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h2><ul><li>1 子类继承了父类所有的属性和方法，但private的属性和方法不能在子类直接访问，要通过父类提供的public的方法访问</li><li>2  java继承只支持单继承，一个类只能有一个直接父类</li><li>3 子类可以<strong>重写override</strong>并覆盖父类的同名方法（必须和父类方法名称，参数表相同，子类返回两类型要和父类返回类型一样或者是父类返回类型的子类）</li></ul><h2 id="继承的细节"><a href="#继承的细节" class="headerlink" title="继承的细节"></a>继承的细节</h2><ul><li><p>重写的子类方法权限不能小于父类方法的访问权限  </p><br></li><li><p>访问子类构造方法之前会访问父类构造方法，完成父类的初始化  </p><br></li><li><p>当创建子类对象时，不管子类使用哪个构造器，默认情况下总会去调用父类的无参构造器，<strong>若父类没有提供无参构造器，则必须在子类的构造器中用super去制定使用父类的哪个构造器完成对父类的初始化</strong></p><ul><li>故定义一个类时，无特殊需求时，最好在类中定义一个无参构造器。  <br></li></ul></li><li><p>java所有的类都是Object类的子类    </p><br></li><li><p>父类构造器的调用不限于直接父类，而是一直向上追溯到Object类（顶级父类）</p></li></ul><h3 id="super-函数"><a href="#super-函数" class="headerlink" title="super()函数"></a>super()函数</h3><ul><li><a href="https://blog.csdn.net/pipizhen_/article/details/107165618">super函数相关内容</a></li><li>作用是能够帮助子类初始化从父类继承下来的成员,从而简化代码     <br></li><li>当子类和父类中有重名成员时必须借用super来访问父类成员<ul><li>super的访问不限于直接父类，包括更高级的类也可以用super去访问，若多个基类中都有同名成员，用super访问必须遵循就近原则。A-&gt;B-&gt;C</li><li><strong>但不可跳跃访问，若父类同名变量私有，则不会继续向上查找爷爷类是否还有可访问的同名变量</strong>    <br></li></ul></li><li>super不能出现在静态方法中，static上下文不能够出现 this super。    <br></li><li>super()和this()在使用时，<strong>必须放在构造器第一行</strong><ul><li><strong>this 和 super 访问构造方法不能同时存在</strong></li><li>这里super()的作用是制定调用父类的哪个构造方法</li><li><strong>若没有自己写super函数调用，在实例化子类对象时会自动调用父类无参构造器，效果等同于super（）</strong>;</li></ul></li></ul><h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><ul><li>final关键字用于修饰类，属性，方法和局部变量</li><li>使用final修饰的情况<ul><li>1 当类不希望被继承时，可以用final修饰这个类</li><li>2 当不希望父类的某个方法被子类override时，可以用final修饰这个方法</li><li>3 当不希望某个类的某个属性的值被修改，可以用final修饰这个属性</li><li>4 当不希望某个局部变量的值被修改，可以用final修饰这个局部变量</li></ul></li><li>使用细节<ul><li>final修饰的属性也叫常量，一般用XX_XX（大写字母加下划线）来命名</li><li>final变量是不可改变的，但它的值可以在运行时刻初始化，也可以在编译时刻初始化，甚至可以放在构造函数和代码块中初始化，而不必在声明的时候初始化，所以下面的语句均合法<ul><li>final inti&#x3D;1;&#x2F;&#x2F;编译时刻</li><li>final int i2&#x3D; (int) (Math.Random①* 10)；&#x2F;&#x2F;运行时刻 </li><li>final int i3: &#x2F;&#x2F;构造函数或代码块里再初始化</li></ul></li><li>若final修饰的属性是静态的，则初始化的位置只能是<ul><li>定义时</li><li>在静态代码块中</li><li>（此时不能在构造器中赋值）</li></ul></li><li>final类不能继承但可以实例化对象</li><li>如果类不是final类，但含有final方法，则该方法虽然不能重写但可以被继承 </li><li>若是一个类已经是final类了，则没必要再将其中的方法修饰为final</li><li>final不能修饰构造方法</li><li>final和static搭配使用效率更高，不会导致类加载，底层编译器做了优化<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span> ;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Test类加载&quot;</span>);</span><br><span class="line">    &#125;<span class="comment">//在main中直接输出Test.num,是否会出现类加载的情况？若是去掉static呢？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>包装类如Integer，Double，等都是final类，String也是final类，不可被继承</li></ul></li></ul><h2 id="对象创建具体流程"><a href="#对象创建具体流程" class="headerlink" title="对象创建具体流程"></a>对象创建具体流程</h2><ul><li><p>1，加载类信息，只加载一次</p></li><li><p>2，在堆中分配空间（地址）</p></li><li><p>3，完成对象初始化</p><ul><li>1 默认初始化 （实例化对象时jvm会将成员变量自动初始化为0，null等）</li><li>2 显式初始化 </li><li>3 构造器初始化<blockquote><ul><li>先完成类加载再加载实例对象的相关属性和方法</li><li>注意普通代码块是在构造函数中调用的，构造函数调用先于普通代码块调用<ul><li>子类的初始化依赖于父类的初始化，通常通过调用super()来完成父类的初始化。因此，父类的构造函数调用应该在子类构造函数内的任何其他操作之前，包括子类的实例初始化块和构造函数中的其他代码。</li></ul></li><li>若是普通代码块在构造函数前执行，岂不是意味着普通代码块构造先于构造函数中的super（）初始化父类，父类还没初始化怎么可能用代码块初始化子类对象呢</li><li>调用静态代码块和静态变量的初始化时，他们的优先级相同，若有多个静态代码块和多个非态变量初始化，则按定义顺序调用</li><li>调用普通代码块和非静态变量的初始化时，他们的优先级相同，若有多个普通代码块和多个非静态变量初始化，则按定义顺序调用</li><li>java中实例化对象时调用顺序（debug时程序的调用顺序）：父类静态变量 -&gt;父类静态代码块 -&gt; 本类静态变量 -&gt; 本类静态代码块 -&gt; 本类构造函数 -&gt; 父类构造函数 -&gt; 父类普通变量  -&gt; 父类代码块 -&gt; 本类普通变量 -&gt; 本类代码块 </li><li>java中实例化对象时初始化顺序（指代码执行时程序员自己添加的代码执行顺序）：父类静态变量 -&gt;父类静态代码块 -&gt; 本类静态变量 -&gt; 本类静态代码块  -&gt; 父类普通变量  -&gt; 父类代码块 -&gt; 父类构造函数 -&gt; 本类普通变量 -&gt; 本类代码块 -&gt; 本类构造函数</li></ul></blockquote></li></ul></li><li><p>代码示例：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;<span class="comment">//可debug跟踪查看程序具体执行流程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> getN1();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> getN2();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类静态代码块调用&quot;</span>);</span><br><span class="line">    &#125;;A()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类构造函数调用&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getN1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类静态变量加载&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    &#125;<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getN2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类普通变量加载&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    &#125;&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类普通代码块调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num3</span> <span class="operator">=</span> getN3();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num4</span> <span class="operator">=</span> getN4();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类静态代码块调用&quot;</span>);</span><br><span class="line">    &#125;B()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类构造函数调用&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getN3</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类静态变量加载&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    &#125;<span class="keyword">public</span>  <span class="type">int</span> <span class="title function_">getN4</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类普通变量加载&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    &#125;&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类普通代码块调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//当主类new B时会输出什么结果，为什么会输出这种结果？若是将静态变量定义位置与静态代码块位置交换结果会有不同吗？</span></span><br></pre></td></tr></table></figure><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h2 id="多态基本介绍"><a href="#多态基本介绍" class="headerlink" title="多态基本介绍"></a>多态基本介绍</h2><ul><li>Polymorphic   <br></li><li>为了解决传统代码的复用性不高，不利于代码维护的缺点引入多态    <br></li><li>多态是指<strong>方法或者对象</strong>拥有多种形态，是面向对象的第三大特征，多态是建立在封装和继承的基础上的    <br></li></ul><h2 id="多态的具体体现"><a href="#多态的具体体现" class="headerlink" title="多态的具体体现"></a>多态的具体体现</h2><h3 id="1-方法的多态"><a href="#1-方法的多态" class="headerlink" title="1  方法的多态"></a>1  方法的多态</h3><ul><li>重写和重载体现多态，因参数不同同名函数实际调用方法却不同</li></ul><h4 id="函数调用的绑定"><a href="#函数调用的绑定" class="headerlink" title="函数调用的绑定"></a>函数调用的绑定</h4><ul><li>当通过对象变量调用函数时，调用那个函数这件事叫绑定<ul><li>静态绑定：根据变量的声明类型来决定，<strong>在编译时就确定了调用的函数</strong></li><li><strong>动态绑定</strong>：根据变量的动态类型来决定，<strong>在运行时才能确定调用的函数</strong></li></ul></li></ul><h3 id="2-对象的多态"><a href="#2-对象的多态" class="headerlink" title="2  对象的多态"></a>2  对象的多态</h3><ul><li>一个对象的编译类型和运行类型可以不一致</li><li>编译类型在定义对象时就确定了</li><li>运行类型却是根据实际运行时情况决定</li><li>编译类型看定义时 &#x3D; 左边 ， 运行类型看 &#x3D; 右边<ul><li>编译类型就是这个对象变量的属性且不可修改<ul><li>编译类型是由声明该变量时使用的类型决定的</li></ul></li><li>运行类型是实际赋给该变量的内存空间的模板的类型<ul><li>运行类型是由变量指向的具体对象的类型决定</li><li>可以用getClass函数来获得该变量的运行类型</li></ul></li></ul></li></ul><h4 id="向上造型"><a href="#向上造型" class="headerlink" title="向上造型"></a>向上造型</h4><ul><li><p><strong>子类的对象被当做父类对象来使用</strong>    </p><ul><li><p>子类对象赋值给父类变量</p><ul><li><strong>此时不能通过该变量直接调用子类的特有成员</strong>，只有在子类重写父类方法时才能调用子类重写的方法</li><li>此时调用函数时<strong>先在运行类型（子类）中<em>重写父类的函数</em> 中查找</strong>，若没有再去父类中寻找</li></ul></li><li><p>子类对象可以传递给需要父类对象的函数</p></li><li><p>子类对象可以存放在父类对象的容器中</p></li></ul></li><li><p><strong>通过父类变量调用存在覆盖关系的函数时，会调用变量当时的管理的对象运行类型的函数，这时就会发生多态</strong></p></li></ul><h4 id="向下造型"><a href="#向下造型" class="headerlink" title="向下造型"></a>向下造型</h4><ul><li><p>语法：子类类型 引用名 &#x3D; （子类类型） 父类引用     </p></li><li><p><strong>只能强转父类的引用，不能强转父类对象</strong>      </p></li><li><p>要求父类的引用必须指向的是当前目标类型的对象</p><ul><li>即只能将被向上造型的对象的引用向下强转（即只能往回转，并不能在一个父类对象中创造父类中本没有的子类的成员）</li></ul></li><li><p><strong>可以调用子类类型中所有的成员</strong></p></li></ul><h4 id="动态绑定-DynamicBonding"><a href="#动态绑定-DynamicBonding" class="headerlink" title="动态绑定(DynamicBonding)"></a>动态绑定(DynamicBonding)</h4><ul><li>java的动态绑定机制<ul><li><p><strong>调用对象方法时，该方法会与对象的内存地址&#x2F;运行类型绑定</strong> </p><ul><li>即会首先在运行类型重写方法中寻找该方法 </li><li>具体调用哪个方法在运行时才能解析确定</li></ul></li><li><p>当调用对象属性时，<strong>属性没有动态绑定机制</strong>，哪里声明哪里使用</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span> ;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getI</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i +<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>  <span class="title function_">showI</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getI();<span class="comment">//此处会动态绑定调用B中getI()函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">20</span> ;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getI</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicBoding</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        sout(a.showI());<span class="comment">//运行结果是40</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="多态的细节和注意事项"><a href="#多态的细节和注意事项" class="headerlink" title="多态的细节和注意事项"></a>多态的细节和注意事项</h2><ul><li>属性没有重写一说，属性的值看编译类型  <br></li><li>instanceOf比较操作符，用于判断<strong>对象的运行类型</strong>是否为某运行类型或某类型的子类（就是看该对象的实际内存模型）<ul><li>语法： 对象名 instanceof  类名</li></ul></li></ul><h2 id="多态的应用"><a href="#多态的应用" class="headerlink" title="多态的应用"></a>多态的应用</h2><ul><li>多态数组：数组定义类型为父类类型，里面实际保存类型为子类类型<ul><li>在多态数组循环遍历时可以利用instanceof关键字来判断数组内变量的运行类型，并做出相应类型的操作    <br></li></ul></li><li>多态参数：方法定义的形参为父类类型，实参允许为子类类型</li></ul><h1 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h1><h2 id="抽象类和抽象"><a href="#抽象类和抽象" class="headerlink" title="抽象类和抽象"></a>抽象类和抽象</h2><ul><li><p>当父类的某些方法需要声明，但又不确定如何实现时，可以将该方法声明为抽象（abstract）方法，那么这个类就必须要声明为抽象类</p><ul><li>abstact关键字只能用于修饰类和函数</li></ul></li><li><p>抽象函数——表达概念而无法实现具体代码的函数</p><ul><li>用 abstract关键字修饰一个函数，那么这个函数就是抽象函数</li><li>抽象函数特点<ul><li>抽象函数没有方法体</li><li><strong>抽象函数不能用private，final和static来修饰，因为这些关键字都是与重写相违背的</strong></li><li>如果一个类中抽象函数，那么需要将这个类声明为抽象类</li><li><strong>继承自抽象类的非抽象子类必须覆盖父类中的抽象函数</strong></li></ul></li></ul></li><li><p>抽象类——表达概念而无法构造出实体的类</p><ul><li>用 abstract关键字修饰一个类，那么这个类就是抽象类</li><li>抽象类一般只是作为几个类的公共概念，并为作为父类其提供共有属性</li><li>抽象类特点<ul><li>抽象类不能实例化产生对象</li><li>抽象类仍是类，可以有任意成员</li><li>抽象类中不一定要有抽象函数，但抽象函数必须要在抽象类中</li><li><strong>如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法</strong>，除非他自己也声明为abstract类  </li><li>抽象类的价值在于设计，由设计者设计好之后，让子类继承并实现抽象类</li></ul></li></ul></li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul><li><p>概念</p><ul><li>Java接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）</li><li>接口可以理解为一种特殊的类，里面全部是由全局常量和公共的抽象方法所组成。接口是<strong>解决Java无法使用多继承的一种手段</strong>，但是接口在实际中更多的作用是<strong>制定标准</strong>的。或者我们可以直接把接口理解为100%的抽象类，既接口中的方法必须全部是抽象方法。（JDK1.8之前可以这样理解）</li></ul></li><li><p>基本介绍</p><ul><li>interface 接口</li><li>是一种特殊的class，与class地位相同</li><li>用implements表示类实现接口，在实现接口的类中要实现接口中的所有的抽象函数</li><li>类可以实现多个接口</li><li>接口可以继承接口，但不能继承类</li><li>接口不能实现接口</li></ul></li><li><p>语法</p><ul><li>接口定义：<br>  interface 接口名{<br>  &#x2F;&#x2F;属性方法等<br>  }  <blockquote><p>在jdk7.0之前接口里的所有方法都没有方法体<br>  jdk8.0后接口类中可以有静态函数，默认函数，也就是说接口中可以有方法法具体实现，要用默认函数default关键字修饰</p></blockquote></li><li>接口实现：<br>  class 类名 implements 接口{<br>  &#x2F;&#x2F;自己属性和函数，且必须实现接口的抽象函数<br>  }</li></ul></li><li><p>接口细节 </p><ul><li><p>接口特点</p><ul><li>接口是纯抽象类</li><li>所有的成员函数默认是public的抽象函数,可以不用abstract修饰</li><li><strong>所有的成员变量都默认是public static final</strong> </li><li>接口的修饰符只能是public和默认  </li><li>接口只是规定了长什么样子，但是不管里面有什么<ul><li>例  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//就是public static final int a = 1 ;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="comment">//主方法中创建B实例对象b,是否可以输出 b.a , B.a , A.a ?</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>接口实现细节 </p><ul><li>当一个类实现接口时，如果这个类是抽象类，则可以只实现接口中的部分方法，否则要实现接口的所有抽象函数</li><li>一个类可以同时实现多个接口，接口之间用逗号， 隔开</li><li><strong>任何实现了接口的类都可以传递给需要接口类对象的函数</strong><ul><li>此时可以在该函数中调用接口中的函数。</li></ul></li></ul></li><li><p>接口继承细节</p><ul><li>接口不能继承类但接口可以继承接口，用extends关键字，且可以继承多个接口，用逗号，隔开</li><li>一个类在基础恒另一个类的同时还可以实现接口，此时extends关键字必须位于implements关键字之前</li></ul></li></ul></li><li><p>实现接口与继承类的比较</p><ul><li>接口与继承解决的问题不同<ul><li>继承的价值在于：提升代码的复用性和可维护性</li><li>接口的价值在于：设计，设计好各种规范和方法，让其他类去实现这些方法，更加灵活</li></ul></li><li>接口在一定程度上实现代码解耦[即：接口规范性 + 动态绑定]</li></ul></li><li><p>接口的作用：_<strong>通过将接口的声明与实现分开，业务中只需关心方法而不需关心具体的实现类，从而实现代码的解耦和模块化</strong>_</p></li><li><p>接口的多态</p><ul><li>多态参数<ul><li>接口类型的变量可以指向实现了该接口的类的对象</li></ul></li><li>多态数组<ul><li>可以创建接口类型的数组，其中的引用指向实现了该接口的类的对象</li><li>在调用数组中变量的被实现的接口类的抽象函数时，会动态绑定调用该对象运行类型类中实现的接口中的抽象函数</li></ul></li><li>接口多态传递</li></ul></li></ul><br>- 一个简单的运用接口的例子：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComputerRun</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        <span class="type">Mouse</span> <span class="variable">mouse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mouse</span>();</span><br><span class="line">        <span class="type">Keyboard</span> <span class="variable">keyboard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Keyboard</span>();</span><br><span class="line">        computer.addNewDevice(mouse);</span><br><span class="line">        computer.addNewDevice(keyboard);</span><br><span class="line">        computer.toolOn();</span><br><span class="line">        computer.toolOff();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Usb</span>&#123;<span class="comment">//接口相当于提供一种规范,要求实现接口的类必须实现某些函数</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">toolOn</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">toolOff</span><span class="params">()</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Usb2</span> <span class="keyword">extends</span> <span class="title class_">Usb</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span> <span class="keyword">implements</span> <span class="title class_">Usb</span>&#123;<span class="comment">//实现接口</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//private Usb he = new Usb();错误！不能将接口类实例化</span></span><br><span class="line">    <span class="comment">//但可以实现接口的数组，因为这里只是创建了接口类的引用，并没有创建接口实例，引用可以指向实现了接口的其他类的对象实例</span></span><br><span class="line">    <span class="keyword">private</span> Usb[] devices = <span class="keyword">new</span> <span class="title class_">Usb</span>[<span class="number">2</span>]; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//在这里接口类参数相当于一种规范，只有实现了Usb接口的对象才能传入这个函数，并且不管这个对象内部有什么</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNewDevice</span><span class="params">(Usb device)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//只是将用接口类引用指向传入的对象，类似于向上造型</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; devices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(devices[i] != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">continue</span> ;</span><br><span class="line">            </span><br><span class="line">            devices[i] = device;</span><br><span class="line">            <span class="keyword">if</span>(devices[i] <span class="keyword">instanceof</span> Keyboard)&#123;</span><br><span class="line">                <span class="type">Keyboard</span> <span class="variable">test</span> <span class="operator">=</span> (Keyboard) devices[i];<span class="comment">//向下造型</span></span><br><span class="line">                System.out.println(<span class="string">&quot;鼠标名是&quot;</span> + test.name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toolOn</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; devices.length; i++) &#123;</span><br><span class="line">            devices[i].toolOn();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;电脑启动&quot;</span>);</span><br><span class="line">        <span class="comment">//传入的对象都是实现了接口的，这里会发生多态，调用其运行类型的类内实现的接口抽象函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toolOff</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; devices.length; i++) &#123;</span><br><span class="line">            devices[i].toolOn();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;电脑关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mouse</span> <span class="keyword">implements</span> <span class="title class_">Usb</span>&#123;<span class="comment">//</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toolOn</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鼠标启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toolOff</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鼠标关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Keyboard</span> <span class="keyword">implements</span> <span class="title class_">Usb2</span>&#123;<span class="comment">//实现Usb2，而Usb2继承了Usb，故相当于keyboard类也实现了Usb接口，可以传递给Usb类的引用，这就是接口多态传递</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;罗技&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toolOn</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;键盘启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toolOff</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;键盘关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>面向接口的编程方式<ul><li>设计程序时先定义接口，再实现类</li><li>任何需要在函数间传入传出的一定是接口而不是具体的类（可扩展性高）</li><li>是java成功的关键，适合写大型程序，也导致程序代码量膨胀极快      <br></li></ul></li><li>两种抽象<ul><li>与具体相对<ul><li>表达一种概念而非实体</li></ul></li><li>与细节相对<ul><li>表示在一定程度上忽略细节关注大局</li></ul></li></ul></li></ul><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><ul><li><p>简介：</p><ul><li>提供一种快速简介的方式来实现接口，</li><li>接口的抽象方法的具体实现直接在Lambda表达式里定义即可，而不用像传统方法一样定义类，实现接口的抽象方法，实例化对象在调用方法的繁琐步骤</li><li>lambda表达式可以直接实现接口的抽象方法，然后可以等效作为一个实现接口类的实例化对象使用。</li><li>实例：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">   <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main中：</span></span><br><span class="line"><span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Car is running &quot;</span>) ;</span><br><span class="line">&#125;;</span><br><span class="line">car.run() ;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>语法： () -&gt; {}</p><ul><li><p>这里的 ( ) 中的内容是interface中抽象方法的参数表，{} 中是实现抽象方法的函数体</p></li><li><p>如果lambda函数体(即大括号中)中只包含一个表达式，那么此时大括号可以省略，但如果lambda函数体包含多条语句或有明确的流程控制则必须要使用大括号</p></li><li><p>如果抽象方法中有参数，则也需要在 () 中加入参数，参数类型可以不写</p><ul><li>例：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main中：</span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">car</span> <span class="operator">=</span> ( String name ) -&gt; &#123;</span><br><span class="line">    System.out.println( name + <span class="string">&quot; is running &quot;</span> );</span><br><span class="line">&#125; ;</span><br><span class="line">car.run(<span class="string">&quot;cow&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>也可以直接作为参数传递给函数：</p><ul><li>例：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">animalRun</span><span class="params">(Animal animal)</span>&#123;</span><br><span class="line">    animal.run(<span class="string">&quot;cow&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">main中：</span><br><span class="line">animalRun((name) -&gt; &#123;</span><br><span class="line">     System.out.println( name + <span class="string">&quot; is running &quot;</span> );</span><br><span class="line">&#125;) ;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>使用限制</p><ul><li><strong>Lambda表达式只能用于有且只有一个抽象方法的接口上</strong>，我们称这样的接口为函数式接口(Functional Interface)</li><li>只要函数式接口才可以使用lambda表达式</li><li>因为当接口中有多个表达式时，java将无法确定lambda表达式中是要实现哪个抽象方法</li><li>可以使用@FunctionalInterface来标注某个接口是一个函数式接口，这样编译器就会检查当前接口是否满足函数式接口的条件</li></ul></li><li><p>lambda表达式是一种语法糖，就是用于简化函数式接口的实现，在java的函数式编程中起关键作用</p></li></ul><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><ul><li>基本介绍<ul><li>一个类内部有完整的嵌套了另一个类结构，被嵌套的类称为内部类（inner class），</li><li>嵌套其他类的类称为外部类（outer class）。</li><li>内部类是类的第五大成员。<ul><li>类的五大成员：<ul><li>属性</li><li>方法</li><li>构造器</li><li>代码块</li><li>内部类</li></ul></li></ul></li><li>内部类的最大特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系</li></ul></li><li>基本语法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- <span class="keyword">class</span> <span class="title class_">Outer</span>&#123;<span class="comment">//外部类  </span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;<span class="comment">//内部类  </span></span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">other</span>&#123;<span class="comment">//外部其他类</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>分类<ul><li>定义在外部类局部位置上：<ul><li>局部内部类（有类名）</li><li><strong>匿名内部类</strong>（没有类名）【重要！】</li></ul></li><li>定义在外部类的成员位置上：<ul><li>成员内部类（没用static修饰）</li><li>静态内部类（使用static修饰）</li></ul></li></ul></li></ul><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><ul><li><p>定义</p><ul><li>局部内部类是 <strong>定义在外部类的局部位置（方法和块中）</strong>，并且有类名</li><li>本质仍然是一个类</li></ul></li><li><p>特点</p><ul><li>可以直接访问外部类所有成员，包含私有的</li><li>不能添加访问修饰符，因为它的地位就是一个局部变量<ul><li>局部变量不能使用修饰符，但可以使用final修饰</li><li>加final修饰后就不可被继承</li></ul></li></ul></li><li><p>作用域：<strong>仅仅在定义它的方法或代码块中</strong></p></li><li><p>访问权限</p><ul><li>局部内部类访问外部类的成员<ul><li>直接访问</li></ul></li><li>外部类访问局部内部类成员<ul><li>先创建对象，再访问（注意，必须在作用域内创建对象）</li></ul></li><li>外部其他类不能访问局部内部类，因为局部内部类地位是一个局部变量</li></ul></li><li><p>如果外部类和局部内部类重名时，默认遵循就近原则</p><ul><li>如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClassTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        outer.function();</span><br><span class="line">        System.out.println(<span class="string">&quot;调用内部类函数的对象的哈希值 = &quot;</span> + outer.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">3</span> ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;外部类方法调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">function</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//局部内部类是定义在外部类的局部位置，通常在方法中</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;<span class="comment">//作用域仅仅在定义它的方法和代码块中</span></span><br><span class="line">            <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">2</span> ;</span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">printinfo</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//访问外部类重名属性使用（外部类名.this.成员）格式</span></span><br><span class="line">                <span class="comment">//这里Outer.this本质就是外部类的对象，即那个对象调用了printinfo函数，</span></span><br><span class="line">                <span class="comment">//Outer.this就是哪个对象,可以通过比较Outer.this和调用该函数的对象的哈希值</span></span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;外部类私有属性num = &quot;</span> + Outer.<span class="built_in">this</span>.num);</span><br><span class="line">                System.out.println(<span class="string">&quot;内部类属性    num = &quot;</span> + <span class="built_in">this</span>.num);</span><br><span class="line">                System.out.println(<span class="string">&quot;就近访问的    num = &quot;</span> + num);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;Outer.this的对象的hashcode值 = &quot;</span> + Outer.<span class="built_in">this</span>.hashCode());</span><br><span class="line"></span><br><span class="line">                method();<span class="comment">//可以直接访问外部类的所有的成员和方法</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在定义这个内部类的方法中创建内部类实例对象，直接调用方法即可</span></span><br><span class="line">        <span class="type">Inner</span> <span class="variable">doPrint</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        doPrint.printinfo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//private Inner doPrint2 ;//错误，在定义局部内部类的函数之外无法访问到这个类</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="匿名内部类-重要"><a href="#匿名内部类-重要" class="headerlink" title="匿名内部类(重要)"></a>匿名内部类(重要)</h2><p>AnonymousInnerClass</p><ul><li>定义<ul><li>匿名内部类是定义在外部类的局部位置，比如方法中，并且没有类名的内部类</li></ul></li><li>本质<ul><li>本质是类</li><li>内部类</li><li>该类没有名字</li><li>同时还是一个对象</li></ul></li><li>基本语法<ul><li>new 类或接口(参数列表){<br>  类体<br>  };</li></ul></li><li>产生原因<ul><li>基于需求，当需要创建一个类实现一个接口，创建对象，但<strong>仅使用一次</strong>后面不在使用</li><li>为了简化开发</li></ul></li></ul><h3 id="实现接口的匿名内部类"><a href="#实现接口的匿名内部类" class="headerlink" title="实现接口的匿名内部类"></a>实现接口的匿名内部类</h3><ul><li>分析下列实例<ul><li>keyboard引用就是指向实现的匿名对象</li><li>keyboard的编译类型是Usb</li><li><strong>keyboard的运行类型就是该匿名内部类</strong></li><li>底层就相当于  <ul><li>class XXXX implements Usb{<br>public void deviceRun(){}<br>  }</li><li><strong>即创建出一个实现了USb接口的类</strong></li><li>这里的XXXX是由系统分配的，如果用getClass函数输出，一般匿名内部类的class输出会包含一个$字符</li></ul></li><li><strong>基于接口的匿名内部类必须要实现对应接口的抽象函数</strong></li><li>匿名内部类使用一次后就无法再使用，即只能创建一个实例对象</li><li>匿名内部类内部可以添加实现其他接口中没有的属性和方法<ul><li>但创建实例后无法访问，因为其运行类型是匿名类，无法向下造型</li><li>但可以但可以在重写的方法中调用新添加的方法</li></ul></li></ul></li><li>例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Usb</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deviceRun</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Keyboard</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Usb</span> <span class="variable">keyboard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Usb</span>&#123;</span><br><span class="line">            <span class="comment">//实现对应接口的抽象函数</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deviceRun</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;键盘启动&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        keyborad.deviceRun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="基于类的匿名内部类"><a href="#基于类的匿名内部类" class="headerlink" title="基于类的匿名内部类"></a>基于类的匿名内部类</h3><ul><li>分析下列实例代码<ul><li>base是Base类型的引用指向创建的匿名内部类对象</li><li>base的编译类型是Base</li><li><strong>base的运行类型就是该匿名内部类</strong></li><li><strong>底层就相当于</strong>  <ul><li>Base base&#x3D; new XXXX();<br>  class XXXX extends Base{<br>  &#x2F;&#x2F;故即使方法块中没有任何语句，XXXX仍是一个新的区别于Base的类<br>  }</li><li>即<strong>创建了一个继承base的子类XXXX</strong></li></ul></li><li>匿名内部类创建时的参数列表会传递给匿名内部类基类的构造器</li><li>匿名内部类内部可以重写类中的方法</li><li>匿名内部类使用一次后就无法再使用，即只能创建一个实例对象</li><li>匿名内部类内部可以添加实现类中本没有的属性和方法<ul><li>但创建实例后无法直接访问，因为其运行类型是匿名类，无法向下造型</li><li>但可以在重写的父类的方法中调用新自己添加的方法</li></ul></li></ul></li><li>例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHi</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;, Hi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getname</span><span class="params">()</span>&#123;<span class="keyword">return</span> <span class="built_in">this</span>.name;&#125;;</span><br><span class="line">    Base(String name)&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">testClass</span>&#123;</span><br><span class="line">    <span class="comment">//这里的参数列表会传递给匿名内部类基类的构造器</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Base</span> <span class="variable">base</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Base</span>(<span class="string">&quot;Tom&quot;</span>)&#123;</span><br><span class="line">        <span class="comment">//在方法体重可以重写对应类的函数</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        base.sayHi();</span><br><span class="line">        base.sayHello();<span class="comment">//无法访问到，且因为是匿名内部类无法向下造型访问</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//更常用的是直接创建匿名对象调用，一次使用</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Base</span>(<span class="string">&quot;Tom&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;jack&quot;</span> ;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHi</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="comment">//此处没有权限直接调用父类的name，与继承的语法关系相同</span></span><br><span class="line">                System.out.println(getname() + <span class="string">&quot;你好&quot;</span>);</span><br><span class="line">                System.out.println(name + <span class="string">&quot;你好&quot;</span>);</span><br><span class="line">                <span class="comment">//变量调用符合就近原则</span></span><br><span class="line">                <span class="built_in">this</span>.sayHello();</span><br><span class="line">                <span class="comment">//只能在匿名内部类内调用匿名类中添加的父类中本没有的新的方法</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.sayHi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="匿名内部类细节"><a href="#匿名内部类细节" class="headerlink" title="匿名内部类细节"></a>匿名内部类细节</h3><ul><li>匿名内部类即使一个类的定义，它本身也是一个对象</li><li>匿名内部类的语法中既有 <em>定义类的特征</em> 也有 <em>创建对象的特征</em></li><li>其他特点与局部内部类相同</li></ul><h3 id="匿名内部类实践"><a href="#匿名内部类实践" class="headerlink" title="匿名内部类实践"></a>匿名内部类实践</h3><ul><li><em><strong>匿名内部类当做实参直接传递</strong></em>,简洁高效<ul><li>因为匿名内部类本身也是一个对象，故可以作为参数传递给函数</li><li>例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//匿名对象方法，创建匿名内部类的匿名对象作为接口类的实参传递给函数</span></span><br><span class="line">    Cat.thisCatWantFly(<span class="keyword">new</span> <span class="title class_">Fly</span>()&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">iCanFly</span><span class="params">()</span>&#123;<span class="comment">//不能减小重写的接口方法的范围</span></span><br><span class="line">        <span class="comment">//接口方法只能是默认和public，故此处最好写上public</span></span><br><span class="line">            System.out.println(<span class="string">&quot;i am a cat , i can fly&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//传统方法，创建一个新的类FlyCat实现Fly接口，实例化后传参</span></span><br><span class="line">    <span class="type">FlyCat</span> <span class="variable">flyCat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FlyCat</span>();</span><br><span class="line">    Cat.thisCatWantFly(flyCat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Fly</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">iCanFly</span><span class="params">()</span>;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line"><span class="comment">//静态方法，参数类型为接口类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">thisCatWantFly</span><span class="params">(Fly cat)</span>&#123;</span><br><span class="line">    cat.iCanFly();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlyCat</span> <span class="keyword">implements</span> <span class="title class_">Fly</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">iCanFly</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;i am a cat , i can fly&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><ul><li><p>成员内部类是定义在外部类的成员位置，并且没有static修饰</p></li><li><p>特点</p><ul><li>可以直接访问外部类的所有成员，包含私有的</li><li>可以添加任意修饰符，因为它的地位就是一个成员</li><li>作用域和其他外部类成员一样，为整个类体</li><li>成员内部类访问外部类<ul><li>直接访问</li></ul></li><li>外部类访问成员内部类  <ul><li>先创建对象，再访问</li></ul></li><li>外部其他类访问成员内部类<ul><li><p>用外部类.内部类 方式直接创建对象</p><ul><li>例：Outer.Inner inner &#x3D; <strong>Outer.new Inner();</strong></li></ul></li><li><p>在外部类中编写方法返回一个成员内部类对象</p></li></ul></li><li>访问外部类成员规则与其他内部类相同</li></ul></li><li><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>  <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;num = &quot;</span> + num);</span><br><span class="line">            System.out.println(<span class="string">&quot;num = &quot;</span> + Outer.<span class="built_in">this</span>.num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useInner</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        inner.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><ul><li>静态内部类是定义在外部类的成员位置，并且有static修饰</li><li>特点<ul><li>可以直接访问外部类的所静态有成员，包含私有的，但不能直接访问非静态成员</li><li>可以添加任意修饰符，因为它的地位就是一个成员</li><li>作用域和其他外部类成员一样，为整个类体</li><li>外部类访问静态内部类<ul><li>要先创建对象再访问</li><li>Outer,Inner inner &#x3D; <strong>new Outer.Inner()</strong>;</li><li>因为是静态成员可以通过类名加 . 直接访问</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>  <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;num = &quot;</span> + num);</span><br><span class="line">            System.out.println(<span class="string">&quot;num = &quot;</span> + Outer.num);<span class="comment">//此处与普通成员内部类不同</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useStaticInner</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        inner.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Object函数"><a href="#Object函数" class="headerlink" title="Object函数"></a>Object函数</h1><h2 id="equals函数"><a href="#equals函数" class="headerlink" title="equals函数"></a>equals函数</h2><ul><li><p>equals()是Object类中的方法，只能判断引用类型变量所指对象与当前对象是否“相等”</p></li><li><p><strong>equals()在Object中函数默认是判断地址是否相等</strong>，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">    &#125;<span class="comment">//Object类中法equals()方法实现</span></span><br></pre></td></tr></table></figure></li><li><p>equals方法在非null对象引用上实现了等价关系；</p></li><li><p>equals函数公约 ：</p><ul><li>自反性 ：对于任何非空的参考值x ， x.equals(x)应该返回true 。 </li><li>对称性 ：对于任何非空引用值x和y ， x.equals(y)应该返回true当且仅当y.equals(x)返回true 。 </li><li>传递性 ：对于任何非空引用值x ， y和z ，如果x.equals(y)返回true，equals(z)返回true ，然后x.equals(z)应该返回true 。 </li><li>一致性 ：对于任何非null引用值x和y，如果不修改对象上的equals比较中使用的信息，则多次调用x.equals（y）会一致地返回true或一致地返回false。。 </li><li>对于任何非空的参考值x ， x.equals(null)应该返回false 。</li></ul></li><li><p>注意，无论何时覆盖该方法，通常需要覆盖hashCode方法，以便维护hashCode方法的公约，该方法规定相等的对象必须具有相等的哈希码。</p></li></ul><h3 id="重写equals-函数"><a href="#重写equals-函数" class="headerlink" title="重写equals()函数"></a>重写equals()函数</h3><ul><li><p>在声明定义一个类时，若直接调用类的equals()函数，使用的是继承自Object类的equals，作用是判断两个对象变量是否管理同一个对象。</p></li><li><p>若要想要比较字符串的内容而不是引用，应该重写一个属于该类的equals()函数</p></li><li><p>重写步骤</p><ul><li>1 判断传入的Obj是否与当前对象地址相同<ul><li>若是，则可直接返回true</li></ul></li><li>2 判断传入的obj的运行类型是否与当前对象类型相同<ul><li>若否，则可直接返回false</li></ul></li><li>3 <strong>将传入的obj向下造型，赋给一个当前对象类型的变量</strong><ul><li><strong>以获得访问该类特有属性的权限</strong></li></ul></li><li>4 比较属性内容是否相同<ul><li>全为真方可返回为true</li></ul></li></ul></li><li><p><strong>在Object子类中，如String，Integer，会重写该方法，用于判断内容是否相同</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == anObject) &#123;<span class="comment">//String中重写的equals方法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">anotherString</span> <span class="operator">=</span> (String)anObject;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> value.length;</span><br><span class="line">            <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">                <span class="type">char</span> v1[] = value;</span><br><span class="line">                <span class="type">char</span> v2[] = anotherString.value;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>学习： 多阅读源码</li></ul><h2 id="hashCode-函数"><a href="#hashCode-函数" class="headerlink" title="hashCode()函数"></a>hashCode()函数</h2><ul><li><p>简介 </p><ul><li>hashcode()的作用主要是提高具有哈希结构的容器的效率</li><li>两个引用如果指向同一个对象则哈希值一定相同</li><li>两个引用如果指向不同对象则哈希值最好要不同</li><li>哈希值是根据地址号经过特殊算法运算得来的</li><li>如果需要也会要重写hashcode()</li></ul></li><li><p>hashCode函数返回对象的哈希码值。 支持这种方法是为了散列表，如HashMap。</p></li><li><p>hashCode()的要求是：</p><ul><li><p>在Java应用程序的执行过程中，每当对同一对象多次调用hashCode方法时，只要不修改对象上的equals比较中使用的信息，hashCode方法就必须始终返回相同的整数。从一个应用程序的一次执行到同一应用程序的另一次执行，该整数不需要保持一致。 </p></li><li><p>如果根据equals（Object）方法，两个对象相等，那么对这两个对象中的每一个调用hashCode方法必须产生相同的整数结果。</p></li><li><p>如果根据equals（Object）方法，两个对象不相等，那么对这两个对象中的每一个调用hashCode方法必须产生不同的整数结果，这是不必要的。然而，程序员应该意识到，为不相等的对象生成不同的整数结果可能会提高哈希表的性能</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;<span class="comment">//String 的hashcode方法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">                h = <span class="number">31</span> * h + val[i];</span><br><span class="line">            &#125;</span><br><span class="line">            hash = h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>总结<ul><li><p>hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的；</p></li><li><p>如果两个对象相同，就是适用于equals(java.lang.Object) 方法，那么这两个对象的hashCode一定要相同；</p></li><li><p>如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致，否则就会违反上面提到的第2点；</p></li><li><p>两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中，如Hashtable，他们“存放在同一个篮子里”</p></li></ul></li></ul><h2 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h2><ul><li>基本介绍<ul><li>默认返回：全类名 + @ + 哈希值的十六进制，<blockquote><p>return getClass().getName() + “@” + Integer.toHexString(hashCode());  </p></blockquote></li><li>实际开发中通常希望对象的toString()方法返回一些特有属性信息等，故子类往往会重写toString()方法</li><li>重写toString方法，打印或拼接对象时，都会自动调用该对象的toString形式</li><li>当直接输出一个对象时，toString方法会被默认调用</li></ul></li></ul><h2 id="clone-函数"><a href="#clone-函数" class="headerlink" title="clone()函数"></a>clone()函数</h2><h3 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h3><ul><li>浅拷贝：默认情况下，clone()方法执行的是浅拷贝（shallow copy），它只会复制对象的字段引用，而不是字段的内容。这意味着如果对象包含其他对象的引用，那么复制的对象和原始对象将共享这些引用，可能导致意外的副作用。</li><li>隐式类型转换：clone()方法返回的是Object类型，需要进行显式的类型转换才能得到正确的类型。这可能导致类型转换错误和运行时异常。</li><li>不适用于不可变对象：对于不可变对象（如String），通常没有必要使用clone()方法，因为它们本身就是不可变的，可以直接共享。</li></ul><h3 id="clone-函数的重写"><a href="#clone-函数的重写" class="headerlink" title="clone()函数的重写"></a>clone()函数的重写</h3><h2 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h2><ul><li>当对象被回收时，系统自动调用该对象的finalize方法，子类可以重写该方法，根据需要做一些<strong>释放资源</strong>的操作等</li><li>何时被回收，当某个对象没有任何引用时，则jvm就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁前会调用finalize方法（类似于CPP中的析构函数）</li><li>垃圾回收机制的调用，是由系统来决定<ul><li>并不是对象不被引用后立刻就回收，而是系统有专门算法控制回收时机</li><li>可以通过System.gc()主动触发垃圾回收机制</li></ul></li><li>若未重写该方法，则会调用Object类中finalize方法，即默认处理</li></ul><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><ul><li>设计模式是静态方法和属性的经典使用</li><li>设计模式是在大量的实践中总结和理论化之后优选的代码结果，编程风格，以及解决问题的思考方式。设计模式就像是被经典的棋谱，免得我们再去摸索</li></ul><h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><ul><li>单例设计模式就是采取一定的方法保证在整个软件系统中，某个类只能存在一个实例对象，并且只提供一个取得其对象实例的方法</li><li>单例模式有两种方式<ul><li>饿汉式</li><li>懒汉式</li></ul></li></ul><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><ul><li>实现方式<ul><li>1 构造器私有化-&gt;防止类外将该类实例化</li><li>2 类的内部创建对象</li><li>3 向外提供一个公共的静态方法返回该实例对象<ul><li>饿汉式是指在类加载时就直接创建这个对象</li><li>故饿汉式可能创建了对象但是没有被使用</li></ul></li></ul></li><li>代码演示 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleClass</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleClass</span> <span class="params">()</span>&#123;&#125;;<span class="comment">//构造器私有化保证只有一个实例化对象   </span></span><br><span class="line">    <span class="comment">//在类内创建好改对象实例，为了能在静态方法中返回该实例对象，需要将其修饰为static</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SingleClass</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleClass</span>();</span><br><span class="line">    <span class="comment">//提供对外返回该实例的公共的static接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingleClass <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><ul><li>实现方式与饿汉式相近<ul><li>区别在于懒汉式是在用户调用该getInstance方法时才会创建实例对象</li><li>且再次调用getInstance方法时会返回之前创建的对象</li></ul></li><li>代码演示<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleClass</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleClass</span> <span class="params">()</span>&#123;&#125;;<span class="comment">//构造器私有化保证只有一个实例化对象   </span></span><br><span class="line">    <span class="comment">//在类内创建对象变量但并不实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleClass instance ;</span><br><span class="line">    <span class="comment">//提供对外返回该实例的公共的static接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingleClass <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)<span class="comment">//如果instance为null则创建实例对象，若部位null则返回之前已经创建好的对象</span></span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">SingleClass</span>();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>二者最大区别在于创建对象的时机不同，饿汉式是在类加载时就创建了对象实例，而懒汉式时在使用时才创建</li><li>饿汉式不存在线程安全为题，懒汉式存在线程安全问题</li><li>饿汉式存在资源浪费的可能。</li><li>在javaSE的标准类中，java.lang.Runtime就是经典的单例模式</li></ul><h2 id="模板设计模式"><a href="#模板设计模式" class="headerlink" title="模板设计模式"></a>模板设计模式</h2><p>例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Template&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doJob</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calculateTime</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        dojob();<span class="comment">//在父类模板中调用抽象方法，子类调用该方法会动态绑定调用自己重写的doJob()</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Subclass1 <span class="keyword">extends</span> <span class="title class_">Template</span>&#123;</span><br><span class="line">    <span class="meta">@override</span><span class="comment">//重写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doJob</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="comment">//执行任务代码，例如计算1加到一百万</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;java-面向对象基础&lt;/p&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;类和对象&quot;&gt;&lt;a href=&quot;#类和对象&quot; class=&quot;headerlink&quot; title=&quot;类和对象&quot;&gt;&lt;/a&gt;类和对象&lt;/h1&gt;&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="java" scheme="https://pengzhanyi.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>个人blog建设</title>
    <link href="https://pengzhanyi.github.io/2023/09/17/%E4%B8%AA%E4%BA%BAblog%E5%BB%BA%E8%AE%BE/"/>
    <id>https://pengzhanyi.github.io/2023/09/17/%E4%B8%AA%E4%BA%BAblog%E5%BB%BA%E8%AE%BE/</id>
    <published>2023-09-17T12:19:01.000Z</published>
    <updated>2023-11-20T13:13:27.441Z</updated>
    
    <content type="html"><![CDATA[<h1 id="记录关于在Github的Pages上用hexo的模板建设个人网站过程中用到的教程和走的一些坑（windows）"><a href="#记录关于在Github的Pages上用hexo的模板建设个人网站过程中用到的教程和走的一些坑（windows）" class="headerlink" title="记录关于在Github的Pages上用hexo的模板建设个人网站过程中用到的教程和走的一些坑（windows）"></a>记录关于在Github的Pages上用hexo的模板建设个人网站过程中用到的教程和走的一些坑（windows）</h1><ul><li><p>1 安装配置Node.js,<a href="https://blog.csdn.net/weixin_52799373/article/details/123840137">教程</a></p></li><li><p>2 <a href="https://zhuanlan.zhihu.com/p/392994381">安装Git ，并生成SSH密钥</a></p></li><li><p>3 下载hexo，（注意必须在管理员权限下的gitbash或powershell中下载）</p></li><li><p>4 <a href="https://zhuanlan.zhihu.com/p/78467553">部署网站</a></p></li><li><p>5 下载并应用butterfly主题时的<a href="https://zhuanlan.zhihu.com/p/137946156">坑</a></p></li></ul><p>补充</p><ul><li><p>6 <a href="https://hexo.io/zh-cn/docs/configuration.html">hexo官方文档</a></p><ul><li>hexo 命令要命令行在blog文件位置才有效 </li><li>hexo new “name’      &#x2F;&#x2F;新建文章</li><li>hexo new page “name” &#x2F;&#x2F;新建页面</li><li>hexo clean &#x2F;&#x2F;清除缓存文件</li><li>hexo g   &#x2F;&#x2F;生成页面</li><li>hexo s  &#x2F;&#x2F;启动预览</li><li>hexo d  &#x2F;&#x2F;部署到Github</li></ul></li><li><p><a href="https://butterfly.js.org/">Butterfly主题官方文档</a></p></li></ul><p>补充1：</p><ul><li>Markdown代码块关闭标签<ul><li>在Markdown文件中插入代码块时，在代码块结束时切记不要在 &#96;&#96;&#96; 后加空格，否则该标签未关闭。关闭则直接回车换两行即可。该问题在编译器里是看不出异常的，编译器里预览效果都是正常的包括直接用浏览器预览也是正常的，但实际并不是这样的，当你生成hexo博客后就会发现异常。痛苦啊~~~</li></ul></li><li>博客中插入图片，看了很多教程，再次深刻体会到了为什么不要多用百度和CSDN，话说发现一个国内看起来很老的博客网站，博客园，感觉还不错，这次也是在这上面找到的<a href="https://www.cnblogs.com/hugochen1024/p/12570656.html">解决方法</a>，不过很烦的就是，要是想让图片在网站上显示，在Typora预览的时候就看不到图片，虽然在前面图片路径加俩点就行，但是不能同一格式就很烦，感觉部署这个还是太麻烦了，以后会考虑语雀~</li><li><a href="https://www.cnblogs.com/xiaohi/p/15907083.html">Typora破解</a><ul><li>typora 中可以添加显示一些表情：💯 <a href="https://www.emojiall.com/zh-hans/all-emojis">表情网站</a>  ,在typora中 英文字符冒号后加英文单词可以输出对应表情</li></ul></li></ul><p> 补充2： </p><ul><li><p>reveal-md ,看佬用这个做到PPT太优雅了，遂想学习，可惜没弄明白（——.—）</p></li><li><p><a href="https://github.com/webpro/reveal-md">reveal-md 地址</a>,东西真的少</p></li><li><p>佬的讲解的<a href="https://www.bilibili.com/video/BV1pu4y1j7kA/?spm_id_from=333.788.top_right_bar_window_history.content.click">视频</a></p></li><li><p>佬的Github    <a href="https://github.com/TonyCrane/slide-template">reveal-md的模板</a> ， 在这里slide&#x2F;src中 有slides.md 和 custom.css</p></li><li><p>没搞懂，但最终在自己电脑上弄出来那种效果（虽然不知道为什么—）：</p><ul><li><p>将佬的 src目录下的 custom.css拷贝到C 盘主目录下</p><ul><li>或者直接把整个src目录文件拷贝到C盘下，</li></ul></li><li><p>用佬给的 slides.md 模板 ,与佬的main.dark.md模板主要不同就是渲染用的.css文件不同</p><ul><li>佬的 markdown文件 主要配置（yml文件配置的写法）：  <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Slide</span> <span class="string">模板</span></span><br><span class="line"><span class="attr">separator:</span> <span class="string">&lt;!--s--&gt;</span>  <span class="comment">#横着翻页的分割线</span></span><br><span class="line"><span class="attr">verticalSeparator:</span> <span class="string">&lt;!--v--&gt;</span> <span class="comment">#竖着着翻页的分割线</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">simple</span></span><br><span class="line"><span class="attr">highlightTheme:</span> <span class="string">github</span></span><br><span class="line"><span class="attr">css:</span> <span class="string">custom.css</span> </span><br><span class="line"><span class="attr">revealOptions:</span> <span class="comment"># 用于reveal.js的本身配置</span></span><br><span class="line">    <span class="attr">transition:</span> <span class="string">&#x27;slide&#x27;</span></span><br><span class="line">    <span class="attr">transitionSpeed:</span> <span class="string">fast</span></span><br><span class="line">    <span class="attr">center:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">slideNumber:</span> <span class="string">&quot;c/t&quot;</span></span><br><span class="line">    <span class="attr">width:</span> <span class="number">1000</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></li><li>这里 custom.css 表示在当前命令行目录下寻找custom.css文件，故如果.css文件在C盘下，就要在C盘打开命令行 ，这里是相对地址,但是我用绝对地址试了下好像不行，，，</li><li>故如果拷贝了整个src文件到C盘下，就要将这里的的css文件地址改为 &#x2F;src&#x2F;custom.css ,在C盘中命令行运行。</li></ul></li><li><p>运行命令示例： reveal-md “C:\Users\Lenovo\Desktop\slides.md” -w</p></li></ul></li><li><p>佬的custom.css 文件：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> url(<span class="attribute">https</span>://fonts.googleapis.com/css2?family=<span class="attribute">Ubuntu</span>:wght@<span class="number">400</span>;<span class="number">600</span>&amp;family=Source+<span class="selector-tag">Code</span>+Pro&amp;family=JetBrains+Mono:ital,wght@<span class="number">0</span>,<span class="number">300</span>;<span class="number">0</span>,<span class="number">400</span>;<span class="number">0</span>,<span class="number">600</span>;<span class="number">0</span>,<span class="number">700</span>;<span class="number">1</span>,<span class="number">400</span>;<span class="number">1</span>,<span class="number">700</span>);</span><br><span class="line"><span class="keyword">@import</span> url(<span class="attribute">https</span>://gcore.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@<span class="number">1.1</span>.<span class="number">0</span>/style.css);</span><br><span class="line"></span><br><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attr">--r-main-font</span>: <span class="string">&quot;JetBrains Mono&quot;</span>, <span class="string">&quot;LXGW WenKai Screen&quot;</span>, sans-serif;</span><br><span class="line">  <span class="attr">--r-heading-font</span>: <span class="string">&quot;JetBrains Mono&quot;</span>, <span class="string">&quot;LXGW WenKai Screen&quot;</span>, sans-serif;</span><br><span class="line">  <span class="attr">--r-code-font</span>: <span class="string">&quot;JetBrains Mono&quot;</span>, <span class="string">&quot;LXGW WenKai Screen&quot;</span>, sans-serif;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.reveal</span> <span class="selector-class">.slide-number</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">26px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, .<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.reveal</span> <span class="selector-class">.slides</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1.5px</span> <span class="number">#ddd</span> solid;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">7px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: left;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">300</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.reveal</span> <span class="selector-tag">section</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.reveal</span> <span class="selector-tag">p</span>, <span class="selector-class">.reveal</span> <span class="selector-tag">li</span>, <span class="selector-class">.reveal</span> center &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.reveal</span> <span class="selector-tag">h1</span>, <span class="selector-class">.reveal</span> <span class="selector-tag">h2</span>, <span class="selector-class">.reveal</span> <span class="selector-tag">h3</span>, <span class="selector-class">.reveal</span> <span class="selector-tag">h4</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">700</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.reveal</span> <span class="selector-tag">p</span>, <span class="selector-class">.reveal</span> <span class="selector-tag">h1</span>, <span class="selector-class">.reveal</span> <span class="selector-tag">h2</span>, <span class="selector-class">.reveal</span> <span class="selector-tag">h3</span>, <span class="selector-class">.reveal</span> <span class="selector-tag">h4</span>, <span class="selector-class">.reveal</span> <span class="selector-tag">h5</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>:  <span class="number">0</span> <span class="number">25px</span> <span class="number">0</span> <span class="number">25px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.reveal</span> pre &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">3mm</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.reveal</span> pre <span class="selector-tag">code</span> &#123;</span><br><span class="line">  <span class="attribute">max-height</span>: none;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">3mm</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">28px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.reveal</span> pre <span class="selector-tag">code</span> <span class="selector-tag">table</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: inherit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.reveal</span> <span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1.5em</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.reveal</span> <span class="selector-tag">ol</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.reveal</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.reveal</span> <span class="selector-tag">li</span> + <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.reveal</span> <span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.reveal</span> <span class="selector-tag">h1</span>,</span><br><span class="line"><span class="selector-class">.reveal</span> <span class="selector-tag">h2</span>,</span><br><span class="line"><span class="selector-class">.reveal</span> <span class="selector-tag">h3</span>,</span><br><span class="line"><span class="selector-class">.reveal</span> <span class="selector-tag">h4</span>,</span><br><span class="line"><span class="selector-class">.reveal</span> <span class="selector-tag">h5</span>,</span><br><span class="line"><span class="selector-class">.reveal</span> <span class="selector-tag">h6</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: left;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#222</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">400</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.2</span>;</span><br><span class="line">  <span class="attribute">letter-spacing</span>: normal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.reveal</span> <span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">10</span> <span class="number">0</span> <span class="number">10</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.reveal</span> <span class="selector-class">.middle</span> <span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.reveal</span> <span class="selector-tag">h2</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">48px</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">2px</span> solid <span class="built_in">rgb</span>(<span class="number">0</span>, <span class="number">63</span>, <span class="number">163</span>);</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.reveal</span> <span class="selector-tag">h3</span> &#123; <span class="attribute">font-size</span>: <span class="number">1.15em</span>; &#125;</span><br><span class="line"><span class="selector-class">.reveal</span> <span class="selector-tag">h4</span> &#123; <span class="attribute">font-size</span>: <span class="number">1.05em</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.reveal</span> <span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.reveal</span> <span class="selector-class">.middle</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">660px</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">section</span> <span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">margin-left</span>: auto;</span><br><span class="line">  <span class="attribute">margin-right</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.reveal</span> hr &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">10px</span> solid white;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.reveal</span> <span class="selector-class">.middle</span> hr &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">2px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">radial-gradient</span>(ellipse at center,<span class="built_in">rgba</span>(<span class="number">1</span>, <span class="number">14</span>, <span class="number">54</span>, <span class="number">0.324</span>) <span class="number">0</span>,<span class="built_in">hsla</span>(<span class="number">0</span>, <span class="number">0%</span>, <span class="number">100%</span>, <span class="number">0</span>) <span class="number">75%</span>);</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">40px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.reveal</span> <span class="selector-tag">table</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.three-line</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.three-line</span> &gt; <span class="selector-tag">table</span> &#123;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">1.5pt</span> solid;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1.5pt</span> solid;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">page-break-inside</span>: avoid;</span><br><span class="line">  <span class="attribute">display</span>: inline-table <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.three-line</span> &gt; <span class="selector-tag">table</span> &gt; <span class="selector-tag">tbody</span> &gt; <span class="selector-tag">tr</span> &gt; <span class="selector-tag">td</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">7px</span> <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.three-line</span> &gt; <span class="selector-tag">table</span> &gt; <span class="selector-tag">tbody</span> &gt; <span class="selector-tag">tr</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">7px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.three-line</span> &gt; <span class="selector-tag">table</span> &gt; <span class="selector-tag">thead</span> &#123;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">0.75pt</span> solid;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0.9em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.three-line</span> &gt; <span class="selector-tag">table</span> <span class="selector-tag">th</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">section</span> &gt; <span class="selector-tag">table</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1.5pt</span> solid;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">page-break-inside</span>: avoid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">section</span> &gt; <span class="selector-tag">table</span> &gt; <span class="selector-tag">tbody</span> &gt; <span class="selector-tag">tr</span> &gt; <span class="selector-tag">td</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">0.75pt</span> solid;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">7px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">section</span> &gt; <span class="selector-tag">table</span> &gt; <span class="selector-tag">tbody</span> &gt; <span class="selector-tag">tr</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">0.75pt</span> solid;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">7px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">section</span> &gt; <span class="selector-tag">table</span> &gt; <span class="selector-tag">thead</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">0.75pt</span> solid;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0.9em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">section</span> &gt; <span class="selector-tag">table</span> <span class="selector-tag">th</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">0.75px</span> solid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.reveal</span> <span class="selector-class">.mul-cols</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.reveal</span> <span class="selector-class">.mul-cols</span> <span class="selector-class">.col</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">html</span><span class="selector-class">.print-pdf</span> <span class="selector-class">.reveal</span> pre <span class="selector-tag">code</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="built_in">var</span>(--r-code-font) <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Modified from https://github.com/sivan/heti</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.reveal</span> heti-spacing &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.reveal</span> heti-spacing + <span class="selector-tag">sup</span>,</span><br><span class="line"><span class="selector-class">.reveal</span> heti-spacing + sub &#123;</span><br><span class="line">  <span class="attribute">margin-inline-start</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.reveal</span> <span class="selector-class">.heti-spacing</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0.5em</span>;</span><br><span class="line">  <span class="attribute">vertical-align</span>: top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.reveal</span> <span class="selector-class">.heti-spacing-start</span> &#123;</span><br><span class="line">  <span class="attribute">margin-inline-end</span>: <span class="number">0.25em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.reveal</span> <span class="selector-class">.heti-spacing-end</span> &#123;</span><br><span class="line">  <span class="attribute">margin-inline-start</span>: <span class="number">0.25em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.reveal</span> heti-adjacent &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.reveal</span> <span class="selector-class">.heti-adjacent-half</span> &#123;</span><br><span class="line">  <span class="attribute">margin-inline-end</span>: -<span class="number">0.5em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.reveal</span> <span class="selector-class">.heti-adjacent-quarter</span> &#123;</span><br><span class="line">  <span class="attribute">margin-inline-end</span>: -<span class="number">0.25em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.reveal</span> <span class="selector-class">.slide-number</span> &#123;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">8px</span>;</span><br><span class="line">  <span class="attribute">right</span>: unset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.MathJax</span> <span class="selector-class">.math</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">80%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.katex</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>佬的完整 slides.md文件 ，其中包含一些基础的语法示例</p></li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Slide 模板</span><br><span class="line">separator: &lt;!--s--&gt;</span><br><span class="line">verticalSeparator: &lt;!--v--&gt;</span><br><span class="line">theme: simple</span><br><span class="line">highlightTheme: github</span><br><span class="line">css: custom.css </span><br><span class="line"><span class="code">    transition: &#x27;slide&#x27;</span></span><br><span class="line"><span class="code">    transitionSpeed: fast</span></span><br><span class="line"><span class="code">    center: false</span></span><br><span class="line"><span class="code">    slideNumber: &quot;c/t&quot;</span></span><br><span class="line"><span class="code">    width: 1000</span></span><br><span class="line"><span class="code">---</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle center&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width: 100%&quot;</span>&gt;</span></span></span><br><span class="line"><span class="section"># Slide 模版</span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span></span><br><span class="line"></span><br><span class="line">By [<span class="string">@TonyCrane</span>](<span class="link">https://github.com/TonyCrane</span>)</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!--s--&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle center&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width: 100%&quot;</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="section"># Part.1 大标题</span></span><br><span class="line"></span><br><span class="line">一些 markdown</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!--v--&gt;</span><br><span class="line"></span><br><span class="line"><span class="section">## 标题</span></span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; test</span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="code">```rust [1|2-3]</span></span><br><span class="line"><span class="code">fn main() &#123;</span></span><br><span class="line"><span class="code">    println!(&quot;Hello World!&quot;)</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">```</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> list 1</span><br><span class="line"><span class="bullet">-</span> list 2</span><br><span class="line"><span class="bullet">    -</span> list 2.1</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 有序</span><br><span class="line"></span><br><span class="line">&lt;!--v--&gt;</span><br><span class="line"></span><br><span class="line"><span class="section">## 标题</span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;three-line&quot;</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">|表头 a|表头 b|表头 c|</span><br><span class="line">|:--:|:--:|:--:|</span><br><span class="line">|这是一个|一些内容|...|</span><br><span class="line">|三线表|...|...|</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">|表头 a|表头 b|表头 c|</span><br><span class="line">|:--:|:--:|:--:|</span><br><span class="line">|这是一个|一些内容|...|</span><br><span class="line">|普通表格|...|...|</span><br><span class="line"></span><br><span class="line">&lt;!--s--&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle center&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width: 100%&quot;</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="section"># Part.2 布局</span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!--v--&gt;</span><br><span class="line"></span><br><span class="line"><span class="section">## 多列布局</span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mul-cols&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">第一列</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> list</span><br><span class="line"><span class="bullet">-</span> list</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">第二列</span><br><span class="line"></span><br><span class="line"><span class="code">```python</span></span><br><span class="line"><span class="code">class MyClass:</span></span><br><span class="line"><span class="code">    def __init__(self, ...):</span></span><br><span class="line"><span class="code">        ...</span></span><br><span class="line"><span class="code">    def method(self, ...):</span></span><br><span class="line"><span class="code">        ...</span></span><br><span class="line"><span class="code">```</span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mul-cols&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">第一列</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> list</span><br><span class="line"><span class="bullet">-</span> list</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">第二列</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> list </span><br><span class="line"><span class="bullet">2.</span> list </span><br><span class="line"><span class="bullet">    -</span> list</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">第三列</span><br><span class="line"></span><br><span class="line"><span class="code">```python</span></span><br><span class="line"><span class="code">class MyClass:</span></span><br><span class="line"><span class="code">    def __init__(self, ...):</span></span><br><span class="line"><span class="code">        ...</span></span><br><span class="line"><span class="code">    def method(self, ...):</span></span><br><span class="line"><span class="code">        ...</span></span><br><span class="line"><span class="code">```</span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li><p>用法：和 reveal-js 的快捷键一致，在页面中按下 <code>?</code> 可以查看所有快捷键。常用的：</p><ul><li>N &#x2F; SPACE：下一页</li><li>P &#x2F; Shift SPACE：上一页</li><li>← &#x2F; H：翻到左边页面</li><li>→ &#x2F; L：翻到右边页面</li><li>↑ &#x2F; K：翻到上边页面</li><li>↓ &#x2F; J：翻到下边页面</li><li>B &#x2F; .：暂停（黑屏）</li><li>F：全屏</li><li>ESC &#x2F; O：显示概览</li><li>S：打开演讲者窗口</li><li>生成 pdf 版：在 url 后面加上 <code>?print-pdf</code> 使用浏览器打印</li></ul></li><li><p>插入图片： 当图片文件和当前Markdown文件在同一目录下时： <img src="/head_sculpture.jpg" alt="img"></p></li></ul><p>或   <img src="/head_sculpture.jpg" alt="img" style="zoom:10%;" /> ，可调整图片大小   </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;记录关于在Github的Pages上用hexo的模板建设个人网站过程中用到的教程和走的一些坑（windows）&quot;&gt;&lt;a href=&quot;#记录关于在Github的Pages上用hexo的模板建设个人网站过程中用到的教程和走的一些坑（windows）&quot; class=&quot;h</summary>
      
    
    
    
    
    <category term="blog bulid" scheme="https://pengzhanyi.github.io/tags/blog-bulid/"/>
    
  </entry>
  
  <entry>
    <title>java基础语法</title>
    <link href="https://pengzhanyi.github.io/2023/09/17/java-base/"/>
    <id>https://pengzhanyi.github.io/2023/09/17/java-base/</id>
    <published>2023-09-17T11:25:52.000Z</published>
    <updated>2023-10-13T10:50:58.307Z</updated>
    
    <content type="html"><![CDATA[<ul><li><h2 id="JAVA基础1"><a href="#JAVA基础1" class="headerlink" title="JAVA基础1"></a>JAVA基础1</h2></li></ul><h1 id="一-java的重要特点"><a href="#一-java的重要特点" class="headerlink" title="一.java的重要特点"></a>一.java的重要特点</h1><ul><li>1.面向对象(oop)</li><li>2.健壮性。Java的强类型机制，异常处理，垃圾的自动回收是Java程序健壮性的重要保证。</li><li>3.跨平台可移植</li><li>4.解释性语言<blockquote><p>解释性语言如javascript,PHP。编译性语言：C&#x2F;Cpp<br>区别是：解释性语言编译后的代码不能直接被机器执行，需要解释器执行。编译性语言，编译后的代码，可以直接被机器执行。</p></blockquote></li></ul><h1 id="二-第一个java程序"><a href="#二-第一个java程序" class="headerlink" title="二.第一个java程序"></a>二.第一个java程序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">helloworld</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>java程序的生成<ul><li>javac test.java -&gt; 编译java文件生成test.class字节码文件</li><li>java test 本质就是把.class文件加载到jvm运行该文件</li></ul></li></ul><h1 id="三-java基本数据类型"><a href="#三-java基本数据类型" class="headerlink" title="三.java基本数据类型"></a>三.java基本数据类型</h1><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><ul><li>Java对于方法的局部变量，Java以编译时错误来保证变量在使用前都能得到恰当的初始化，而c是不会报错  <ul><li>但是Java对于<strong>方法内</strong>的单个变量<strong>不会赋予初始值</strong>，对于数组会赋予默认的值</li></ul></li></ul><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><ul><li>整数类型 <ul><li>byte</li><li>short</li><li>int <ul><li>二进制以0b开头</li><li>八进制以0开头</li><li>十六进制以0X开头</li></ul></li><li>long <blockquote><p>补充：位运算符<br>位运算符： &gt;&gt;，&lt;&lt;，&gt;&gt;&gt;是对数据的二进制进行左移右移操作<br>其中 &gt;&gt; 表示向右移动后以1补上空位<br> 而&gt;&gt;&gt;则表示以0补上空位</p></blockquote></li></ul></li></ul><h4 id="数据的类型转换"><a href="#数据的类型转换" class="headerlink" title="数据的类型转换"></a>数据的类型转换</h4><ul><li>整型,实型,字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算，转换从低级到高级</li><li>short类型和byte类型只要参与运算，结果就会被自动转化成int类型数据<blockquote><p>例：byte num &#x3D; 1 ;<br>  short num2 &#x3D;2 ;<br>  short sum &#x3D; num + num2 ;&#x2F;&#x2F;编译会报错</p></blockquote></li></ul><h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><ul><li>float<ul><li>float类型数据必须在数据后加f或F</li></ul></li><li>double</li></ul><h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><ul><li>java使用Unicode来表示字符，可以表示汉字在内的多种文字<blockquote><p>例 ： char a &#x3D; “\u0041”;  \u表示是Unicode编码,0041是指16进制数<br>     System.out.println(a);<br>     输出结果为：a</p></blockquote></li></ul><h2 id="boolean类："><a href="#boolean类：" class="headerlink" title="boolean类："></a>boolean类：</h2><ul><li>只有true和false两个值，且不能与int值作比较</li><li><u>boolean类型默认值为 false</u></li><li>布尔类型boolean占有一个字节，由于其本身所代码的特殊含义，<strong>boolean类型与其他基本类型不能进行类型的转换</strong>（既不能进行自动类型的提升，也不能强制类型转换）， 否则，将编译出错。</li></ul><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>每个引用占据32位的内存空间，其值指向对象实际所在的内存中的位置</p><h3 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h3><h4 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h4><ul><li>数组的创建  </li><li>java中用new创建的int数组有初始零值。</li><li>数组的有一固定属性length，为数组长度</li><li>java中的数组变量只是new出的一块连续地址的“管理者”，即只是获得该数组所在地址，而变量之间的赋值是管理权限的赋予，数组变量的比较是判断是否管理同一个数组。   <blockquote><p><strong>数组的赋值在默认情况下是引用传递，赋的值是地址，赋值方式为引用传递</strong></p></blockquote></li><li>复制数组只能将原数组每个元素逐一拷贝给目的数组,<strong>clone函数</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">System.out.println(array.length);</span><br><span class="line"><span class="type">int</span>[] array2 = array;</span><br><span class="line">array2[<span class="number">0</span>]=<span class="number">10</span>;</span><br><span class="line">System.out.println(array[<span class="number">0</span>],array2[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure></li></ul><h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><ul><li>数组的创建 ： int[][] array &#x3D; new int[3][5];<br>  (必须要给出第一个括号中的参数)</li><li>二维数组array.length 是指该二维数组有多少行，array[1].length表示有几列</li></ul><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><ul><li>String是一个类，<strong>String的变量是对象的管理者而非所有者</strong><ul><li>类似数组变量是数组的管理者而非所有者<ul><li>故字符串创建要用new创建一个String对象，用字符串变量来管理这个这个对象<ul><li>String s &#x3D; new String(“helloworld”);</li></ul></li><li>故字符串对象变量的赋值只是让两个字符串变量管理同一个字符串对象</li></ul></li><li>String是不可变字符串<ul><li>指的是变量一旦被赋值，其值不能被改变，如果想改变变量的值，只能将变量引向另一个字符串</li></ul></li></ul></li></ul><h4 id="equals-与-的区别"><a href="#equals-与-的区别" class="headerlink" title="equals 与 &#x3D;&#x3D; 的区别"></a>equals 与 &#x3D;&#x3D; 的区别</h4><ul><li><p>&#x3D;&#x3D; 是比较运算符，而equals是Object类的方法，Java类都可以使用该方法</p></li><li><p>&#x3D;&#x3D; 既可以比较基本类型也可以比较引用类型，但equals()是Object类中的方法，只能判断引用类型</p></li><li><p>变量的 “&#x3D;&#x3D;”引用类型比较，只是判断两个变量是否管理同一个对象（字符串），即判断地址是否相同</p></li><li><p><strong>比较两个String内容是否相等要用String变量的equals()函数比较</strong></p></li><li><p>下面这段代码输出为true是因为Java中有一个字符串常量池（String Pool）的概念，它使得相同的字符串字面量在内存中只会被存储一次，而多个引用都指向同一个字符串对象。在你的代码中，a和b都被初始化为字符串字面量 “hello”，因为它们的内容相同，所以它们实际上引用了同一个字符串对象，而不是创建了两个相同内容的不同字符串对象。因此，使用”&#x3D;&#x3D;”运算符比较它们会返回true，因为它们引用的是同一个对象。这是字符串常量池的优化机制，它可以减少内存使用，并提高字符串比较的效率。如果你想要比较字符串的内容而不是引用，应该使用equals()方法，而不是”&#x3D;&#x3D;运算符  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="type">String</span> <span class="variable">string1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">string2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">System.out.println(string1 == string2);</span><br></pre></td></tr></table></figure></li><li><p>字符串连接</p><ul><li>用 + 可以连接两个字符串<ul><li>“hello”+”world”&#x3D;”helloworld”</li></ul></li><li>当这个 + 的一边是字符串一边不是时，会将另一边表达为字符串然后做连接<ul><li>“age” + 1 + 2 -&gt; “age12”</li></ul></li></ul></li><li><p>字符串输入</p><ul><li>in.next()读入一个单词，单词的标志是空格<ul><li>空格包括空格，tab和换行</li></ul></li><li>in.nextLine() 读入一整行<blockquote><p>访问字符串里的字符<br>用s.charAT(index)函数，返回该字符串上下标为index的字符，不可用FOR-EACH循环来遍历数组变量</p></blockquote></li></ul></li><li><p>当需要对一个字符串做复杂操作时一般用<strong>StringBuffer</strong>类型，<strong>String类型无法对字符串做修改,是不可变的！！！ String类型只是字符串常量</strong></p><ul><li>StringBuffer.append()</li><li>**StringBuffer.toString()**将该类型转化为String类型;</li></ul></li></ul><h1 id="四-java基本语法"><a href="#四-java基本语法" class="headerlink" title="四.java基本语法"></a>四.java基本语法</h1><h2 id="数据的输入："><a href="#数据的输入：" class="headerlink" title="数据的输入："></a>数据的输入：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, World!&quot;</span>);<span class="comment">//println是指在输出结束后加上换行符</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span> (System.in);<span class="comment">//声明了名为in的数据输入扫描仪（Scanner）</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> in.nextInt();<span class="comment">//将输入的下一个int值赋给value变量</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">amount</span> <span class="operator">=</span> <span class="number">0</span>；<span class="comment">//常量定义</span></span><br><span class="line">        System.out.println(<span class="string">&quot;20+&quot;</span> + value + <span class="string">&quot;=&quot;</span> + (<span class="number">20</span>+ + value) );</span><br><span class="line">in.close();<span class="comment">//结束数据流，释放内存</span></span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure><ul><li>也可以Integer i &#x3D; Integer.parseInt(in.next());输入数据<ul><li>in.next()接收的字符串类型</li><li>parseInt()是Integer类型的函数，将字符串识别转化为int<ul><li>与之相对的有<strong>toString()函数</strong>，将其他类型识别为转化为字符串类型</li></ul></li></ul></li></ul><h2 id="循环："><a href="#循环：" class="headerlink" title="循环："></a>循环：</h2><ul><li>while循环</li><li>do-while循环</li><li>for循环</li></ul><h3 id="FOR-EACH循环"><a href="#FOR-EACH循环" class="headerlink" title="FOR-EACH循环"></a>FOR-EACH循环</h3><pre><code>形式：for(&lt;类型&gt; &lt;变量名&gt; ，&lt;数组&gt;)&#123;&#125;</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="type">int</span> k : array)</span><br><span class="line"><span class="comment">/*解读：对于array数组里的每一个元素，循环的一轮依次拿出作为k的值,  </span></span><br><span class="line"><span class="comment">适合用于遍历数组的情况*/</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( k == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;find!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="包裹类型"><a href="#包裹类型" class="headerlink" title="包裹类型"></a>包裹类型</h2><ul><li>每种基础类型都有相对应的包裹类型</li></ul><table><thead><tr><th>基础类型</th><th>包裹类型</th></tr></thead><tbody><tr><td>boolean</td><td>Boolean</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>double</td><td>Double</td></tr></tbody></table><ul><li><p>包装类与基本数据类型比较</p></li><li><p>包裹类型变量有一些特殊的函数   </p><ul><li>每个包裹类型都有toString方法，用于将该类型变量转化为字符串</li><li>每个包裹类型也有自己的parse方法，用于将字符串识别转化为该类型的变量<blockquote><p>例 ： Integer a &#x3D; 1;<br>System.out.println(a.MAX_VALUE);<br>输出结果为：2147483647<br>类似的还有Interger.parseInt( string, 10)，该函数将字符串作为有符号的十进制整数进行解析</p></blockquote></li></ul></li></ul><h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><ul><li>abs 求绝对值</li><li>pow 求幂</li><li>random 提供一个0-1的随机数<ul><li>random.nextInt(bound) 提供一个零到bound的随机int类型数据，包括零但不包括bound<ul><li>一般可以用random.nextInt(array.length)作为下标来做到随机访问数组中的成员</li></ul></li></ul></li><li>round 做四舍五入</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li>不能在一个块内定义块外定义过的变量。（与C语言会隐藏块外同名变量机制不同）</li></ul><h2 id="可变参数方法"><a href="#可变参数方法" class="headerlink" title="可变参数方法"></a>可变参数方法</h2><ul><li><img src="/images/java_base1_01.png" alt="img"></li></ul><h2 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h2><h3 id="IDEA快捷键"><a href="#IDEA快捷键" class="headerlink" title="IDEA快捷键"></a>IDEA快捷键</h3><ul><li>删除当前行， 自己配Ctrl + d</li><li>补全代码 alt + &#x2F;</li><li>导入该行所需的类 Alt + Enter</li><li>生成构造器等 <strong>alt + insert</strong></li><li><strong>查看一个类的层级关系 Ctrl + H</strong></li><li>生成当前类的继承关系图Ctrl + Alt + U</li><li>查看当前类的所有方法和属性 Ctrl + F12</li><li>将光标放在一个方法上，Ctrl + B可以选择定位到哪个类的方法</li><li>.var 可自动分配变量名</li><li>Ctrl + b 跳转到该函数实现处</li></ul><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><ul><li>sout模板快捷键</li><li>fori模板快捷键</li><li>file - 设置- 编辑器-实时模板 里查看java的模板，可以自定义模板增加开发效率</li></ul><h2 id="package"><a href="#package" class="headerlink" title="package"></a>package</h2><h3 id="包的基本语法"><a href="#包的基本语法" class="headerlink" title="包的基本语法"></a>包的基本语法</h3><ul><li>package 包名;</li></ul><h3 id="包的作用"><a href="#包的作用" class="headerlink" title="包的作用"></a>包的作用</h3><ul><li>包的本质就是创建不同的文件夹来保存管理类</li><li>包的名字里可以带有“.”,例如import java.util.Scanner;其中的.（包的名字中的.）实际上表达的就是文件系统中文件夹的层次，java正是同这样的手段来管理类，这就是java的package管理机制。</li><li>可用去区分相同名字的类</li><li><strong>若用到的类与当前所在文件不在一个package中则需要用import package名.类名  来引入这个类</strong>。</li></ul><h3 id="包的导入"><a href="#包的导入" class="headerlink" title="包的导入"></a>包的导入</h3><ul><li>语法： import + 完整包名<ul><li>例 ： import java.util.Scanner 只会引入Scanner</li></ul></li><li>import + 包名. + * <ul><li>引入该类下的所有的类（但不建议使用该方法，<strong>最好根据需求引用相应的类</strong>）</li></ul></li></ul><h3 id="常用包"><a href="#常用包" class="headerlink" title="常用包"></a>常用包</h3><ul><li>java.util&#x2F;&#x2F;系统提供的工具包，包括Scanner</li><li>java.lang &#x2F;&#x2F;lang是基本包，默认引入，不许要再引入</li><li>java.net &#x2F;&#x2F;网络包，做网络开发</li><li>java.awt &#x2F;&#x2F;做java界面开发，GUI</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>package的作用是声明当前类所在的包，需要放在类的最上面，一个类中最多只有一句package</li><li>import指令放在package指令下，在类定义前</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;h2 id=&quot;JAVA基础1&quot;&gt;&lt;a href=&quot;#JAVA基础1&quot; class=&quot;headerlink&quot; title=&quot;JAVA基础1&quot;&gt;&lt;/a&gt;JAVA基础1&lt;/h2&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;一-java的重要特点&quot;&gt;&lt;a href=&quot;#一</summary>
      
    
    
    
    
    <category term="java" scheme="https://pengzhanyi.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>hello blog test</title>
    <link href="https://pengzhanyi.github.io/2023/09/17/hello-blog-test/"/>
    <id>https://pengzhanyi.github.io/2023/09/17/hello-blog-test/</id>
    <published>2023-09-17T01:03:36.000Z</published>
    <updated>2023-09-17T12:41:07.232Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://pengzhanyi.github.io/2023/09/17/hello-world/"/>
    <id>https://pengzhanyi.github.io/2023/09/17/hello-world/</id>
    <published>2023-09-17T00:13:16.062Z</published>
    <updated>2023-09-17T00:13:16.062Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
