<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog | kaori</title>
  
  
  <link href="https://pengzhanyi.github.io/atom.xml" rel="self"/>
  
  <link href="https://pengzhanyi.github.io/"/>
  <updated>2023-09-24T10:12:29.556Z</updated>
  <id>https://pengzhanyi.github.io/</id>
  
  <author>
    <name>zhanyi peng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java基础- 基于面向对象的应用</title>
    <link href="https://pengzhanyi.github.io/2023/09/24/java-base3/"/>
    <id>https://pengzhanyi.github.io/2023/09/24/java-base3/</id>
    <published>2023-09-24T08:50:40.000Z</published>
    <updated>2023-09-24T10:12:29.556Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="特殊类"><a href="#特殊类" class="headerlink" title="特殊类"></a>特殊类</h1><h2 id="泛型容器类"><a href="#泛型容器类" class="headerlink" title="泛型容器类"></a>泛型容器类</h2><blockquote><p>例：ArrayList&lt;*Stirng*&gt; notes &#x3D; new ArrayList&lt;*String*&gt;;</p></blockquote><ul><li>容器有两个类型：<ul><li>容器的类型：例如ArrayList</li><li>元素的类型：例如String      <br></li></ul></li><li>ArrayList</li></ul><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><ul><li>定义在别的类的内部，函数内部的类<ul><li>内部类能直接访问外部的全部资源</li><li>外部是函数时，只能访问那个函数里final的变量</li></ul></li></ul><h2 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h2><ul><li>在new对象时给出类的定义形成了匿名类</li><li>匿名类可以继承某类，也可以实现某接口</li><li>Swing的消息机制广泛使用匿名类<ul><li>注入反转</li></ul></li></ul><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="异常捕捉机制"><a href="#异常捕捉机制" class="headerlink" title="异常捕捉机制"></a>异常捕捉机制</h2><p>-·</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;<span class="comment">/*可能产生异常的代码*/</span>&#125;</span><br><span class="line">    <span class="keyword">catch</span>(Typel id1)</span><br><span class="line">    &#123;<span class="comment">/*处理Typel异常的代码*/</span>&#125;</span><br><span class="line">    <span class="keyword">catch</span>(Type2 id1)</span><br><span class="line">    &#123;/处理Type2异常的代码*/&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h2 id="equals函数"><a href="#equals函数" class="headerlink" title="equals函数"></a>equals函数</h2><ul><li><p>equals()是Object类中的方法，只能判断引用类型变量所指对象</p></li><li><p><strong>equals()在Object中函数默认是判断地址是否相等</strong>，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">    &#125;<span class="comment">//Object类中法equals()方法实现</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>但<strong>在Object子类中，如String，Integer，会重写该方法，用于判断内容是否相同</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == anObject) &#123;<span class="comment">//Object类中法equals()方法实现</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">anotherString</span> <span class="operator">=</span> (String)anObject;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> value.length;</span><br><span class="line">            <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">                <span class="type">char</span> v1[] = value;</span><br><span class="line">                <span class="type">char</span> v2[] = anotherString.value;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="重写equals-函数"><a href="#重写equals-函数" class="headerlink" title="重写equals()函数"></a>重写equals()函数</h3><ul><li>在声明定义一个类时，若直接调用类的equals()函数，使用的是继承自Object类的equals，作用是判断两个对象变量是否管理同一个对象。</li><li>若要想要比较字符串的内容而不是引用，应该重写一个属于该类的equals()函数</li><li>重写步骤<ul><li>1 判断传入的Obj是否与当前对象地址相同<ul><li>若是，则可直接返回true</li></ul></li><li>2 判断传入的obj的运行类型是否与当前对象类型相同<ul><li>若否，则可直接返回false</li></ul></li><li>3 <strong>将传入的obj向下造型，赋给一个当前对象类型的变量</strong><ul><li><strong>以获得访问该类特有属性的权限</strong></li></ul></li><li>4 比较属性内容是否相同<ul><li>全为真方可返回为true</li></ul></li></ul></li><li>学习： 多阅读源码</li></ul><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">integer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">12</span>);<span class="comment">//若是将12换成1000，结果是否会有所不同</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">12</span>);</span><br><span class="line">System.out.println(integer1.equals(integer2));</span><br><span class="line"><span class="type">String</span> <span class="variable">string1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span> ;</span><br><span class="line"><span class="type">String</span> <span class="variable">string2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span> ;</span><br><span class="line">System.out.println(string1.equals(string2));</span><br><span class="line"><span class="type">String</span> <span class="variable">string3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>) ;</span><br><span class="line"><span class="type">String</span> <span class="variable">string4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>) ;</span><br><span class="line">System.out.println(string3.equals(string4));</span><br></pre></td></tr></table></figure><h2 id="hashcode-函数"><a href="#hashcode-函数" class="headerlink" title="hashcode()函数"></a>hashcode()函数</h2><ul><li>小结 <ul><li>hashcode()的作用主要是提高具有哈希结构的容器的效率</li><li>两个引用如果指向同一个对象则哈希值一定相同</li><li>两个引用如果指向不同对象则哈希值一定不同</li><li>哈希值是根据地址号经过特殊算法运算得来的</li><li>如果需要也会要重写hashcode()</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;<span class="comment">//String 的hashcode方法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">                h = <span class="number">31</span> * h + val[i];</span><br><span class="line">            &#125;</span><br><span class="line">            hash = h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h2><ul><li>基本介绍<ul><li>默认返回：全类名 + @ + 哈希值的十六进制，<blockquote><p>return getClass().getName() + “@” + Integer.toHexString(hashCode());  </p></blockquote></li><li>实际开发中通常希望对象的toString()方法返回一些特有属性信息等，故子类往往会重写toString()方法</li><li>重写toString方法，打印或拼接对象时，都会自动调用该对象的toString形式</li><li>当直接输出一个对象时，toString方法会被默认调用</li></ul></li></ul><h2 id="clone-函数"><a href="#clone-函数" class="headerlink" title="clone()函数"></a>clone()函数</h2><h3 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h3><ul><li>浅拷贝：默认情况下，clone()方法执行的是浅拷贝（shallow copy），它只会复制对象的字段引用，而不是字段的内容。这意味着如果对象包含其他对象的引用，那么复制的对象和原始对象将共享这些引用，可能导致意外的副作用。</li><li>隐式类型转换：clone()方法返回的是Object类型，需要进行显式的类型转换才能得到正确的类型。这可能导致类型转换错误和运行时异常。</li><li>不适用于不可变对象：对于不可变对象（如String），通常没有必要使用clone()方法，因为它们本身就是不可变的，可以直接共享。</li></ul><h3 id="clone-函数的重写"><a href="#clone-函数的重写" class="headerlink" title="clone()函数的重写"></a>clone()函数的重写</h3><h2 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h2><ul><li>当对象被回收时，系统自动调用该对象的finalize方法，子类可以重写该方法，根据需要做一些<strong>释放资源</strong>的操作等</li><li>何时被回收，当某个对象没有任何引用时，则jvm就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁前会调用finalize方法（类似于CPP中的析构函数）</li><li>垃圾回收机制的调用，是由系统来决定<ul><li>并不是对象不被引用后立刻就回收，而是系统有专门算法控制回收时机</li><li>可以通过System.gc()主动触发垃圾回收机制</li></ul></li><li>若未重写该方法，则会调用Object类中finalize方法，即默认处理</li></ul><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><ul><li>设计模式是静态方法和属性的经典使用</li><li>设计模式是在大量的实践中总结和理论化之后优选的代码结果，编程风格，以及解决问题的思考方式。设计模式就像是被经典的棋谱，免得我们再去摸索</li></ul><h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><ul><li>单例设计模式就是采取一定的方法保证在整个软件系统中，某个类只能存在一个实例对象，并且只提供一个取得其对象实例的方法</li><li>单例模式有两种方式<ul><li>饿汉式</li><li>懒汉式</li></ul></li></ul><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><ul><li>实现方式<ul><li>1 构造器私有化-&gt;防止类外将该类实例化</li><li>2 类的内部创建对象</li><li>3 向外提供一个公共的静态方法返回该实例对象<ul><li>饿汉式是指在类加载时就直接创建这个对象</li><li>故饿汉式可能创建了对象但是没有被使用</li></ul></li></ul></li><li>代码演示 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleClass</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleClass</span> <span class="params">()</span>&#123;&#125;;<span class="comment">//构造器私有化保证只有一个实例化对象   </span></span><br><span class="line">    <span class="comment">//在类内创建好改对象实例，为了能在静态方法中返回该实例对象，需要将其修饰为static</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SingleClass</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleClass</span>();</span><br><span class="line">    <span class="comment">//提供对外返回该实例的公共的static接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingleClass <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><ul><li>实现方式与饿汉式相近<ul><li>区别在于懒汉式是在用户调用该getInstance方法时才会创建实例对象</li><li>且再次调用getInstance方法时会返回之前创建的对象</li></ul></li><li>代码演示<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleClass</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleClass</span> <span class="params">()</span>&#123;&#125;;<span class="comment">//构造器私有化保证只有一个实例化对象   </span></span><br><span class="line">    <span class="comment">//在类内创建对象变量但并不实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleClass instance ;</span><br><span class="line">    <span class="comment">//提供对外返回该实例的公共的static接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingleClass <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)<span class="comment">//如果instance为null则创建实例对象，若部位null则返回之前已经创建好的对象</span></span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">SingleClass</span>();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>二者最大区别在于创建对象的时机不同，饿汉式是在类加载时就创建了对象实例，而懒汉式时在使用时才创建</li><li>饿汉式不存在线程安全为题，懒汉式存在线程安全问题</li><li>饿汉式存在资源浪费的可能。</li><li>在javaSE的标准类中，java.lang.Runtime就是经典的单例模式</li></ul><h2 id="模板设计模式"><a href="#模板设计模式" class="headerlink" title="模板设计模式"></a>模板设计模式</h2><p>例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Template&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doJob</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calculateTime</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        dojob();<span class="comment">//在父类模板中调用抽象方法，子类调用该方法会动态绑定调用自己重写的doJob()</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Subclass1 <span class="keyword">extends</span> <span class="title class_">Template</span>&#123;</span><br><span class="line">    <span class="meta">@override</span><span class="comment">//重写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doJob</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="comment">//执行任务代码，例如计算1加到一百万</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;特殊类&quot;&gt;&lt;a href=&quot;#特殊类&quot; class=&quot;headerlink&quot; title=&quot;特殊类&quot;&gt;&lt;/a&gt;特殊类&lt;/h1&gt;&lt;h2 id=&quot;泛型容器类&quot;&gt;&lt;a href=&quot;#泛型容器类&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    
    <category term="java" scheme="https://pengzhanyi.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java基础——面向对象基础</title>
    <link href="https://pengzhanyi.github.io/2023/09/19/java_base2/"/>
    <id>https://pengzhanyi.github.io/2023/09/19/java_base2/</id>
    <published>2023-09-19T13:37:20.000Z</published>
    <updated>2023-09-25T13:31:46.762Z</updated>
    
    <content type="html"><![CDATA[<p>java-面向对象基础</p><h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2><ul><li>类是规范，类是定义了这个类所有对象的属性和操作，可以根据类的定义来创建对象</li></ul><h3 id="类的基本内容"><a href="#类的基本内容" class="headerlink" title="类的基本内容"></a>类的基本内容</h3><ul><li>成员变量</li><li>成员函数</li><li>代码块</li></ul><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><ul><li><p>类定义了对象所具有的变量，这些变量就是成员变量（属性）    </p><ul><li>属性定义： 访问修饰符 + 属性类型 + 属性名<ul><li>类的成员变量一般设置为private属性</li></ul></li><li>成员变量的生存期是对象的生存期，作用域是类内部的成员函数</li><li>定义子啊函数内部的变量是本地变量，生存期也作用域都是函数内部</li></ul><blockquote><p>注意在类中成员变量有对象数组时，<strong>使用对象数组前先将其数组成员指向实例化化对象，因为创建的对象数组只是对象引用，对象数组中成员全是null，并无实例，使用时会发生Nonepointerexception</strong></p></blockquote></li></ul><h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><ul><li>成员函数是类对外提供操纵属性的接口  <ul><li>成员函数定义： <ul><li>public 返回数据类型 方法名 （参数表）{函数体}；</li></ul></li><li>可在成员函数内部直接调用自己的其他函数</li><li>在成员函数的外部要通过对象的名字+.来调用该函数</li><li>this是成员函数的一个特殊的固有的本地变量，它表达了调用这个函数的那个对象</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showprice</span><span class="params">(<span class="type">int</span> price)</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">this</span>.price = price;<span class="comment">//利用this来访问被本地变量覆盖的成员变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><ul><li><p>代码块又称为<strong>初始化块</strong>，属于类中的成员，类似于成员函数</p><ul><li>将逻辑语句封装在方法体中，通过{}包围起来，但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显示调用，而是加载类时，或创建对象时隐式调用。</li></ul></li><li><p>基本语法</p><ul><li><p>[修饰符]{<br>  代码块<br>  };</p></li><li><p>注意：</p><ul><li>修饰符可选，要写也只能写static</li><li>代码块分为静态代码块和普通代码块</li><li>逻辑语句可以为任何逻辑语句</li><li>;可以省略</li></ul></li></ul></li><li><p>作用</p><ul><li>相当于另外一种形式的构造器（对于构造器的补充机制），可以做初始化操作</li><li>若多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的复用性</li><li>当不管调用那哪个构造器创建对象都会先调用代码块中的内容<ul><li>代码块调用顺序先于构造器</li></ul></li></ul></li><li><p>注意事项和细节讨论</p><ul><li><p>static代码块也叫<strong>静态代码块</strong>，作用就是<strong>对类进行初始化</strong>，而且它<strong>在类的加载时执行</strong>，<strong>且只会执行一次</strong></p></li><li><p>如果是<strong>普通代码块</strong>，<strong>每创建一个对象就执行一次</strong>，与类加载无关。</p></li><li><p><strong>类什么时候加载</strong></p><ul><li>1 创建对象实例的时候</li><li>2 创建子类对象实例，父类 也会被加载</li><li>3 使用类的静态成员时（静态方法，静态属性）</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span><span class="comment">//例</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类静态代码块调用，父类加载&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类普通代码块调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subclass</span> <span class="keyword">extends</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类静态代码块调用，子类加载&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类普通代码块调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若是 new Subclass() 会输出什么,顺序是什么样的？</span></span><br></pre></td></tr></table></figure><h3 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h3><p> static 修饰符表示静态的，静止的<br><br></p><ul><li><p>类变量</p><ul><li>在类中定义的成员变量加上static关键字就成为类变量（静态变量）</li><li>类变量属于类，    <ul><li>可以通过类名.变量名直接访问</li><li>也可通过该类的实例对象.变量访问</li><li>或在类内的函数中直接用变量名（没有变量名覆盖的情况下）</li></ul></li><li>该类创造的所有对象都可以访问这个类变量，但是都是同一个，这个<strong>类变量不属于任何对象，它属于这个类</strong>，被该类的所有对象共享   <br></li></ul></li><li><p>类函数</p><ul><li>static修饰成员函数表示这个函数只属于这个类</li><li>类函数调用方法<ul><li>对象.函数名 </li><li>类名.函数名  </li><li>也可以在非静态方法中通过this指针来调用类函数和类变量</li></ul></li><li><strong>static函数只能调用static函数，只能访问static的成员变量</strong>，他们都可以通过类名访问，也可以通过对象访问</li><li>static方法中不能使用this关键字</li><li>不能通过static函数获得具体的对象内的信息</li><li>static变量只会在类进入到程序中的时候（程序装载）被初始化，与具体对象的初始化无关</li></ul></li><li><p>类方法和类变量使用场景</p><ul><li>当方法中不涉及任何和相关对象的成员，则可以将方法设计成静态方法，提高开发效率<ul><li>比如，工具类utils中的Math类，Arrays类等</li></ul></li><li>实际开发自己的工具类时，将一些通用的方法设计成静态方法，这样不需要创建对象就可以使用该方法，如打印数组，排序等，</li></ul></li><li><p>静态代码块</p><ul><li>用static修饰的代码块称为静态代码块</li><li>当类被加载时静态代码块会执行，由于类只加载一次，因此静态代码块只执行一次，在程序中通常会使用静态代码块来对类的成员静态变量进行初始化</li></ul></li><li><p>注意事项</p><ul><li>static关键字只能用于修饰成员变量，不能用于修饰局部变量</li><li>在一个静态方法中只能访问用static修饰的成员，因为非静态成员在为必须要创建对象后的实例化才能访问，而静态成员在被调用时可以不创建对象<ul><li><strong>静态方法只能调用静态成员</strong></li><li><strong>非静态方法可以访问所有成员</strong></li></ul></li></ul></li></ul><p>补充</p><blockquote><p>main方法语法分析<br>解释main方法的形式：<br> public static void main(String[] args){}<br>1.jvm需要调用类中的main方法，故该方法的访问权限必须是public<br>2.jvm在执行main方法时不必创建对象，所以该方法必须是static<br>3.该方法接受String类型的数组参数，该数组中保存执行java命令时传递给所运行类的参数<br>4.java 执行程序 参数1 参数2 参数3<br>在命令行中 传入参数后，可以在程序中从args中取出这些参数</p></blockquote><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="对象含义"><a href="#对象含义" class="headerlink" title="对象含义"></a>对象含义</h3><ul><li><p>对象 &#x3D; 数据 + 服务（提供的待使用函数）</p></li><li><p><strong>对象变量只是对象的管理者</strong>，对象变量的赋值在默认情况下是引用传递，赋的值是地址，赋值方式为引用传递</p></li><li><p><strong>对象内部的数据应该被保护起来不对外公开，把数据和对数据的操作放在一起，隐藏方法实现法细节，对外提供操作该对象的接口。这就是封装</strong>。</p></li></ul><h3 id="对象的初始化"><a href="#对象的初始化" class="headerlink" title="对象的初始化"></a>对象的初始化</h3><h4 id="成员变量定义初始化"><a href="#成员变量定义初始化" class="headerlink" title="成员变量定义初始化"></a>成员变量定义初始化</h4><ul><li>成员变量在定义的地方就可给出初始值</li><li>没有给出初始值的成员变量会自动获得零值<ul><li>对象的零值表示没有管理任何对象，也可主动给NULL值</li></ul></li><li>定义初始化可以调用函数甚至可以使用已经定义的成员变量<ul><li>例：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> f1();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f1</span><span class="params">()</span>&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><ul><li>基本语法<ul><li>[修饰符] + 方法名 （参数表）{函数体}    <br></li></ul></li><li>构造器特点 <ul><li><strong>这个函数没有返回值类型</strong></li><li><strong>这个函数名字和类的名字完全相同</strong></li><li>在创建这个类的每一个对象的时候会自动调用这个函数</li><li>可通过构造器在创建对象的时候就直接完成对象属性初始化<blockquote><p>构造器的最前面<strong>默认情况下隐含了super函数和调用普通代码块</strong>。</p><ul><li>即构造函数（）<br>{<br>super();<br>调用本类的普通代码块;<br>&#x2F;&#x2F;程序员添加的操作<br>}</li><li>故实际上创建对象时先调用构造函数，后调用普通代码块。  </li><li>但执行其中自己添加的语句的顺序是普通代码块先于构造函数</li><li>debug跟踪发现 在创建对象时先进入构造函数，然后再跳转到普通代码块内（无继承发生的情况下）</li></ul></blockquote></li></ul></li></ul><br>  <ul><li>构造器重载<ul><li>构造函数可以<strong>重载（overload）</strong>，可以由多个构造函数，只需要函数的参数表不同</li><li>若程序员没有定义构造器，系统会自动给类生成一个默认的空实现的无参构造器。<br>  但一旦为该类提供了构造器，系统就不在提供默认的构造器了。</li><li><strong>如果一个类中定义了有参的构造方法，最好再定义一个无参的构造方法</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">hello</span>&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    hello()&#123;</span><br><span class="line">        value = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    hello(<span class="type">int</span> value)&#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><blockquote><p>javap 是JDK提供的一个命令行工具，能对给定的class文件提供的字节码进行反编译，通过他可以对照源代码和字节码了解编译器的内部工作。<br>使用格式：javap <options> <classes> </p><ul><li>常用：javap -c &#x2F;-v 类名 (-c对代码反汇编，-v输出附加信息)</li></ul></blockquote><h3 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h3><ul><li><p>jvm给每个对象分配this，代表当前对象，用于在方法中访问对象中的其他成员。</p><ul><li><p>通过this可以明确地访问一个类的成员变量，解决与局部变量名称冲突问题</p></li><li><p>通过this调用成员方法</p></li><li><p>通过this可以访问构造器</p><ul><li>访问构造器语法： this（参数列表）; </li><li>但<strong>只能在构造器中调用其他构造器，且只能位于第一行，只能出现一次</strong>。</li></ul></li><li><p>this不能在类定义的外部使用，只能在类定义的方法中使用  </p></li><li><p>this访问属性的规则</p><ul><li>1 先找本类，如果有，则调用</li><li>2 如果没有，则找父类（如果父类有并且可以调用，则调用）</li><li>3 如果父类没有则可以继续找父类的父类直到Object类</li><li>注意:如果查找属性的过程中找到了该属性但没有访问权限，则会报错，cannot access ,并不会继续在父类的父类中继续查找该属性，若查找的过程中没有找到，则提示属性不存在。</li></ul></li></ul>  <br></li></ul><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><ul><li>java中的垃圾回收机制：java虚拟机会自动回收垃圾所占用的内存空间</li><li>也可以通过调用System.gc()方法来通知java虚拟机立即惊醒垃圾回收<ul><li>当一个对象在内存中被释放时，它的 <strong>finalize()</strong> 方法会被自动调用，故可以在类内定义 finalize()方法来观察对象何时被释放</li></ul></li></ul><h1 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h1><h2 id="public"><a href="#public" class="headerlink" title="public"></a>public</h2><ul><li>public表示被修饰的变量&#x2F;函数是开放的，可随意访问的。</li><li>在class关键字前加public表示任何人都可以用这个类来定义对象，如果类是public则要求该类必须处在一个文件名与类名相同的源代码文件中。</li></ul><h2 id="private"><a href="#private" class="headerlink" title="private"></a>private</h2><ul><li>private关键字只能用于成员变量和成员函数<ul><li>表示被修饰的变量&#x2F;函数是这个类私有的，<strong>只有在类内才能访问</strong>。</li><li><strong>这个限制是对于类的而不是对对象的。即同一个类的不同对象可以互相访问别人的私有成员</strong>，同一个类的对象共用类内函数，判断是否能被访问仅看作用域是否在定义该成员的类中。<a href="https://blog.csdn.net/fukaibo121/article/details/73611184">相关内容</a> <ul><li>例：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">Outer</span> <span class="variable">outer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">            <span class="type">Outer</span> <span class="variable">outer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">            outer1.test(outer2);<span class="comment">//outer可以在自己的函数中直接访问到outer2的私有变量</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Outer tesOuter)</span>&#123;</span><br><span class="line">                System.out.println(tesOuter.num);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        ```    </span><br><span class="line"></span><br><span class="line">- 基本原则是所有的成员变量都设置为私有的，保护这些变量不能被外界随意使用，对外提供相应的函数接口让这个类按设计者意图去被使用。  </span><br><span class="line"></span><br><span class="line">- **当一个编译单元中有不止一个类的时候，只有一个类可以是<span class="keyword">public</span>**    </span><br><span class="line"></span><br><span class="line">- 如果一个类前没有<span class="keyword">public</span>，则这个类只能在当前所在的<span class="keyword">package</span>中起作用，</span><br><span class="line"></span><br><span class="line">## <span class="keyword">protected</span></span><br><span class="line">- 子类和同一个<span class="keyword">package</span>的其他类可以访问。</span><br><span class="line">## friendly（默认）</span><br><span class="line">- 如果没有在一个成员前<span class="keyword">private</span>或<span class="keyword">public</span>修饰，就是friendly，意思是和该成员位于同一个<span class="keyword">package</span>的其他类可以访问。</span><br><span class="line"></span><br><span class="line">#  封装</span><br><span class="line">## 介绍</span><br><span class="line">- 封装就是把数据和对数据的操作放在一起，对象内部的数据应该被保护起来不对外公开，对外提供操作该对象的接口。这就是封装。</span><br><span class="line">## 作用</span><br><span class="line">- 可以对数据进行验证，保证安全合理  </span><br><span class="line">&lt;br&gt;</span><br><span class="line">- 利用接口和实现聚合</span><br><span class="line">    - 把实现类内成员变量操作的方法在类内实现，对外隐藏细节</span><br><span class="line">    - 有效利用容器，提升灵活性</span><br><span class="line">    - 后面代码如何发展与外部无关，提升代码的可拓展性</span><br><span class="line">    - 以框架 + 数据来提高可拓展性   </span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    </span><br><span class="line">- 利用封装来降低耦合</span><br><span class="line">    - 类和类之间的关系成为耦合</span><br><span class="line">    - 耦合程度越低越好，保持距离，保证代码的可拓展性是形成良好代码的关键</span><br><span class="line">    - 最好不要在一个类中直接操作，输出另一个类中的成员变量</span><br><span class="line">    &gt;建议：一段代码最好只完成一个最小的功能，降低代码之间的耦合性</span><br><span class="line"></span><br><span class="line">### 封装的实现</span><br><span class="line">- <span class="number">1</span>  将属性进行私有化，保证外部不可随意修改查看属性</span><br><span class="line">- <span class="number">2</span>  提供<span class="keyword">public</span>的get 和 set方法用于获得和修改属性的值（一般get方法要有返回值，set可以设置为<span class="type">boolean</span>的返回类型）</span><br><span class="line">    - 把数据验证和权限判断的代码封装在成员函数内部</span><br><span class="line">    - 将构造器与set函数结合起来，set方法放入构造器中</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#  继承</span><br><span class="line"></span><br><span class="line">## 继承语法</span><br><span class="line">- class 子类 extends 父类&#123;&#125;</span><br><span class="line">    - 子类就会自动拥有父类定义的属性和方法</span><br><span class="line">    - 父类也叫超类 ， 基类</span><br><span class="line">    - 子类也叫派生类</span><br><span class="line"></span><br><span class="line">## 继承作用</span><br><span class="line">- 通过继承可以解决代码复用，</span><br><span class="line">- 当多个类中存在相同的属性和方法是，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有子类只需通过**extends**来声明继承父类即可，而不需要子类重新定义这些属性和方法。</span><br><span class="line">## 继承的特点</span><br><span class="line"></span><br><span class="line">- <span class="number">1</span> 子类继承了父类所有的属性和方法，但<span class="keyword">private</span>的属性和方法不能在子类直接访问，要通过父类提供的<span class="keyword">public</span>的方法访问</span><br><span class="line">- <span class="number">2</span>  java继承只支持单继承，一个类只能有一个直接父类</span><br><span class="line">- <span class="number">3</span> 子类可以**重写override**并覆盖父类的同名方法（必须和父类方法名称，参数表相同，子类返回两类型要和父类返回类型一样或者是父类返回类型的子类）</span><br><span class="line">## 继承的细节</span><br><span class="line">- 重写的子类方法权限不能小于父类方法的访问权限  </span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">- 访问子类构造方法之前会访问父类构造方法，完成父类的初始化  </span><br><span class="line">&lt;br&gt;</span><br><span class="line">- 当创建子类对象时，不管子类使用哪个构造器，默认情况下总会去调用父类的无参构造器，**若父类没有提供无参构造器，则必须在子类的构造器中用<span class="built_in">super</span>去制定使用父类的哪个构造器完成对父类的初始化**</span><br><span class="line">    - 故定义一个类时，无特殊需求时，最好在类中定义一个无参构造器。  </span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">- java所有的类都是Object类的子类    </span><br><span class="line">&lt;br&gt;</span><br><span class="line">- 父类构造器的调用不限于直接父类，而是一直向上追溯到Object类（顶级父类）</span><br><span class="line">### <span class="built_in">super</span>()函数</span><br><span class="line">- [<span class="built_in">super</span>函数相关内容](https:<span class="comment">//blog.csdn.net/pipizhen_/article/details/107165618)</span></span><br><span class="line">- 作用是能够帮助子类初始化从父类继承下来的成员,从而简化代码     </span><br><span class="line">&lt;br&gt;</span><br><span class="line">- 当子类和父类中有重名成员时必须借用<span class="built_in">super</span>来访问父类成员</span><br><span class="line">    - <span class="built_in">super</span>的访问不限于直接父类，包括更高级的类也可以用<span class="built_in">super</span>去访问，若多个基类中都有同名成员，用<span class="built_in">super</span>访问必须遵循就近原则。A-&gt;B-&gt;C</span><br><span class="line">    - **但不可跳跃访问，若父类同名变量私有，则不会继续向上查找爷爷类是否还有可访问的同名变量**  </span><br><span class="line">    &lt;br&gt;</span><br><span class="line">- <span class="built_in">super</span>不能出现在静态方法中，<span class="keyword">static</span>上下文不能够出现 <span class="built_in">this</span> <span class="built_in">super</span>。    </span><br><span class="line">&lt;br&gt;</span><br><span class="line">- <span class="built_in">super</span>()和<span class="built_in">this</span>()在使用时，**必须放在构造器第一行**</span><br><span class="line">    - **<span class="built_in">this</span> 和 <span class="built_in">super</span> 访问构造方法不能同时存在**</span><br><span class="line">    - 这里<span class="built_in">super</span>()的作用是制定调用父类的哪个构造方法</span><br><span class="line">    - **若没有自己写<span class="built_in">super</span>函数调用，在实例化子类对象时会自动调用父类无参构造器，效果等同于<span class="built_in">super</span>（）**;       </span><br><span class="line">       </span><br><span class="line">## <span class="keyword">final</span>关键字</span><br><span class="line">- <span class="keyword">final</span>关键字用于修饰类，属性，方法和局部变量</span><br><span class="line">- 使用<span class="keyword">final</span>修饰的情况</span><br><span class="line">    - <span class="number">1</span> 当类不希望被继承时，可以用<span class="keyword">final</span>修饰这个类</span><br><span class="line">    - <span class="number">2</span> 当不希望父类的某个方法被子类override时，可以用<span class="keyword">final</span>修饰这个方法</span><br><span class="line">    - <span class="number">3</span> 当不希望某个类的某个属性的值被修改，可以用<span class="keyword">final</span>修饰这个属性</span><br><span class="line">    - <span class="number">4</span> 当不希望某个局部变量的值被修改，可以用<span class="keyword">final</span>修饰这个局部变量</span><br><span class="line">- 使用细节</span><br><span class="line">    - <span class="keyword">final</span>修饰的属性也叫常量，一般用XX_XX（大写字母加下划线）来命名</span><br><span class="line">    - <span class="keyword">final</span>修饰的属性必须在定义时给出初值，可以在以下位置赋初值</span><br><span class="line">        - 在定义时 </span><br><span class="line">        - 在构造器中</span><br><span class="line">        - 在代码块中</span><br><span class="line">    - 若<span class="keyword">final</span>修饰的属性是静态的，则初始化的位置只能是</span><br><span class="line">        - 定义时</span><br><span class="line">        - 在静态代码块中</span><br><span class="line">        - （此时不能在构造器中赋值）</span><br><span class="line">    - <span class="keyword">final</span>类不能继承但可以实例化对象</span><br><span class="line">    - 如果类不是<span class="keyword">final</span>类，但含有<span class="keyword">final</span>方法，则该方法虽然不能重写但可以被继承 </span><br><span class="line">    - 若是一个类已经是<span class="keyword">final</span>类了，则没必要再将其中的方法修饰为<span class="keyword">final</span></span><br><span class="line">    - <span class="keyword">final</span>不能修饰构造方法</span><br><span class="line">    - <span class="keyword">final</span>和<span class="keyword">static</span>搭配使用效率更高，不会导致类加载，底层编译器做了优化</span><br><span class="line">    ```java</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span> ;</span><br><span class="line">        <span class="keyword">static</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Test类加载&quot;</span>);</span><br><span class="line">        &#125;<span class="comment">//在main中直接输出Test.num,是否会出现类加载的情况？若是去掉static呢？</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>包装类如Integer，Double，等都是final类，String也是final类，不可被继承</li></ul></li></ul><h2 id="对象创建具体流程"><a href="#对象创建具体流程" class="headerlink" title="对象创建具体流程"></a>对象创建具体流程</h2><ul><li>1，加载类信息，只加载一次</li><li>2，在堆中分配空间（地址）</li><li>3，完成对象初始化<ul><li>1 默认初始化 （实例化对象时jvm会将成员变量自动初始化为0，null等）</li><li>2 显式初始化 </li><li>3 构造器初始化<blockquote><ul><li>先完成类加载再加载实例对象的相关属性和方法</li><li>注意普通代码块是在构造函数中调用的，构造函数调用先于普通代码块调用<ul><li>子类的初始化依赖于父类的初始化，通常通过调用super()来完成父类的初始化。因此，父类的构造函数调用应该在子类构造函数内的任何其他操作之前，包括子类的实例初始化块和构造函数中的其他代码。</li></ul></li><li>若是普通代码块在构造函数前执行，岂不是意味着普通代码块构造先于构造函数中的super（）初始化父类，父类还没初始化怎么可能用代码块初始化子类对象呢</li><li>调用静态代码块和静态变量的初始化时，他们的优先级相同，若有多个静态代码块和多个非态变量初始化，则按定义顺序调用</li><li>调用普通代码块和非静态变量的初始化时，他们的优先级相同，若有多个普通代码块和多个非静态变量初始化，则按定义顺序调用</li><li>java中实例化对象时调用顺序（debug时程序的调用顺序）：父类静态变量 -&gt;父类静态代码块 -&gt; 本类静态变量 -&gt; 本类静态代码块 -&gt; 本类构造函数 -&gt; 父类构造函数 -&gt; 父类普通变量  -&gt; 父类代码块 -&gt; 本类普通变量 -&gt; 本类代码块 </li><li>java中实例化对象时初始化顺序（指代码执行时程序员自己添加的代码执行顺序）：父类静态变量 -&gt;父类静态代码块 -&gt; 本类静态变量 -&gt; 本类静态代码块  -&gt; 父类普通变量  -&gt; 父类代码块 -&gt; 父类构造函数 -&gt; 本类普通变量 -&gt; 本类代码块 -&gt; 本类构造函数</li></ul></blockquote></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;<span class="comment">//可debug跟踪查看程序具体执行流程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> getN1();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> getN2();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类静态代码块调用&quot;</span>);</span><br><span class="line">    &#125;;A()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类构造函数调用&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getN1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类静态变量加载&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    &#125;<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getN2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类普通变量加载&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    &#125;&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类普通代码块调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num3</span> <span class="operator">=</span> getN3();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num4</span> <span class="operator">=</span> getN4();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类静态代码块调用&quot;</span>);</span><br><span class="line">    &#125;B()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类构造函数调用&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getN3</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类静态变量加载&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    &#125;<span class="keyword">public</span>  <span class="type">int</span> <span class="title function_">getN4</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类普通变量加载&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    &#125;&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类普通代码块调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//当主类new B时会输出什么结果，为什么会输出这种结果？若是将静态变量定义位置与静态代码块位置交换结果会有不同吗？</span></span><br></pre></td></tr></table></figure><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h2 id="多态基本介绍"><a href="#多态基本介绍" class="headerlink" title="多态基本介绍"></a>多态基本介绍</h2><ul><li>Polymorphic   <br></li><li>为了解决传统代码的复用性不高，不利于代码维护的缺点引入多态    <br></li><li>多态是指<strong>方法或者对象</strong>拥有多种形态，是面向对象的第三大特征，多态是建立在封装和继承的基础上的    <br></li></ul><h2 id="多态的具体体现"><a href="#多态的具体体现" class="headerlink" title="多态的具体体现"></a>多态的具体体现</h2><h3 id="1-方法的多态"><a href="#1-方法的多态" class="headerlink" title="1  方法的多态"></a>1  方法的多态</h3><ul><li>重写和重载体现多态，因参数不同同名函数实际调用方法却不同</li></ul><h4 id="函数调用的绑定"><a href="#函数调用的绑定" class="headerlink" title="函数调用的绑定"></a>函数调用的绑定</h4><ul><li>当通过对象变量调用函数时，调用那个函数这件事叫绑定<ul><li>静态绑定：根据变量的声明类型来决定，<strong>在编译时就确定了调用的函数</strong></li><li><strong>动态绑定</strong>：根据变量的动态类型来决定，<strong>在运行时才能确定调用的函数</strong></li></ul></li></ul><h3 id="2-对象的多态"><a href="#2-对象的多态" class="headerlink" title="2  对象的多态"></a>2  对象的多态</h3><ul><li>一个对象的编译类型和运行类型可以不一致</li><li>编译类型在定义对象时就确定了</li><li>运行类型却是根据实际运行时情况决定</li><li>编译类型看定义时 &#x3D; 左边 ， 运行类型看 &#x3D; 右边<ul><li>编译类型就是这个对象变量的属性且不可修改<ul><li>编译类型是由声明该变量时使用的类型决定的</li></ul></li><li>运行类型是实际赋给该变量的内存空间的模板的类型<ul><li>运行类型是由变量指向的具体对象的类型决定</li><li>可以用getClass函数来获得该变量的运行类型</li></ul></li></ul></li></ul><h4 id="向上造型"><a href="#向上造型" class="headerlink" title="向上造型"></a>向上造型</h4><ul><li><p><strong>子类的对象被当做父类对象来使用</strong>    </p><ul><li><p>子类对象赋值给父类变量</p><ul><li><strong>此时不能通过该变量直接调用子类的特有成员</strong>，只有在子类重写父类方法时才能调用子类重写的方法</li><li>此时调用函数时<strong>先在运行类型（子类）中<em>重写父类的函数</em> 中查找</strong>，若没有再去父类中寻找</li></ul></li><li><p>子类对象可以传递给需要父类对象的函数</p></li><li><p>子类对象可以存放在父类对象的容器中</p></li></ul></li><li><p><strong>通过父类变量调用存在覆盖关系的函数时，会调用变量当时的管理的对象运行类型的函数，这时就会发生多态</strong></p></li></ul><h4 id="向下造型"><a href="#向下造型" class="headerlink" title="向下造型"></a>向下造型</h4><ul><li><p>语法：子类类型 引用名 &#x3D; （子类类型） 父类引用     </p></li><li><p><strong>只能强转父类的引用，不能强转父类对象</strong>      </p></li><li><p>要求父类的引用必须指向的是当前目标类型的对象</p><ul><li>即只能将被向上造型的对象的引用向下强转（即只能往回转，并不能在一个父类对象中创造父类中本没有的子类的成员）</li></ul></li><li><p><strong>可以调用子类类型中所有的成员</strong></p></li></ul><h4 id="动态绑定-DynamicBonding"><a href="#动态绑定-DynamicBonding" class="headerlink" title="动态绑定(DynamicBonding)"></a>动态绑定(DynamicBonding)</h4><ul><li>java的动态绑定机制<ul><li><p><strong>调用对象方法时，该方法会与对象的内存地址&#x2F;运行类型绑定</strong> </p><ul><li>即会首先在运行类型重写方法中寻找该方法 </li><li>具体调用哪个方法在运行时才能解析确定</li></ul></li><li><p>当调用对象属性时，<strong>属性没有动态绑定机制</strong>，哪里声明哪里使用</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span> ;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getI</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i +<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>  <span class="title function_">showI</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getI();<span class="comment">//此处会动态绑定调用B中getI()函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">20</span> ;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getI</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicBoding</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        sout(a.showI());<span class="comment">//运行结果是40</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="多态的细节和注意事项"><a href="#多态的细节和注意事项" class="headerlink" title="多态的细节和注意事项"></a>多态的细节和注意事项</h2><ul><li>属性没有重写一说，属性的值看编译类型  <br></li><li>instanceOf比较操作符，用于判断<strong>对象的运行类型</strong>是否为某运行类型或某类型的子类（就是看该对象的实际内存模型）<ul><li>语法： 对象名 instanceof  类名</li></ul></li></ul><h2 id="多态的应用"><a href="#多态的应用" class="headerlink" title="多态的应用"></a>多态的应用</h2><ul><li>多态数组：数组定义类型为父类类型，里面实际保存类型为子类类型<ul><li>在多态数组循环遍历时可以利用instanceof关键字来判断数组内变量的运行类型，并做出相应类型的操作    <br></li></ul></li><li>多态参数：方法定义的形参为父类类型，实参允许为子类类型</li></ul><h1 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h1><h2 id="抽象类和抽象"><a href="#抽象类和抽象" class="headerlink" title="抽象类和抽象"></a>抽象类和抽象</h2><ul><li><p>当父类的某些方法需要声明，但又不确定如何实现时，可以将该方法声明为抽象（abstract）方法，那么这个类就必须要声明为抽象类</p><ul><li>abstact关键字只能用于修饰类和函数</li></ul></li><li><p>抽象函数——表达概念而无法实现具体代码的函数</p><ul><li>用 abstract关键字修饰一个函数，那么这个函数就是抽象函数</li><li>抽象函数特点<ul><li>抽象函数没有方法体</li><li><strong>抽象函数不能用private，final和static来修饰，因为这些关键字都是与重写相违背的</strong></li><li>如果一个类中抽象函数，那么需要将这个类声明为抽象类</li><li><strong>继承自抽象类的非抽象子类必须覆盖父类中的抽象函数</strong></li></ul></li></ul></li><li><p>抽象类——表达概念而无法构造出实体的类</p><ul><li>用 abstract关键字修饰一个类，那么这个类就是抽象类</li><li>抽象类一般只是作为几个类的公共概念，并为作为父类其提供共有属性</li><li>抽象类特点<ul><li>抽象类不能实例化产生对象</li><li>抽象类仍是类，可以有任意成员</li><li>抽象类中不一定要有抽象函数，但抽象函数必须要在抽象类中</li><li><strong>如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法</strong>，除非他自己也声明为abstract类  </li><li>抽象类的价值在于设计，由设计者设计好之后，让子类继承并实现抽象类</li></ul></li></ul></li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul><li><p>概念</p><ul><li>Java接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）</li><li>接口可以理解为一种特殊的类，里面全部是由全局常量和公共的抽象方法所组成。接口是<strong>解决Java无法使用多继承的一种手段</strong>，但是接口在实际中更多的作用是<strong>制定标准</strong>的。或者我们可以直接把接口理解为100%的抽象类，既接口中的方法必须全部是抽象方法。（JDK1.8之前可以这样理解）</li></ul></li><li><p>基本介绍</p><ul><li>interface 接口</li><li>是一种特殊的class，与class地位相同</li><li>用implements表示类实现接口，在实现接口的类中要实现接口中的所有的抽象函数</li><li>类可以实现多个接口</li><li>接口可以继承接口，但不能继承类</li><li>接口不能实现接口</li></ul></li><li><p>语法</p><ul><li>接口定义：<br>  interface 接口名{<br>  &#x2F;&#x2F;属性方法等<br>  }  <blockquote><p>在jdk7.0之前接口里的所有方法都没有方法体<br>  jdk8.0后接口类中可以有静态函数，默认函数，也就是说接口中可以有方法法具体实现，要用默认函数default关键字修饰</p></blockquote></li><li>接口实现：<br>  class 类名 implements 接口{<br>  &#x2F;&#x2F;自己属性和函数，且必须实现接口的抽象函数<br>  }</li></ul></li><li><p>接口细节 </p><ul><li>接口特点<ul><li>接口是纯抽象类</li><li>所有的成员函数默认是public的抽象函数,可以不用abstract修饰</li><li><strong>所有的成员变量都默认是public static final</strong> </li><li>接口的修饰符只能是public和默认  </li><li>接口只是规定了长什么样子，但是不管里面有什么<ul><li>例  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">            <span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//就是public static final int a = 1 ;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line">            <span class="comment">//主方法中创建B实例对象b,是否可以输出 b.a , B.a , A.a ?</span></span><br><span class="line">            ```   </span><br><span class="line"></span><br><span class="line">    - 接口实现细节 </span><br><span class="line">        - 当一个类实现接口时，如果这个类是抽象类，则可以只实现接口中的部分方法，否则要实现接口的所有抽象函数</span><br><span class="line">        - 一个类可以同时实现多个接口，接口之间用逗号， 隔开</span><br><span class="line">        - **任何实现了接口的类都可以传递给需要接口类对象的函数**</span><br><span class="line">            - 此时可以在该函数中调用接口中的函数。 </span><br><span class="line">    - 接口继承细节</span><br><span class="line">        - 接口不能继承类但接口可以继承接口，用extends关键字，且可以继承多个接口，用逗号，隔开</span><br><span class="line">        - 一个类在基础恒另一个类的同时还可以实现接口，此时extends关键字必须位于implements关键字之前</span><br><span class="line"></span><br><span class="line">- 实现接口与继承类的比较</span><br><span class="line">    - 接口与继承解决的问题不同</span><br><span class="line">        - 继承的价值在于：提升代码的复用性和可维护性</span><br><span class="line">        - 接口的价值在于：设计，设计好各种规范和方法，让其他类去实现这些方法，更加灵活</span><br><span class="line">    - 接口再一定程度上实现代码解耦[即：接口规范性 + 动态绑定]</span><br><span class="line"></span><br><span class="line">- 接口的多态</span><br><span class="line">    - 多态参数</span><br><span class="line">        - 接口类型的变量可以指向实现了该接口的类的对象</span><br><span class="line">    - 多态数组</span><br><span class="line">        - 可以创建接口类型的数组，其中的引用指向实现了该接口的类的对象</span><br><span class="line">        - 在调用数组中变量的被实现的接口类的抽象函数时，会动态绑定调用该对象运行类型类中实现的接口中的抽象函数</span><br><span class="line">    - 接口多态传递</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line">- 一个简单的运用接口的例子：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComputerRun</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        <span class="type">Mouse</span> <span class="variable">mouse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mouse</span>();</span><br><span class="line">        <span class="type">Keyboard</span> <span class="variable">keyboard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Keyboard</span>();</span><br><span class="line">        computer.addNewDevice(mouse);</span><br><span class="line">        computer.addNewDevice(keyboard);</span><br><span class="line">        computer.toolOn();</span><br><span class="line">        computer.toolOff();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Usb</span>&#123;<span class="comment">//接口相当于提供一种规范,要求实现接口的类必须实现某些函数</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">toolOn</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">toolOff</span><span class="params">()</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Usb2</span> <span class="keyword">extends</span> <span class="title class_">Usb</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span> <span class="keyword">implements</span> <span class="title class_">Usb</span>&#123;<span class="comment">//实现接口</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//private Usb he = new Usb();错误！不能将接口类实例化</span></span><br><span class="line">    <span class="comment">//但可以实现接口的数组，因为这里只是创建了接口类的引用，并没有创建接口实例，引用可以指向实现了接口的其他类的对象实例</span></span><br><span class="line">    <span class="keyword">private</span> Usb[] devices = <span class="keyword">new</span> <span class="title class_">Usb</span>[<span class="number">2</span>]; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//在这里接口类参数相当于一种规范，只有实现了Usb接口的对象才能传入这个函数，并且不管这个对象内部有什么</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNewDevice</span><span class="params">(Usb device)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//只是将用接口类引用指向传入的对象，类似于向上造型</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; devices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(devices[i] != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">continue</span> ;</span><br><span class="line">            </span><br><span class="line">            devices[i] = device;</span><br><span class="line">            <span class="keyword">if</span>(devices[i] <span class="keyword">instanceof</span> Keyboard)&#123;</span><br><span class="line">                <span class="type">Keyboard</span> <span class="variable">test</span> <span class="operator">=</span> (Keyboard) devices[i];<span class="comment">//向下造型</span></span><br><span class="line">                System.out.println(<span class="string">&quot;鼠标名是&quot;</span> + test.name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toolOn</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; devices.length; i++) &#123;</span><br><span class="line">            devices[i].toolOn();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;电脑启动&quot;</span>);</span><br><span class="line">        <span class="comment">//传入的对象都是实现了接口的，这里会发生多态，调用其运行类型的类内实现的接口抽象函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toolOff</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; devices.length; i++) &#123;</span><br><span class="line">            devices[i].toolOn();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;电脑关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mouse</span> <span class="keyword">implements</span> <span class="title class_">Usb</span>&#123;<span class="comment">//</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toolOn</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鼠标启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toolOff</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鼠标关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Keyboard</span> <span class="keyword">implements</span> <span class="title class_">Usb2</span>&#123;<span class="comment">//实现Usb2，而Usb2继承了Usb，故相当于keyboard类也实现了Usb接口，可以传递给Usb类的引用，这就是接口多态传递</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;罗技&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toolOn</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;键盘启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toolOff</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;键盘关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li><li><p>面向接口的编程方式</p><ul><li>设计程序时先定义接口，再实现类</li><li>任何需要在函数间传入传出的一定是接口而不是具体的类（可扩展性高）</li><li>是java成功的关键，适合写大型程序，也导致程序代码量膨胀极快      <br></li></ul></li><li><p>两种抽象</p><ul><li>与具体相对<ul><li>表达一种概念而非实体</li></ul></li><li>与细节相对<ul><li>表示在一定程度上忽略细节关注大局</li></ul></li></ul></li></ul><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><ul><li>基本介绍<ul><li>一个类内部有完整的潜逃了另一个类结构，被奇纳陶瓷的类称为内部类（inner class），</li><li>嵌套其他类的类称为外部类（outer class）。</li><li>内部类是类的第五大成员。<ul><li>类的五大成员：<ul><li>属性</li><li>方法</li><li>构造器</li><li>代码块</li><li>内部类</li></ul></li></ul></li><li>内部类的最大特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系</li></ul></li><li>基本语法  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- <span class="keyword">class</span> <span class="title class_">Outer</span>&#123;<span class="comment">//外部类  </span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;<span class="comment">//内部类  </span></span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">other</span>&#123;<span class="comment">//外部其他类</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>分类<ul><li>定义在外部类局部位置上：<ul><li>局部内部类（有类名）</li><li><strong>匿名内部类</strong>（没有类名）【重要！】</li></ul></li><li>定义在外部类的成员位置上：<ul><li>成员内部类（没用static修饰）</li><li>静态内部类（使用static修饰）</li></ul></li></ul></li></ul><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><ul><li><p>定义</p><ul><li>局部内部类是 <strong>定义在外部类的局部位置（方法和块中）</strong>，并且有类名</li><li>本质仍然是一个类</li></ul></li><li><p>特点</p><ul><li>可以直接访问外部类所有成员，包含私有的</li><li>不能添加访问修饰符，因为它的地位就是一个局部变量<ul><li>局部变量不能使用修饰符，但可以使用final修饰</li><li>加final修饰后就不可被继承</li></ul></li></ul></li><li><p>作用域：<strong>仅仅在定义它的方法或代码块中</strong></p></li><li><p>访问权限</p><ul><li>局部内部类访问外部类的成员<ul><li>直接访问</li></ul></li><li>外部类访问局部内部类成员<ul><li>先创建对象，再访问（注意，必须在作用域内创建对象）</li></ul></li><li>外部其他类不能访问局部内部类，因为局部内部类地位是一个局部变量</li></ul></li><li><p>如果外部类和局部内部类重名时，默认遵循就近原则</p><ul><li>如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClassTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        outer.function();</span><br><span class="line">        System.out.println(<span class="string">&quot;调用内部类函数的对象的哈希值 = &quot;</span> + outer.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">3</span> ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;外部类方法调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">function</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//局部内部类是定义在外部类的局部位置，通常在方法中</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;<span class="comment">//作用域仅仅在定义它的方法和代码块中</span></span><br><span class="line">            <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">2</span> ;</span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">printinfo</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//访问外部类重名属性使用（外部类名.this.成员）格式</span></span><br><span class="line">                <span class="comment">//这里Outer.this本质就是外部类的对象，即那个对象调用了printinfo函数，</span></span><br><span class="line">                <span class="comment">//Outer.this就是哪个对象,可以通过比较Outer.this和调用该函数的对象的哈希值</span></span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;外部类私有属性num = &quot;</span> + Outer.<span class="built_in">this</span>.num);</span><br><span class="line">                System.out.println(<span class="string">&quot;内部类属性    num = &quot;</span> + <span class="built_in">this</span>.num);</span><br><span class="line">                System.out.println(<span class="string">&quot;就近访问的    num = &quot;</span> + num);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;Outer.this的对象的hashcode值 = &quot;</span> + Outer.<span class="built_in">this</span>.hashCode());</span><br><span class="line"></span><br><span class="line">                method();<span class="comment">//可以直接访问外部类的所有的成员和方法</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在定义这个内部类的方法中创建内部类实例对象，直接调用方法即可</span></span><br><span class="line">        <span class="type">Inner</span> <span class="variable">doPrint</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        doPrint.printinfo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//private Inner doPrint2 ;//错误，在定义局部内部类的函数之外无法访问到这个类</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="匿名内部类-重要"><a href="#匿名内部类-重要" class="headerlink" title="匿名内部类(重要)"></a>匿名内部类(重要)</h2><p>AnonymousInnerClass</p><ul><li>定义<ul><li>匿名内部类是定义在外部类的局部位置，比如方法中，并且没有类名的内部类</li></ul></li><li>本质<ul><li>本质是类</li><li>内部类</li><li>该类没有名字</li><li>同时还是一个对象</li></ul></li><li>基本语法<ul><li>new 类或接口(参数列表){<br>  类体<br>  };</li></ul></li><li>产生原因<ul><li>基于需求，当需要创建一个类实现一个接口，创建对象，但<strong>仅使用一次</strong>后面不在使用</li><li>为了简化开发</li></ul></li></ul><h3 id="实现接口的匿名内部类"><a href="#实现接口的匿名内部类" class="headerlink" title="实现接口的匿名内部类"></a>实现接口的匿名内部类</h3><ul><li>分析下列实例<ul><li>keyboard引用就是指向实现的匿名对象</li><li>keyboard的编译类型是Usb</li><li><strong>keyboard的运行类型就是该匿名内部类</strong></li><li>底层就相当于  <ul><li>class XXXX implements Usb{<br>public void deviceRun(){}<br>  }</li><li><strong>即创建出一个实现了USb接口的类</strong></li><li>这里的XXXX是由系统分配的，如果用getClass函数输出，一般匿名内部类的class输出会包含一个$字符</li></ul></li><li><strong>基于接口的匿名内部类必须要实现对应接口的抽象函数</strong></li><li>匿名内部类使用一次后就无法再使用，即只能创建一个实例对象</li><li>匿名内部类内部可以添加实现其他接口中没有的属性和方法<ul><li>但创建实例后无法访问，因为其运行类型是匿名类，无法向下造型</li><li>但可以但可以在重写的方法中调用新添加的方法</li></ul></li></ul></li><li>例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Usb</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deviceRun</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Keyboard</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Usb</span> <span class="variable">keyboard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Usb</span>&#123;</span><br><span class="line">            <span class="comment">//实现对应接口的抽象函数</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deviceRun</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;键盘启动&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        keyborad.deviceRun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="基于类的匿名内部类"><a href="#基于类的匿名内部类" class="headerlink" title="基于类的匿名内部类"></a>基于类的匿名内部类</h3><ul><li>分析下列实例代码<ul><li>base是Base类型的引用指向创建的匿名内部类对象</li><li>base的编译类型是Base</li><li><strong>base的运行类型就是该匿名内部类</strong></li><li><strong>底层就相当于</strong>  <ul><li>Base base&#x3D; new XXXX();<br>  class XXXX extends Base{<br>  &#x2F;&#x2F;故即使方法块中没有任何语句，XXXX仍是一个新的区别于Base的类<br>  }</li><li>即<strong>创建了一个继承base的子类XXXX</strong></li></ul></li><li>匿名内部类创建时的参数列表会传递给匿名内部类基类的构造器</li><li>匿名内部类内部可以重写类中的方法</li><li>匿名内部类使用一次后就无法再使用，即只能创建一个实例对象</li><li>匿名内部类内部可以添加实现类中本没有的属性和方法<ul><li>但创建实例后无法直接访问，因为其运行类型是匿名类，无法向下造型</li><li>但可以在重写的父类的方法中调用新自己添加的方法</li></ul></li></ul></li><li>例：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHi</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;, Hi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getname</span><span class="params">()</span>&#123;<span class="keyword">return</span> <span class="built_in">this</span>.name;&#125;;</span><br><span class="line">    Base(String name)&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">testClass</span>&#123;</span><br><span class="line">    <span class="comment">//这里的参数列表会传递给匿名内部类基类的构造器</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Base</span> <span class="variable">base</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Base</span>(<span class="string">&quot;Tom&quot;</span>)&#123;</span><br><span class="line">        <span class="comment">//在方法体重可以重写对应类的函数</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        base.sayHi();</span><br><span class="line">        base.sayHello();<span class="comment">//无法访问到，且因为是匿名内部类无法向下造型访问</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//更常用的是直接创建匿名对象调用，一次使用</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Base</span>(<span class="string">&quot;Tom&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;jack&quot;</span> ;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHi</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="comment">//此处没有权限直接调用父类的name，与继承的语法关系相同</span></span><br><span class="line">                System.out.println(getname() + <span class="string">&quot;你好&quot;</span>);</span><br><span class="line">                System.out.println(name + <span class="string">&quot;你好&quot;</span>);</span><br><span class="line">                <span class="comment">//变量调用符合就近原则</span></span><br><span class="line">                <span class="built_in">this</span>.sayHello();</span><br><span class="line">                <span class="comment">//只能在匿名内部类内调用匿名类中添加的父类中本没有的新的方法</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.sayHi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="匿名内部类细节"><a href="#匿名内部类细节" class="headerlink" title="匿名内部类细节"></a>匿名内部类细节</h3><ul><li>匿名内部类即使一个类的定义，它本身也是一个对象</li><li>匿名内部类的语法中既有 <em>定义类的特征</em> 也有 <em>创建对象的特征</em></li><li>其他特点与局部内部类相同</li></ul><h3 id="匿名内部类实践"><a href="#匿名内部类实践" class="headerlink" title="匿名内部类实践"></a>匿名内部类实践</h3><ul><li><em><strong>匿名内部类当做实参直接传递</strong></em>,简洁高效<ul><li>因为匿名内部类本身也是一个对象，故可以作为参数传递给函数</li><li>例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//匿名对象方法，创建匿名内部类的匿名对象作为接口类的实参传递给函数</span></span><br><span class="line">    Cat.thisCatWantFly(<span class="keyword">new</span> <span class="title class_">Fly</span>()&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">iCanFly</span><span class="params">()</span>&#123;<span class="comment">//不能减小重写的接口方法的范围</span></span><br><span class="line">        <span class="comment">//接口方法只能是默认和public，故此处最好写上public</span></span><br><span class="line">            System.out.println(<span class="string">&quot;i am a cat , i can fly&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//传统方法，创建一个新的类FlyCat实现Fly接口，实例化后传参</span></span><br><span class="line">    <span class="type">FlyCat</span> <span class="variable">flyCat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FlyCat</span>();</span><br><span class="line">    Cat.thisCatWantFly(flyCat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Fly</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">iCanFly</span><span class="params">()</span>;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line"><span class="comment">//静态方法，参数类型为接口类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">thisCatWantFly</span><span class="params">(Fly cat)</span>&#123;</span><br><span class="line">    cat.iCanFly();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlyCat</span> <span class="keyword">implements</span> <span class="title class_">Fly</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">iCanFly</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;i am a cat , i can fly&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><ul><li><p>成员内部类是定义在外部类的成员位置，并且没有static修饰</p></li><li><p>特点</p><ul><li>可以直接访问外部类的所有成员，包含私有的</li><li>可以添加任意修饰符，因为它的地位就是一个成员</li><li>作用域和其他外部类成员一样，为整个类体</li><li>成员内部类访问外部类<ul><li>直接访问</li></ul></li><li>外部类访问成员内部类  <ul><li>先创建对象，再访问</li></ul></li><li>外部其他类访问成员内部类<ul><li><p>用外部类.内部类 方式直接创建对象</p><ul><li>例：Outer.Inner inner &#x3D; <strong>Outer.new Inner();</strong></li></ul></li><li><p>在外部类中编写方法返回一个成员内部类对象</p></li></ul></li><li>访问外部类成员规则与其他内部类相同</li></ul></li><li><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>  <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;num = &quot;</span> + num);</span><br><span class="line">            System.out.println(<span class="string">&quot;num = &quot;</span> + Outer.<span class="built_in">this</span>.num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useInner</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        inner.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><ul><li>静态内部类是定义在外部类的成员位置，并且有static修饰</li><li>特点<ul><li>可以直接访问外部类的所静态有成员，包含私有的，但不能直接访问非静态成员</li><li>可以添加任意修饰符，因为它的地位就是一个成员</li><li>作用域和其他外部类成员一样，为整个类体</li><li>外部类访问静态内部类<ul><li>要先创建对象再访问</li><li>Outer,Inner inner &#x3D; <strong>new Outer.Inner()</strong>;</li><li>因为是静态成员可以通过类名加 . 直接访问</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>  <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;num = &quot;</span> + num);</span><br><span class="line">            System.out.println(<span class="string">&quot;num = &quot;</span> + Outer.num);<span class="comment">//此处与普通成员内部类不同</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useStaticInner</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        inner.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;java-面向对象基础&lt;/p&gt;
&lt;h1 id=&quot;类和对象&quot;&gt;&lt;a href=&quot;#类和对象&quot; class=&quot;headerlink&quot; title=&quot;类和对象&quot;&gt;&lt;/a&gt;类和对象&lt;/h1&gt;&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    
    <category term="java" scheme="https://pengzhanyi.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>个人blog建设</title>
    <link href="https://pengzhanyi.github.io/2023/09/17/%E4%B8%AA%E4%BA%BAblog%E5%BB%BA%E8%AE%BE/"/>
    <id>https://pengzhanyi.github.io/2023/09/17/%E4%B8%AA%E4%BA%BAblog%E5%BB%BA%E8%AE%BE/</id>
    <published>2023-09-17T12:19:01.000Z</published>
    <updated>2023-09-18T08:56:31.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="记录关于在Github的Pages上用hexo的模板建设个人网站过程中用到的教程和走的一些坑（windows）"><a href="#记录关于在Github的Pages上用hexo的模板建设个人网站过程中用到的教程和走的一些坑（windows）" class="headerlink" title="记录关于在Github的Pages上用hexo的模板建设个人网站过程中用到的教程和走的一些坑（windows）"></a>记录关于在Github的Pages上用hexo的模板建设个人网站过程中用到的教程和走的一些坑（windows）</h1><ul><li><p>1 安装配置Node.js,<a href="https://blog.csdn.net/weixin_52799373/article/details/123840137">教程</a></p></li><li><p>2 <a href="https://zhuanlan.zhihu.com/p/392994381">安装Git ，并生成SSH密钥</a></p></li><li><p>3 下载hexo，（注意必须在管理员权限下的gitbash或powershell中下载）</p></li><li><p>4 <a href="https://zhuanlan.zhihu.com/p/78467553">部署网站</a></p></li><li><p>5 下载并应用butterfly主题时的<a href="https://zhuanlan.zhihu.com/p/137946156">坑</a></p></li></ul><p>补充</p><ul><li>6 <a href="https://hexo.io/zh-cn/docs/configuration.html">hexo官方文档</a><ul><li><p>hexo 命令要命令行在blog文件位置才有效</p><ul><li>或将hexo加入环境变量</li></ul></li><li><p>hexo new “name’      &#x2F;&#x2F;新建文章</p></li><li><p>hexo new page “name” &#x2F;&#x2F;新建页面</p></li><li><p>hexo clean &#x2F;&#x2F;清除缓存文件</p></li><li><p>hexo g   &#x2F;&#x2F;生成页面</p></li><li><p>hexo s  &#x2F;&#x2F;启动预览</p></li><li><p>hexo d  &#x2F;&#x2F;部署到Github</p></li></ul></li><li>7 <a href="https://butterfly.js.org/">Butterfly主题官方文档</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;记录关于在Github的Pages上用hexo的模板建设个人网站过程中用到的教程和走的一些坑（windows）&quot;&gt;&lt;a href=&quot;#记录关于在Github的Pages上用hexo的模板建设个人网站过程中用到的教程和走的一些坑（windows）&quot; class=&quot;h</summary>
      
    
    
    
    
    <category term="blog bulid" scheme="https://pengzhanyi.github.io/tags/blog-bulid/"/>
    
  </entry>
  
  <entry>
    <title>java基础语法</title>
    <link href="https://pengzhanyi.github.io/2023/09/17/java-base/"/>
    <id>https://pengzhanyi.github.io/2023/09/17/java-base/</id>
    <published>2023-09-17T11:25:52.000Z</published>
    <updated>2023-09-25T06:31:20.824Z</updated>
    
    <content type="html"><![CDATA[<ul><li><h2 id="JAVA基础1"><a href="#JAVA基础1" class="headerlink" title="JAVA基础1"></a>JAVA基础1</h2></li></ul><h1 id="一-java的重要特点"><a href="#一-java的重要特点" class="headerlink" title="一.java的重要特点"></a>一.java的重要特点</h1><ul><li>1.面向对象(oop)</li><li>2.健壮性。Java的强类型机制，异常处理，垃圾的自动回收是Java程序健壮性的重要保证。</li><li>3.跨平台可移植</li><li>4.解释性语言<blockquote><p>解释性语言如javascript,PHP。编译性语言：C&#x2F;Cpp<br>区别是：解释性语言编译后的代码不能直接被机器执行，需要解释器执行。编译性语言，编译后的代码，可以直接被机器执行。</p></blockquote></li></ul><h1 id="二-第一个java程序"><a href="#二-第一个java程序" class="headerlink" title="二.第一个java程序"></a>二.第一个java程序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">helloworld</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>java程序的生成<ul><li>javac test.java -&gt; 编译java文件生成test.class字节码文件</li><li>java test 本质就是把.class文件加载到jvm运行该文件</li></ul></li></ul><h1 id="三-java基本数据类型"><a href="#三-java基本数据类型" class="headerlink" title="三.java基本数据类型"></a>三.java基本数据类型</h1><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><ul><li>整数类型 <ul><li>byte</li><li>short</li><li>int <ul><li>二进制以0b开头</li><li>八进制以0开头</li><li>十六进制以0X开头</li></ul></li><li>long <blockquote><p>补充：位运算符<br>位运算符： &gt;&gt;，&lt;&lt;，&gt;&gt;&gt;是对数据的二进制进行左移右移操作<br>其中 &gt;&gt; 表示向右移动后以1补上空位<br> 而&gt;&gt;&gt;则表示以0补上空位</p></blockquote></li></ul></li></ul><h4 id="数据的类型转换"><a href="#数据的类型转换" class="headerlink" title="数据的类型转换"></a>数据的类型转换</h4><ul><li>整型,实型,字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算，转换从低级到高级</li><li>short类型和byte类型只要参与运算，结果就会被自动转化成int类型数据<blockquote><p>例：byte num &#x3D; 1 ;<br>  short num2 &#x3D;2 ;<br>  short sum &#x3D; num + num2 ;&#x2F;&#x2F;编译会报错</p></blockquote></li></ul><h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><ul><li>float<ul><li>float类型数据必须在数据后加f或F</li></ul></li><li>double</li></ul><h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><ul><li>java使用Unicode来表示字符，可以表示汉字在内的多种文字<blockquote><p>例 ： char a &#x3D; “\u0041”;  \u表示是Unicode编码,0041是指16进制数<br>     System.out.println(a);<br>     输出结果为：a</p></blockquote></li></ul><h2 id="boolean类："><a href="#boolean类：" class="headerlink" title="boolean类："></a>boolean类：</h2><ul><li>只有true和false两个值，且不能与int值作比较</li><li>布尔类型boolean占有一个字节，由于其本身所代码的特殊含义，<strong>boolean类型与其他基本类型不能进行类型的转换</strong>（既不能进行自动类型的提升，也不能强制类型转换）， 否则，将编译出错。</li></ul><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>每个引用占据32位的内存空间，其值指向对象实际所在的内存中的位置</p><h3 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h3><h4 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h4><ul><li>数组的创建  </li><li>java中用new创建的int数组有初始零值。</li><li>数组的有一固定属性length，为数组长度</li><li>java中的数组变量只是new出的一块连续地址的“管理者”，即只是获得该数组所在地址，而变量之间的赋值是管理权限的赋予，数组变量的比较是判断是否管理同一个数组。   <blockquote><p><strong>数组的赋值在默认情况下是引用传递，赋的值是地址，赋值方式为引用传递</strong></p></blockquote></li><li>复制数组只能将原数组每个元素逐一拷贝给目的数组,<strong>clone函数</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">System.out.println(array.length);</span><br><span class="line"><span class="type">int</span>[] array2 = array;</span><br><span class="line">array2[<span class="number">0</span>]=<span class="number">10</span>;</span><br><span class="line">System.out.println(array[<span class="number">0</span>],array2[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure></li></ul><h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><ul><li>数组的创建 ： int[][] array &#x3D; new int[3][5];<br>  (必须要给出第一个括号中的参数)</li><li>二维数组array.length 是指该二维数组有多少行，array[1].length表示有几列</li></ul><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><ul><li>String是一个类，<strong>String的变量是对象的管理者而非所有者</strong><ul><li>类似数组变量是数组的管理者而非所有者<ul><li>故字符串创建要用new创建一个String对象，用字符串变量来管理这个这个对象<ul><li>String s &#x3D; new String(“helloworld”);</li></ul></li><li>故字符串对象变量的赋值只是让两个字符串变量管理同一个字符串对象</li></ul></li><li>String是不可变字符串<ul><li>指的是变量一旦被赋值，其值不能被改变，如果想改变变量的值，只能将变量引向另一个字符串</li></ul></li></ul></li></ul><h4 id="equals-与-的区别"><a href="#equals-与-的区别" class="headerlink" title="equals 与 &#x3D;&#x3D; 的区别"></a>equals 与 &#x3D;&#x3D; 的区别</h4><ul><li><p>&#x3D;&#x3D; 是比较运算符，而equals是Object类的方法，Java类都可以使用该方法</p></li><li><p>&#x3D;&#x3D; 既可以比较基本类型也可以比较引用类型，但equals()是Object类中的方法，只能判断引用类型</p></li><li><p>变量的 “&#x3D;&#x3D;”引用类型比较，只是判断两个变量是否管理同一个对象（字符串），即判断地址是否相同</p></li><li><p><strong>比较两个String内容是否相等要用String变量的equals()函数比较</strong></p></li><li><p>下面这段代码输出为true是因为Java中有一个字符串常量池（String Pool）的概念，它使得相同的字符串字面量在内存中只会被存储一次，而多个引用都指向同一个字符串对象。在你的代码中，a和b都被初始化为字符串字面量 “hello”，因为它们的内容相同，所以它们实际上引用了同一个字符串对象，而不是创建了两个相同内容的不同字符串对象。因此，使用”&#x3D;&#x3D;”运算符比较它们会返回true，因为它们引用的是同一个对象。这是字符串常量池的优化机制，它可以减少内存使用，并提高字符串比较的效率。如果你想要比较字符串的内容而不是引用，应该使用equals()方法，而不是”&#x3D;&#x3D;运算符  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="type">String</span> <span class="variable">string1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">string2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">System.out.println(string1 == string2);</span><br></pre></td></tr></table></figure></li><li><p>字符串连接</p><ul><li>用 + 可以连接两个字符串<ul><li>“hello”+”world”&#x3D;”helloworld”</li></ul></li><li>当这个 + 的一边是字符串一边不是时，会将另一边表达为字符串然后做连接<ul><li>“age” + 1 + 2 -&gt; “age12”</li></ul></li></ul></li><li><p>字符串输入</p><ul><li>in.next()读入一个单词，单词的标志是空格<ul><li>空格包括空格，tab和换行</li></ul></li><li>in.nextLine() 读入一整行<blockquote><p>访问字符串里的字符<br>用s.charAT(index)函数，返回该字符串上下标为index的字符，不可用FOR-EACH循环来遍历数组变量</p></blockquote></li></ul></li><li><p>当需要对一个字符串做复杂操作时一般用<strong>StringBuffer</strong>类型，<strong>String类型无法对字符串做修改,是不可变的！！！ String类型只是字符串常量</strong></p><ul><li>StringBuffer.append()</li><li>**StringBuffer.toString()**将该类型转化为String类型;</li></ul></li></ul><h1 id="四-java基本语法"><a href="#四-java基本语法" class="headerlink" title="四.java基本语法"></a>四.java基本语法</h1><h2 id="数据的输入："><a href="#数据的输入：" class="headerlink" title="数据的输入："></a>数据的输入：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, World!&quot;</span>);<span class="comment">//println是指在输出结束后加上换行符</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span> (System.in);<span class="comment">//声明了名为in的数据输入扫描仪（Scanner）</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> in.nextInt();<span class="comment">//将输入的下一个int值赋给value变量</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">amount</span> <span class="operator">=</span> <span class="number">0</span>；<span class="comment">//常量定义</span></span><br><span class="line">        System.out.println(<span class="string">&quot;20+&quot;</span> + value + <span class="string">&quot;=&quot;</span> + (<span class="number">20</span>+ + value) );</span><br><span class="line">in.close();<span class="comment">//结束数据流，释放内存</span></span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure><ul><li>也可以Integer i &#x3D; Integer.parseInt(in.next());输入数据<ul><li>in.next()接收的字符串类型</li><li>parseInt()是Integer类型的函数，将字符串识别转化为int<ul><li>与之相对的有<strong>toString()函数</strong>，将其他类型识别为转化为字符串类型</li></ul></li></ul></li></ul><h2 id="循环："><a href="#循环：" class="headerlink" title="循环："></a>循环：</h2><ul><li>while循环</li><li>do-while循环</li><li>for循环</li></ul><h3 id="FOR-EACH循环"><a href="#FOR-EACH循环" class="headerlink" title="FOR-EACH循环"></a>FOR-EACH循环</h3><pre><code>形式：for(&lt;类型&gt; &lt;变量名&gt; ，&lt;数组&gt;)&#123;&#125;</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="type">int</span> k : array)</span><br><span class="line"><span class="comment">/*解读：对于array数组里的每一个元素，循环的一轮依次拿出作为k的值,  </span></span><br><span class="line"><span class="comment">适合用于遍历数组的情况*/</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( k == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;find!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="包裹类型"><a href="#包裹类型" class="headerlink" title="包裹类型"></a>包裹类型</h2><ul><li>每种基础类型都有相对应的包裹类型</li></ul><table><thead><tr><th>基础类型</th><th>包裹类型</th></tr></thead><tbody><tr><td>boolean</td><td>Boolean</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>double</td><td>Double</td></tr></tbody></table><p>包裹类型变量有一些特殊的函数<br>    - 每个包裹类型都有toString方法，用于将该类型变量转化为字符串<br>    - 每个包裹类型也有自己的parse方法，用于将字符串识别转化为该类型的变量</p><blockquote><p>例 ： Integer a &#x3D; 1;<br>System.out.println(a.MAX_VALUE);<br>输出结果为：2147483647<br>类似的还有Interger.parseInt( string, 10)，该函数将字符串作为有符号的十进制整数进行解析</p></blockquote><h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><ul><li>abs 求绝对值</li><li>pow 求幂</li><li>random 提供一个0-1的随机数<ul><li>random.nextInt(bound) 提供一个零到bound的随机int类型数据，包括零但不包括bound<ul><li>一般可以用random.nextInt(array.length)作为下标来做到随机访问数组中的成员</li></ul></li></ul></li><li>round 做四舍五入</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li>不能在一个块内定义块外定义过的变量。（与C语言会隐藏块外同名变量机制不同）</li></ul><h2 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h2><h3 id="IDEA快捷键"><a href="#IDEA快捷键" class="headerlink" title="IDEA快捷键"></a>IDEA快捷键</h3><ul><li>删除当前行， 自己配Ctrl + d</li><li>补全代码 alt + &#x2F;</li><li>导入该行所需的类 Alt + Enter</li><li>生成构造器等 <strong>alt + insert</strong></li><li><strong>查看一个类的层级关系 Ctrl + H</strong></li><li>生成当前类的继承关系图Ctrl + Alt + U</li><li>查看当前类的所有方法和属性 Ctrl + F12</li><li>将光标放在一个方法上，Ctrl + B可以选择定位到哪个类的方法</li><li>.var 可自动分配变量名</li><li>Ctrl + b 跳转到该函数实现处</li></ul><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><ul><li>sout模板快捷键</li><li>fori模板快捷键</li><li>file - 设置- 编辑器-实时模板 里查看java的模板，可以自定义模板增加开发效率</li></ul><h2 id="package"><a href="#package" class="headerlink" title="package"></a>package</h2><h3 id="包的基本语法"><a href="#包的基本语法" class="headerlink" title="包的基本语法"></a>包的基本语法</h3><ul><li>package 包名;</li></ul><h3 id="包的作用"><a href="#包的作用" class="headerlink" title="包的作用"></a>包的作用</h3><ul><li>包的本质就是创建不同的文件夹来保存管理类</li><li>包的名字里可以带有“.”,例如import java.util.Scanner;其中的.（包的名字中的.）实际上表达的就是文件系统中文件夹的层次，java正是同这样的手段来管理类，这就是java的package管理机制。</li><li>可用去区分相同名字的类</li><li><strong>若用到的类与当前所在文件不在一个package中则需要用import package名.类名  来引入这个类</strong>。</li></ul><h3 id="包的导入"><a href="#包的导入" class="headerlink" title="包的导入"></a>包的导入</h3><ul><li>语法： import + 完整包名<ul><li>例 ： import java.util.Scanner 只会引入Scanner</li></ul></li><li>import + 包名. + * <ul><li>引入该类下的所有的类（但不建议使用该方法，<strong>最好根据需求引用相应的类</strong>）</li></ul></li></ul><h3 id="常用包"><a href="#常用包" class="headerlink" title="常用包"></a>常用包</h3><ul><li>java.util&#x2F;&#x2F;系统提供的工具包，包括Scanner</li><li>java.lang &#x2F;&#x2F;lang是基本包，默认引入，不许要再引入</li><li>java.net &#x2F;&#x2F;网络包，做网络开发</li><li>java.awt &#x2F;&#x2F;做java界面开发，GUI</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>package的作用是声明当前类所在的包，需要放在类的最上面，一个类中最多只有一句package</li><li>import指令放在package指令下，在类定义前</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;h2 id=&quot;JAVA基础1&quot;&gt;&lt;a href=&quot;#JAVA基础1&quot; class=&quot;headerlink&quot; title=&quot;JAVA基础1&quot;&gt;&lt;/a&gt;JAVA基础1&lt;/h2&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;一-java的重要特点&quot;&gt;&lt;a href=&quot;#一</summary>
      
    
    
    
    
    <category term="java" scheme="https://pengzhanyi.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>hello blog test</title>
    <link href="https://pengzhanyi.github.io/2023/09/17/hello-blog-test/"/>
    <id>https://pengzhanyi.github.io/2023/09/17/hello-blog-test/</id>
    <published>2023-09-17T01:03:36.000Z</published>
    <updated>2023-09-17T12:41:07.232Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://pengzhanyi.github.io/2023/09/17/hello-world/"/>
    <id>https://pengzhanyi.github.io/2023/09/17/hello-world/</id>
    <published>2023-09-17T00:13:16.062Z</published>
    <updated>2023-09-17T00:13:16.062Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
