<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog | kaori</title>
  
  
  <link href="https://pengzhanyi.github.io/atom.xml" rel="self"/>
  
  <link href="https://pengzhanyi.github.io/"/>
  <updated>2023-09-26T15:04:51.826Z</updated>
  <id>https://pengzhanyi.github.io/</id>
  
  <author>
    <name>zhanyi peng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构</title>
    <link href="https://pengzhanyi.github.io/2023/09/26/data-structure/"/>
    <id>https://pengzhanyi.github.io/2023/09/26/data-structure/</id>
    <published>2023-09-26T14:39:14.000Z</published>
    <updated>2023-09-26T15:04:51.826Z</updated>
    
    
    
    
    
    <category term="408基础" scheme="https://pengzhanyi.github.io/tags/408%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>java基础- 基于面向对象的应用</title>
    <link href="https://pengzhanyi.github.io/2023/09/24/java-base3/"/>
    <id>https://pengzhanyi.github.io/2023/09/24/java-base3/</id>
    <published>2023-09-24T08:50:40.000Z</published>
    <updated>2023-10-19T10:37:16.408Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="枚举和注解"><a href="#枚举和注解" class="headerlink" title="枚举和注解"></a>枚举和注解</h1><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><ul><li><p>基本介绍：</p><ul><li>枚举对应英文enumeration,简写enum</li><li>枚举是一组常量的集合</li><li>可以理解为枚举属于一种特殊的类，<u>里面只包含一组有限的特定的对象</u></li></ul></li><li><p>枚举实现方式</p><ul><li>1 自定义实现枚举</li><li>2 使用enum关键字实现枚举</li></ul></li></ul><h3 id="自定义实现枚举"><a href="#自定义实现枚举" class="headerlink" title="自定义实现枚举"></a>自定义实现枚举</h3><ul><li>自定义枚举类特点<ul><li>构造器私有化</li><li>对枚举对象&#x2F;属性使用final + static 共同修饰，实现底层优化</li><li>不需要提供类属性的set方法，因为枚举对象值通常为只读,可以提供get方法</li><li>对外暴露枚举对象，<u>设置对象为<strong>public static final</strong></u></li><li>枚举对象名通常使用全部大写，常量的命名规范</li><li>枚举对象根据需要，也可以有多个属性</li></ul></li><li>例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">private</span> String desc ;<span class="comment">//描述</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name , String desc)</span>&#123;</span><br><span class="line">        <span class="comment">//构造器设置为私有化防止外部直接实例化</span></span><br><span class="line">        <span class="built_in">this</span>.name = name ;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//去掉set方法防止属性被修改</span></span><br><span class="line">    <span class="comment">//在类内部直接创建固定的对象，public static final</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span> , <span class="string">&quot;温暖&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span> , <span class="string">&quot;炎热&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span> , <span class="string">&quot;凉爽&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span> , <span class="string">&quot;寒冷&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h3 id="enum关键字实现枚举"><a href="#enum关键字实现枚举" class="headerlink" title="enum关键字实现枚举"></a>enum关键字实现枚举</h3><ul><li><p>实现具体过程</p><ul><li>使用关键字enum来代替class</li><li>public static final 对象名 &#x3D; new 枚举类名（参数列表） 定义枚举变量的方式变为直接用  <strong>变量名（参数列表）</strong></li><li>如果有多个常量（对象），使用 ， 间隔即可</li><li>如果<strong>使用enum来实现枚举，要求必须将定义常量对象写在类的最前面</strong></li><li>例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    Season(<span class="string">&quot;春天&quot;</span> , <span class="string">&quot;温暖&quot;</span>) ,SUMMER (<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;炎热&quot;</span>) ,</span><br><span class="line">    AUTUMN (<span class="string">&quot;秋天&quot;</span> , <span class="string">&quot;凉爽&quot;</span>),WINTER  (<span class="string">&quot;冬天&quot;</span> , <span class="string">&quot;寒冷&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">private</span> String desc ;<span class="comment">//描述</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name , String desc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name ;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name + <span class="built_in">this</span>.desc ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>enum关键字实现枚举注意事项     </p><ul><li>简化的定义枚举类变量的方式： 变量名（参数列表） 形式，这里必须知道它调用的是哪个构造器</li><li>当使用无参构造器创建枚举对象，则实参列表和小括号都可以省略</li><li>当有多个枚举对象时，使用 , 间隔，最后一个由分号结尾</li><li>枚举类对象必须放在枚举类的行首</li></ul></li><li><p>补充</p><ul><li><p>输出enum的对象时会调用enum的toString方法，返回该枚举对象名，具体内容可查看Enum类源码 </p></li><li><p>当使用enum关键字定义类时，这个类会默认继承Enum类，所以子类会获得Enum中的各种方法</p><ul><li><p>因为已经默认Enum类，因为java的单继承机制，故枚举类不能再继承别的类，但可以实现接口</p></li><li><p>可以用javap反编译.class文件以显示对应源码中隐藏的细节，通过这种方法来证明，枚举类继承Enum类,而且是一个final类</p><ul><li><img src="/images/java_base3_01.png" alt="img"></li></ul></li><li><p>或在idea中利用Ctrl + Alt + U来查看类的继承关系</p><ul><li><img src="/images/java_base3_02.png" alt="img"></li></ul></li></ul></li><li><p>enum类常用方法</p><ul><li>toString：Enum类已经重写过了，返回当前对象名，子类可以根据需要重写方法</li><li>name ： 返回当前对象名（常量名），是final的方法，子类中不能重写</li><li>ordinal :返回当前对象的位置号，默认从0开始</li><li>values:返回当前枚举类中的所有常量<ul><li>隐藏起来了，在反编译中可以查看到，返回类型为该枚举类的数组</li></ul></li><li>valueOf：返回具有指定名称的指定枚举类型的枚举常量，要求字符串必须为已有的常量名，否则报异常<ul><li>就是在已有的枚举常量对象中寻找，并不会创建新的枚举对象</li></ul></li><li>compareTo ： 比较两个枚举常量，比较的就是位置号 </li><li>例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>) ， SUMMER(<span class="string">&quot;夏天&quot;</span>) ，AUTUMN(<span class="string">&quot;秋天&quot;</span>) ,WINTER(<span class="string">&quot;冬天&quot;</span>);</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showElements</span><span class="params">()</span>&#123;</span><br><span class="line">        Season[] array = Season.values();</span><br><span class="line">        <span class="comment">//使用values方法获得枚举类数组</span></span><br><span class="line">        <span class="keyword">for</span>(Season element : array)&#123;</span><br><span class="line">            System.out.println(element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name + <span class="built_in">this</span>.desc ;</span><br><span class="line">        <span class="comment">//根据需要重写toString方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><ul><li><p>注解介绍</p><ul><li><p>注解（Annotation）也被称为元数据（Metadata），用于修饰解释，包，类，方法，属性，构造器局部变量等数据信息</p></li><li><p>和注释一样，注解不影响程序逻辑，但注解可以被编译运行，相当于嵌入在代码中的补充信息</p></li><li><p>在JavaSE中，，注解的使用目的很简单，例如标记过时的功能，忽略警告等。但在javaEE中，注解很重要，例如用来配置应用程序的任何切面，代替javaEE旧版所一流的繁荣代码和XML配置等</p></li></ul></li><li><p>基本的Annotation介绍：  </p><ul><li>在使用注解时要在其前面增加@符号，并把该Annotation当成一个修饰符使用。用于修饰它支持的程序元素.</li><li><strong>注解的作用在于编译器会根据注解的内容进行语法校验</strong><ul><li>例如若在方法前加上@override，则在编译时，编译器会去检查该方法是否时真的是重写了父类中的函数或实现接口中的函数，若没有，则编译不能通过</li></ul></li></ul></li><li><p>三种基本注解类型</p><ul><li><p>@Override : 限定某个方法，表示重写父类方法，该注释只能用于方法</p><ul><li>@Override表示指定重写父类的方法（从编译层面验证），</li><li>若不写@Override注解，而父类有public的同名同返回类型的方法，仍然构成重写</li><li>@Override只能修饰方法，不能修饰类，包，属性等</li><li>查看@Override的源码为： @Target(ElementType.METHOD)，表示只能修饰方法</li><li>@Target是修饰注解的注解，称为元注解</li></ul></li><li><p>@Deprecated: 用于表示某个程序元素（类，方法）已经过时</p><ul><li>表示该类，方法，元素已过时，不推荐使用，但仍可以使用</li><li>可以做到新旧版本的兼容和过度</li></ul></li><li><p>@SuppressWarnings:抑制编译器警告</p><ul><li>当不希望看到警告时可以用@SuppressWarings</li><li>使用方法： @SuppressWarnings({ “ “}),在其中写入希望抑制的警告信息<ul><li>例：抑制所有警告 @SuppressWarings( { “ all “ } )</li><li>具体的警告类型可以自己查询 ， 例如”unused” , “unchecked”</li><li>@SuppressWarings 范围与放置的位置相关，可以放在类前，方法前等</li></ul></li><li>查看源码，该注解类有字符串数组参数String[] value(),用于输入多个警告信息</li></ul></li></ul></li></ul><blockquote><p>查看Override源码， @interface表示是一个注解，而不是接口</p></blockquote><ul><li><p>元注解<br>JDK的元Annotation用于修饰其他Annotation<br>元注解作用不大，了解即可，可多看源码</p><ul><li>元注解的种类<ul><li><p>Retention &#x2F;&#x2F;指定注解的作用范围，三种 SOURCE，CLASS，RUNTIME</p><ul><li>例如@Override的作用域在SOURCE，当编译器编译时生效，不会写入.class文件，也不会在Runtime（运行时）生效</li></ul></li><li><p>Target &#x2F;&#x2F;指定注解可以在哪些地方使用</p><ul><li>@Override的 @Target(ElementType.METHOD)，只能作用于方法</li><li>@SuppressWarings 的@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE}) ，可作用方法，变量等</li></ul></li><li><p>Document &#x2F;&#x2F;指定注解是否在javadoc中体现</p><ul><li>注解中加入@Documented 表示该注解会被保存在javadoc文档中</li></ul></li><li><p>Inherited &#x2F;&#x2F;子类会继承父类注解</p></li></ul></li></ul></li></ul><h1 id="异常和异常处理"><a href="#异常和异常处理" class="headerlink" title="异常和异常处理"></a>异常和异常处理</h1><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul><li><p>基本概念</p><ul><li>java语言中，将程序执行中发生的不正常情况称为“异常” ，</li><li>注意：开发过程中的语法错误和逻辑错误不是异常</li></ul></li><li><p>执行过程中的异常事件主要分为两类</p><ul><li><p>Error（错误）：java虚拟机无法解决的严重的问题，例如JVM系统内部错误，资源耗尽的严重情况。如StackOverflowError[栈溢出] ，Error是严重错误，程序会崩溃</p></li><li><p>Exception : 其他因编程错误或偶然外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如NullPointerException[空指针访问] 等</p><ul><li>Exception可以分为两大类<ul><li><p><strong>运行时异常</strong> ，程序运行时发生的异常，</p></li><li><p><strong>编译时异常</strong> ， 编译时，编译器检查出的异常</p></li></ul></li></ul></li></ul></li><li><p>异常体系图</p><ul><li><p>下列图中列举一些常见异常的继承关系图</p><ul><li>注，绿色虚线代表实现接口，蓝色实线代表类的继承</li></ul></li><li><p><img src="/images/java_base3_04.png" alt="img"></p></li><li><p>总结 ：</p><ul><li><p>异常分为两大类，运行时异常和编译时异常</p></li><li><p>运行时异常，编译器不要求强制处理的异常。一般是指编程时的逻辑错误，程序员应该避免其出现的异常。java.lang.RuntimeException类及他的子类都是运行时异常</p></li><li><p>编译时异常是编译器要求必须处理的异常，Exception中除了RuntimeException和其子类，其余都是编译时异常</p></li></ul></li></ul></li></ul><h3 id="简单的异常捕获机制try-catch"><a href="#简单的异常捕获机制try-catch" class="headerlink" title="简单的异常捕获机制try-catch"></a>简单的异常捕获机制try-catch</h3><ul><li><p>对异常进行捕获，保证程序在遇到异常仍可以继续运行，不会直接崩溃，保证程序健壮性</p></li><li><p>当程序员认为一段代码可能出现异常时，可以用try-catch异常处理机制来解决问题</p></li><li><p>try-catch异常处理机制</p><ul><li><p>语法：  </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;<span class="comment">/*可能产生异常的代码*/</span>&#125;</span><br><span class="line">    <span class="keyword">catch</span>(Typel id1)</span><br><span class="line">    &#123;<span class="comment">/*处理Typel异常的代码*/</span>&#125;</span><br><span class="line">    <span class="keyword">catch</span>(Type2 id1)</span><br><span class="line">    &#123;/处理Type2异常的代码*/&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>在idea中，选中代码块， 快捷键 Ctrl + Alt + t ， 选中try - catch</strong></p></li><li><p>示例：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num3</span> <span class="operator">=</span> num1 / num2 ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception e)</span><br><span class="line">    &#123;<span class="comment">/*处理Typel异常的代码*/</span></span><br><span class="line">        e.printStackTrace();<span class="comment">//打印异常相关信息</span></span><br><span class="line">        System.out.println(e.getMessage);<span class="comment">//打印出现异常的原因</span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="常见的运行时异常"><a href="#常见的运行时异常" class="headerlink" title="常见的运行时异常"></a>常见的运行时异常</h3><ul><li><p>NullPointerException空指针异常</p><ul><li>当应用程序试图在需要对象的地方使用NULL时，抛出该异常</li><li>例: <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object[] array = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">10</span>];</span><br><span class="line">System.out.println(array[<span class="number">1</span>].getClass());</span><br><span class="line"><span class="comment">//创建对象数组时，记得要将数组内每个对象引用都初始化指向实例对象</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>ArithmeticException数学运算异常</p><ul><li>当出现异常的运算条件时，抛出此异常，如将一个整数除以零</li></ul></li><li><p>ArrayIndexOutOfBoundsException数组下标越界异常</p><ul><li>用非法索引访问数组时抛出的异常，如果索引为负或大于等于数组大小，则该索引为非法索引</li></ul></li><li><p>ClassCastException类型转换异常</p><ul><li>当试图将对象强制转换为不是实例的子类时，抛出该异常</li><li>例  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="comment">//main方法中：</span></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> (B) a ;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>NumberFormatException数字格式不正常异常</p><ul><li>当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当形式时，抛出该异常，使用时可以确保我们输入满足条件的字符串</li><li>例 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">test</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span> ;</span><br><span class="line">        Integer.parseInt(test);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="编译异常"><a href="#编译异常" class="headerlink" title="编译异常"></a>编译异常</h3><ul><li><p>概念 ：编译异常是指在编译期间就必须处理的异常，否则代码不能通过编译</p></li><li><p>常见的编译异常：</p><ul><li>SQLException ：操纵数据库时，查询表可能发生异常</li><li>IOEException：操纵文件时繁盛的异常</li><li>FileNotFound：当操纵一个不存在的文件时，发生异常</li><li>ClassNotFoundException：加载类时而该类不存在时，异常</li><li>EOFException : 操纵文件，到文件末尾时，发生异常</li><li>IIIegalArgumentException:参数异常</li></ul></li></ul><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><ul><li><p>基本介绍：<br>异常处理就是当异常发生时，对异常处理的方式</p></li><li><p>异常处理的方式：  </p><ul><li>try-catch-finally</li><li>throws</li></ul></li></ul><h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h3><p>用于程序员捕获在代码中发生异常，自行处理</p><ul><li><p>语法：   </p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//可能有异常的代码</span></span><br><span class="line"><span class="comment">//当异常发生时将异常封装成Exception对象,传递给catch </span></span><br><span class="line">&#125;   </span><br><span class="line"><span class="keyword">catch</span> (Type id) &#123; <span class="comment">//这里的Type是指异常的类，可以根据需要填入不同的异常类   </span></span><br><span class="line"><span class="comment">// 得到异常对象后，处理异常 handle exception ，未发现异常则不执行catch中代码 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;    </span><br><span class="line"><span class="comment">//不管是否发现异常，必须执行finally内的代码块，故通常将释放资源的代码放再finally中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意事项：</p><ul><li><p><u>如果异常发生了，则异常后的代码不会执行，直接进入到catch块</u></p></li><li><p><u>如果异常没有发生，则顺序执行try的代码，不会进入到catch块</u></p></li><li><p>如果希望不管是否发生异常，都执行某段代码块（比如关闭连接，释放资源等）则使用finally</p><ul><li>即使在catch中执行了 return 语句结束 ，finally中的代码仍会执行</li><li>只有当在catch中执行了System.exit(0) ，关闭了jvm，则任何代码都不再执行</li></ul></li><li><p>可以有多个catch语句，捕获不同的异常（针对不同的异常进行不同的业务处理）</p><ul><li><strong>如果发生异常只会匹配一个catch</strong></li><li><strong>要求父类异常在前，子类异常在后</strong>，比如Exception在后，NullPointerException在前）<ul><li>因为父类异常在前，父类exception会捕获所有的子类异常，具体的子类异常处理语句永远无法到达</li></ul></li><li>例：                 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">0</span> ;</span><br><span class="line">&#125; <span class="keyword">catch</span>(NullPointerException e)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是空指针异常&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(ArithmeticException e)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是算数异常&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(RuntimeException e)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;这是运行时异常&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;<span class="comment">//Exception是所有异常的父类</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>可以进行try-finally配合使用，这种用法<strong>相当于没有捕获异常，因此程序会直接崩掉</strong>。</p><ul><li>应用场景是执行一段代码，不管是否发生异常都必须执行某个业务逻辑，执行完finally内的语句后程序会崩掉</li></ul></li></ul></li></ul><h3 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h3><p> 将发生的异常抛出，交给调用者（方法）来处理，最顶级的处理者就是JVM</p><ul><li><p>基本介绍：</p><ul><li>如果一个方法中可能存在某种异常，但是并不能确定如何处理这种异常，则此方法声明应该显示地声明抛出异常，表明方法将不对这些异常进行处理，而<strong>由该方法的调用者负责</strong><ul><li>在方法声明中用throws语句可以声明抛出异常的列表，即抛出多个异常</li><li>throws后面的异常类型可以是方法中产生的具体异常类型，也可以是该异常类型的父类</li></ul></li></ul></li><li><p>基本语法 ：<br>  方法修饰符 + 方法名（） + throws + 该函数中出现的异常{}</p><ul><li>例：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Func</span> <span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">    <span class="comment">//这里可以直接抛出具体的异常，也可以是该异常的父类Exception</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;C:// aa.txt&quot;</span>);</span><br><span class="line">&#125;<span class="comment">//使用throws，抛出异常，让调用Func方法的调用者处理</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>throws使用细节</p><ul><li><p>对于编译异常，程序中必须处理，如try-catch或throws</p></li><li><p><strong>对于运行时异常</strong>，程序中如果没有处理，<u>默认就是throws的方式处理</u></p><ul><li>运行时异常可以不处理，java不强制要求处理，因为运行时异常有默认处理机制</li></ul></li><li><p>在throws过程中，如果有方法 try-catch ，就相当于处理，就可以不必throws</p></li><li><p>子类重写父类方法时，对抛出的异常的规定：子类重写的方法，所抛出的异常类型要么和父类抛出的异常一致，要么为父类抛出的异常的类型的子类型 </p><ul><li><p>即<strong>子类重写的抛出的异常的类型范围不能大于父类异常</strong> </p></li><li><p>父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出</p></li><li><p>例</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;<span class="comment">//发生编译错误</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Father</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            a.method();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RunTimeException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> <span class="keyword">throws</span> RuntimeException&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解析：</p><ul><li>1 因为java的多态机制，在main方法中a.method()实际会调用Son中重写的method()方法</li><li>2 实际在try-catch中时针对父类的method方法做出的捕获，实际却调用子类的method方法，子类重写的方法抛出的异常是Exception，显然用于捕获父类异常的RunTimeException无法捕获该异常，可能会导致不可预测的错误</li><li>3 故在java中，子类重写父类的方法时，子类如果选择抛出异常，那么抛出的异常类型不能大于父类的异常类型</li></ul></li><li><p>这是遵循了java异常处理的多态性原则，确保在子类中重写的方法不会引入比父类更多的异常情况，以确保代码的稳定性和一致性</p></li></ul></li></ul></li></ul><blockquote><p>发生异常时以上两种方案二选一就可，要么在当前函数使用try-catch-finally处理异常，要么继续将异常抛出给调用当前函数的函数让其处理<br>    - 最顶级的异常处理<strong>JVM处理异常的方式是直接输出异常信息，退出程序</strong><br>    - 若无显示处理运行时异常，程序默认采用throws方法</p></blockquote><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><ul><li><p>自定义异常步骤：</p><ul><li>1 定义类： 自定义异常类名 ，继承Exception或RuntimeException</li><li>2 如果继承Exception，一般来说属于编译异常</li><li>3 如果继承RuntimeException ， 属于运行异常（一般来说，继承RuntimeException）  <ul><li>即把自定义异常做成运行时异常，好处在于可以使用运行时异常的默认处理机制</li></ul></li></ul></li><li><p>自定义异常使用实例：</p><ul><li>要求输入一个大于0，小于120的数字，否则抛出异常</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="title function_">MyException</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="comment">//这里的message参数是指该异常相关信息</span></span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="comment">//无参构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main方法中</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">180</span> ;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(num &gt; <span class="number">0</span> &amp;&amp; num &lt; <span class="number">120</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;错啦，数字输入不对&quot;</span>) ;</span><br><span class="line">            <span class="comment">//这里相当于创建一个MyException的匿名对象</span></span><br><span class="line">            <span class="comment">//通过 throw 将异常抛出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>throw 和 throws 的区别</strong></p></li></ul><table><thead><tr><th></th><th>意义</th><th>位置</th><th>后面跟的东西</th></tr></thead><tbody><tr><td>throws</td><td>异常处理的一种方式</td><td>方法声明处</td><td>异常类型</td></tr><tr><td>throw</td><td>是手动生成异常对象的关键字</td><td>方法体中</td><td>异常对象</td></tr></tbody></table><h1 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h1><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><ul><li><p>包装类的分类(Wrapper)</p><ul><li>针对八种基本定义类型的引用类型——包装类</li><li>有了类的特点就可以调用类中的方法  </li><li>包装类都是Object类的子类，实现了Serializable接口，部分实现了Compareable接口</li></ul></li><li><p>基本包装类：</p><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>booelan</td><td>Boolean</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr></tbody></table></li><li><p>包装类与基本数据类型的区别（以int和Integer为例）</p><ul><li>数据类型不同 ，int是基础数据类型，而Integer是包装数据类型</li><li>默认值不同：int的默认值是0，而Integer的默认值是null<ul><li>包装类类型未付初值时的null值，更好表示出该变量当前状态</li></ul></li><li>内存中的储存方式不同：<ul><li>int 在内存中直接储存的是数据值</li><li>Integer实际存储的是对象引用，当new一个Integer时实际上是生成一个指针指向此对象</li></ul></li><li>实例化方式不同：Integer必须实例化才可以使用，而int不需要</li><li>变量的比较方式不同<ul><li>int可以直接用 &#x3D;&#x3D; 来比较两个变量是否相等</li><li>Integer是引用类型 ，必须要用equals来比较两个变量值是否相等，<ul><li>（因为常量池的存在数值在-128-127 之间的Integer对象可以用 &#x3D;&#x3D; 来比较，但超出这个范围就不行）</li></ul></li></ul></li></ul></li><li><p>包装类和基本数据的转换</p><ul><li><p>手动装箱和拆箱演示：以int与Integer转化为例</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"><span class="comment">//基本类型——&gt;包装类型[手动装箱]</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> Integer.valueOf(i);<span class="comment">//包装类内置static函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//包装类型——&gt;基本类型[手动拆箱]</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">99</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">j1</span> <span class="operator">=</span> j.intValue() ;</span><br></pre></td></tr></table></figure></li><li><p>自动装箱（JDK5以后）：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">M</span> <span class="operator">=</span> m ;<span class="comment">//自动装箱，底层是使用valueOf()方法，</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2</span>);<span class="comment">//自动拆箱,底层是使用inValue()方法</span></span><br></pre></td></tr></table></figure></li><li><p>例题：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="literal">true</span> ? <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>) : <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">2.0</span>) ;</span><br><span class="line">System.out.println(obj1) ;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意,此处输出为 1.0 ,并不是 1 。</strong>，根据 Java 语言规范，在这种情况下，需要进行类型转换以使得两个表达式具有相同的类型。Integer 和 Double 是不同的类型。在三元运算符中，为了满足类型一致性的要求，会发生自动类型提升，Integer 会自动转换为更高精度的类型 Double。因此，即使条件为 true，返回的值是 Integer(1)，但最终结果会被自动转换为 Double 类型。因此，最终的输出结果是 1.0 而不是 1。</p></blockquote></li></ul></li><li><p>包装类和String类型的相互转换</p><ul><li><p>包装类转String：（以Integer的转换为例）</p><ul><li>实例：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"><span class="comment">//方案一:字符串拼接</span></span><br><span class="line"><span class="type">String</span> <span class="variable">string1</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span> + num;</span><br><span class="line"><span class="comment">//方案二：调用toString()方法 </span></span><br><span class="line"><span class="type">String</span> <span class="variable">string2</span> <span class="operator">=</span> num.toString();</span><br><span class="line"><span class="comment">//方案三:使用valueOf()方法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">string3</span> <span class="operator">=</span> String.valueOf(num);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>String转包装类：（以Integer的转换为例）</p><ul><li>实例：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span> ;</span><br><span class="line"><span class="comment">//方案一：使用包装类的parse函数</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">num1</span> <span class="operator">=</span> Integer.parseInt(string);<span class="comment">//此处也会发生自动装箱</span></span><br><span class="line"><span class="comment">//方案二：构造器,包装类有多个构造器，可按需调用</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(string);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>一些常用的包装类方法和属性</p><ul><li>继承Number类的数字相关包装类的MaxValue和MinValue值;</li><li>Character.isDigit()判断是不是字母 <ul><li>isLetter(),判断是不是字母</li><li>isUppercase()判断是不是大写字母 </li><li>isLowercase()判断是不是小写字母</li><li>toUppercase()转换成大写字母 </li><li>toLowercase()转换成小写字母</li></ul></li></ul></li><li><p>经典例题：Integer的创建方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>) ;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>) ;</span><br><span class="line">System.out.println( a == b) ;</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line">System.out.println( c == d );</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">e</span> <span class="operator">=</span> <span class="number">128</span> ;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">128</span> ;</span><br><span class="line">System.out.println( e == f );</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">128</span> ;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">128</span> ;</span><br><span class="line">System.out.println( x == y );</span><br></pre></td></tr></table></figure></li><li><p>第一处对比会输出false，因为创建了两个不同的对象，a,b引用指向不同对象</p></li><li><p>第二处对比会输出true；</p><ul><li>底层自动装包会使用valueOf()方法</li><li>查看valueOf()底层源码，发现在值在-127 - 128 时，会从对象数组中直接返回对象，在值不在该范围时才会创建新的对象</li><li>源码分析：IntegerCache是Integer的一个内部类，其中有静态属性cache，是一个Integer类型数组，里面保存了值为-127-128的Integer对象，  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>故此处两个对象引用指向同一个对象，输出true</li></ul></li><li><p>第三处对比会输出false，结合上文介绍，因为128不在设定范围内 故此处会创建两个不同对象。</p></li><li><p>第四处输出true，<u>只要有基本数据类型，判断的是值是否相等</u>，此处会把包装类自动拆箱。</p></li><li><p>具体内容可查看源码或debug跟踪到底层代码</p></li></ul><h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><ul><li><a href="https://www.cnblogs.com/xiuzhublog/p/12823838.html">String类详解文章</a></li></ul><h3 id="String-基础"><a href="#String-基础" class="headerlink" title="String 基础"></a>String 基础</h3><ul><li>String类基本介绍<ul><li><p>String对象用于保存字符串，也就是一组字符序列</p><ul><li>String类实现了Serialzable接口，Comparable接口，CharSequeance接口</li><li>实现了Serialzable接口，说明该类可以串行化，该类对象可以在网络上传输</li><li>实现了Comparable接口，说明该类实现了compareTo方法，该类对象之间可以相互比较大小</li></ul></li><li><p>字符串是不可变的。一个字符串对象一旦被分配，其内容是不可变的</p></li><li><p>字符串字符使用Unicode字符编码，<u>一个字符占两个字节</u></p></li><li><p>String 类常用构造器</p><ul><li>new String()</li><li>new String(String original)</li><li>new String(char a[])</li><li>new String(byte[] b)</li></ul></li><li><p>String 类是final的类，不可被继承</p></li><li><p>String中有属性：private final char value[]，用于存放字符串内容</p><ul><li>这个value数组是final类型 ， 赋值后就不能再修改，即value作为引用的存放的地址不能修改, 也即是value的指向不能再修改 </li><li>可查看源码了解</li></ul></li></ul></li></ul><h3 id="String创建机制"><a href="#String创建机制" class="headerlink" title="String创建机制"></a>String创建机制</h3><ul><li><strong>创建String对象的两种方式</strong><ul><li><p>一 .直接赋值 String s &#x3D; “hello” ;</p><ul><li>使用直接赋值时 ，会先从常量池查看是否已有”hello”的数据空间，如果有则直接指向该位置 ； 若是没有则在常量池中重新创建，然后指向常量池中该数据位置，故s最终指向仍是常量池的空间</li></ul></li><li><p>二 .调用构造器 String s &#x3D; new String(“abc”);</p><ul><li><p>这个过程中生成一个或两个对象，取决于常量池是否有该字符串</p></li><li><p><a href="https://cloud.tencent.com/developer/article/1686226">相关解析</a></p></li><li><p>Object类中对String的解释：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(String original)</span> &#123;<span class="number">3</span></span><br><span class="line">    <span class="built_in">this</span>.value = original.value;<span class="comment">//只是引用的传递，并没有在堆中开辟新的空间</span></span><br><span class="line">    <span class="built_in">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么不再在字符串常量池创建该字符串对象，在堆中创建String对象，让栈中的String引用变量s管理该String对象，然后堆中String的属性value指向常量池中的内容</p></li><li><p>如果用String创建的字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中，然后进行如上操作。</p></li><li><p>s最终指向是堆中的空间，(是指向堆中创建的String对象,String对象中的value指向常量池中的数据)</p><ul><li>故如果new两个String &#x3D; “hello”,则两个String的value数组引用中存放的地址相同，即都是常量池中的“hello”。</li></ul></li><li><p><img src="/images/java_base3_05.png" alt="img"></p></li></ul></li><li><p>补充：String的intern()函数</p><ul><li><p>当调用intern方法时，如果池已经包含一个等于此String对象的字符串（用equals(Object)方法确定），则返回来自池的字符串。否则，此String对象将添加到池中，并返回对此String对象的引用</p></li><li><p>即intern()方法最终是返回在常量池中的地址</p></li><li><p>相关实例：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(a == b);<span class="comment">//T</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>) ;</span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(c == d);<span class="comment">//F</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(a == d.intern());<span class="comment">//T</span></span><br><span class="line">System.out.println(c == d.intern());<span class="comment">//F</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>创建字符串对象例题分析：</p><ul><li><p>String a &#x3D; “hello” + “abc”;</p><ul><li>这个过程中创建了一个对象</li><li>编译器会做优化，判断创建的常量池对象是否有引用指向</li><li>故最终优化为String a &#x3D; “helloabc”；</li></ul></li><li><p>String str &#x3D; “hello” + new String(“abc”);</p><ul><li><p>debug跟踪步骤 </p><ul><li>创建一个StringBulider sb &#x3D; new StringBulider();</li><li>执行sb.append(“hello”);</li><li>执行sb.append(“abc”);</li><li>调用sb.toString()<ul><li>这个过程中是创建了新的String对象，以“helloabc”初始化;</li><li>StringBulider的toString方法：返回一个在堆中创建的String对象  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Create a copy, don&#x27;t share the array</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(value, <span class="number">0</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在常量池中创建“helloabc”</li><li>将该String对象返回给c</li></ul></li></ul></li><li><p>这个过程创建了五个对象</p><ul><li><p>常量池中“hello”</p></li><li><p>常量池中“abc”</p></li><li><p>new String(“abc”)匿名对象</p></li><li><p>StringBulider对象sb，用于拼接字符串</p></li><li><p>一个字符串对象，指向堆中的helloabc，交给str管理</p><ul><li>注：StringBuilder内部是可变的字符数组，因为可变，故其不会存放在常量池中，而是在堆中某位置。</li></ul></li></ul></li></ul></li><li><p>总结：</p><ul><li>String c &#x3D; “hello” + “abc”常量相加，c直接指向池</li><li>String c &#x3D; a + b;变量相加， c会指向在堆中创建的String对象</li><li>StringBuilder，StringBuffer等创建的可变字符序列不会放在常量池中</li></ul></li><li><p>补充：</p><ul><li>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</li><li>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码</li></ul></li></ul></li></ul></li></ul><h3 id="String类常用方法"><a href="#String类常用方法" class="headerlink" title="String类常用方法"></a>String类常用方法</h3><p> String类只能保存字符串常量，每次更新都需要重新开辟空间，效率低，因此java设计者还提供了StringBuffer和StringBuider，注意对字符串操作后返回的是全新的字符串，对原字符串没有任何影响</p><ul><li><p>length ,获取字符的个数，字符串长度</p></li><li><p>equals(),判断内容是否相等，区分大小写</p></li><li><p>equalsIgnoreCase(),忽略大小写判断内容是否相等</p></li><li><p>indexOf() ,获取字符在字符串中第一次出现的位置索引，索引从零开始，如果没找到，返回-1</p></li><li><p>lastIndexOf(),获取字符在字符串中最后一次出现的索引，如果没找到，返回-1</p></li><li><p>substring()，截取指定范围的子串</p></li><li><p>trim()，截取前后空格</p></li><li><p>spilt() , 以参数字符串作为标准分割字符串，返回一个字符串数组</p></li><li><p>charAt:获取某索引出的字符，注意不能使用Str[index]这种方式取出字符串的字符</p></li><li><p>format：作为输出的模板</p><ul><li>例：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> String.format(<span class="string">&quot;姓名是%s , 体重是 %.2f&quot;</span>,<span class="string">&quot;hello&quot;</span> , <span class="number">12.012</span>);</span><br><span class="line">System.out.println(info);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> <span class="string">&quot;姓名是%s , 体重是 %.2f&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">info2</span> <span class="operator">=</span> String.format(d , <span class="string">&quot;hello&quot;</span> , <span class="number">12.012</span> )</span><br><span class="line"></span><br><span class="line">System.out.println(info2);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>还有很多字符串函数，根据需要查询</p></li></ul><h2 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h2><ul><li><p>基本介绍</p><ul><li><p>特性</p><ul><li><p>java.lang.StringBuffer代表可变的字符序列，可以对字符串内容进行增删</p></li><li><p>很多方法与String相同，但StringBuffer是可变长度的</p></li><li><p>StringBuffer是一个容器</p></li></ul></li><li><p>结构剖析</p><ul><li><p>StringBuffer的直接父类是 <u>抽象类AbstractStringBuilder</u></p><ul><li>父类中有属性，char[] value ,用于存放字符串内容，因为不是final的，故该value字符数组存放在堆中</li></ul></li><li><p>StringBuffer实现了Serializable接口，即可以串行化</p></li></ul></li><li><p>StringBuffer的构造器</p><ul><li><p>StringBuffer()&#x2F;&#x2F;查看源码发现创建一个长度为16的字符数组 用于存放字符内容</p></li><li><p>StringBuffer(int capacity)&#x2F;&#x2F;创建长度为capacity的字符数组</p></li><li><p>StringBuffer(String str)&#x2F;&#x2F;以str初始化字符数组，创建长度为str.length + 16 的字符数组</p></li><li><p>StringBuffer(CharSequence seq)&#x2F;&#x2F;构造一个字符串缓冲区，它包含与指定的CharSequence相同的字符</p></li></ul></li><li><p>String 与StringBuffer类对比</p><ul><li><p>String保存的是字符串常量，里面的值不能更改，每次String类的更新实际上就是更改地址，效率叫低&#x2F;&#x2F;private final char value[]</p></li><li><p>StringBuffer保存的是字符串常量，里面的值可以更改，每次StringBuffer的更新实际上可以更新内容，不用每次创建新的对象并更新地址，效率高&#x2F;&#x2F;char[] value放在堆中</p></li></ul></li><li><p>String与StringBuffer类的相互转换</p><ul><li><p>String -&gt; StringBuffer</p><ul><li><p>1 使用StringBuffer的构造器：new StringBuffer(str)</p></li><li><p>2 先创建一个空的StringBuffer对象，再使用其提供的append函数将字符串添加近这个对象中</p></li></ul></li><li><p>StringBuffer-&gt; String</p><ul><li><p>1 使用StringBuffer提供的toString()方法</p></li><li><p>2 使用String的构造器在，new String(stringBuffer)</p></li></ul></li></ul></li></ul></li><li><p>StringBuffer常用方法</p><ul><li><p>增： append() &#x2F;&#x2F;有多个append方法，</p></li><li><p>删 delete(start , end) &#x2F;&#x2F;</p></li><li><p>查 indexOf() &#x2F;&#x2F;查找字串在字符串第一次出现的索引如果找不到返回 -1</p></li><li><p>改 replace(start ， end , string) &#x2F;&#x2F;将start-end中的内容替换掉，<u>且不含end</u></p></li><li><p>插入 insert()</p></li><li><p>获取长度length</p></li></ul></li><li><p>实例分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">sb.append(str);</span><br><span class="line">System.out.println(sb.length());<span class="comment">//结果为4</span></span><br><span class="line"><span class="comment">//debug跟踪查看源码，底层用到是AbstractStringBuilder的appendNull方法，将null转化为字符串&quot;null&quot;加入字符串中</span></span><br><span class="line"></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(str);</span><br><span class="line"><span class="comment">//此处调用StringBuffer(String str)构造器，底层会调用str.length ,此处会直接发生异常，抛出NullpointerException</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h2><ul><li><p>基本介绍 </p><ul><li><p>StringBuilder是个可变的的字符序列，此类提供一个与StringBuffer兼容的API，但不保证同步(StringBuilder不是线程安全的)。</p></li><li><p>该类被设计用作StringBuffer的一个简易替换，<strong>用在字符串缓冲区被单个线程使用的时候</strong></p></li><li><p>如果可能，建议优先采用该类，在大多数实现中，它比StringBuffer要快</p></li><li><p>在StringBuilder上的主要操作的是append和insert方法，重载的这些方法可以接受很多类型的数据作为参数</p></li></ul></li><li><p>结构剖析</p><ul><li><p>StringBuilder是final的 ， 不能被继承</p></li><li><p>StringBuilder继承了AbstractStringBuilder属性char value[],对象的字符序列内容存到该value，故也是存放在堆中</p></li><li><p>实现了Serializable接口，说明StringBuilder的对象可以串行化（对象可以网络传输，可以保存到文件）</p></li><li><p>StringBuilder的方法没有做互斥的处理，即没有synchronized关键字，因此最好只在单线程情况下使用StringBuilder</p></li></ul></li><li><p>常用方法：与StringBuffer的方法相近，不在赘述，根据需要查看源码和API文档</p></li></ul><h2 id="String-，-StringBuffer-，-StringBuilder比较"><a href="#String-，-StringBuffer-，-StringBuilder比较" class="headerlink" title="String ， StringBuffer ， StringBuilder比较"></a>String ， StringBuffer ， StringBuilder比较</h2><ul><li><p>String，StringBuilder，StringBuffer非常类似，均代表字符序列，而且方法也大都一样</p><ul><li><p>String：不可变字符序列，效率低，但是也因其不可变特性，使之非常安全且复用率高。</p></li><li><p>StringBuffer:可变字符序列，效率较高（增删），是线程安全的（StringBuffer的方法大都使用了synchronized同步）</p></li><li><p>StringBuilder：可变字符序列，效率最高，但是<u>线程不安全</u></p></li></ul></li><li><p><strong>效率：StringBulider &gt; StringBuffer &gt; String</strong></p><ul><li>验证：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> <span class="number">0L</span> ;</span><br><span class="line">    <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> <span class="number">0L</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span>  <span class="operator">=</span> <span class="string">&quot; &quot;</span>;</span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">70000</span> ; i++)&#123;</span><br><span class="line">        str = str + <span class="string">&quot;i&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    endTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;String的运行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(str);</span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">70000</span> ; i++)&#123;</span><br><span class="line">        sb.append(<span class="string">&#x27;i&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    endTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;StringBuffer的运行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sbd</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">70000</span> ; i++)&#123;</span><br><span class="line">        sbd.append(<span class="string">&#x27;i&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    endTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;StringBuilder的运行时间：&quot;</span> + (endTime - startTime));</span><br></pre></td></tr></table></figure></li></ul></li><li><p>String使用注意：</p><ul><li>String s &#x3D; “a” ; s +&#x3D; “b”; 实际上原来的”a”字符对象已经丢弃了，现在有创建了一个新的字符串”ab”</li><li>如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率，如果这样的操作放到循环中会极大影响程序的性能</li><li>故如果要对字符串做大量修改，不要使用String</li></ul></li><li><p>结论：</p><ul><li>如果字符串存在大量修改操作，用StringBuilder或StringBuffer</li><li>如果字符串存在大量修改操作且在单线程情况下，用StringBuilder</li><li>如果字符串存在大量修改操作且在多线程情况下，用StringBuffer</li><li>如果字符串很少修改，且被多个对象引用，使用String，比如配置信息等</li></ul></li></ul><h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><ul><li><p>Math的主要运用是其中的static方法，具体用法可根据需要查询API文档或查看源码</p><ul><li><p>abs（求绝对值）</p></li><li><p>pow（求幂）</p></li><li><p>ceil（向上取整）</p></li><li><p>floor（向下取整）</p></li><li><p>round（四舍五入）</p></li><li><p>sqrt（求开方）</p></li><li><p>random（返回一个0-1之间的随机数，<u>包括0但不包括1</u>）</p><ul><li>例：获取a - b 之间的一个随机数</li><li>(int)(a + Math.random() * (b - a + 1 ) )</li></ul></li><li><p>补充：Random类：</p><ul><li><p>在java.util包中有一个Random类，它可以在指定的取值范围内随机产生数字</p></li><li><p>构造方法：</p><ul><li>Random() ,无参构造器用于创建一个伪随机数生成器，通过它创建的Random实例对象每次使用的种子是随机的（实际上系统会以当前时间戳作为种子）</li><li>Random(long seed),构造方法使用一个long型的seed种子创建伪随机数生成器</li></ul></li><li><p>特点： 当创建Random类的实例对象时，如果指定了相同的种子，则每个实例对象产生的随机数具有相同的序列</p></li><li><p>Random类常用方法：</p><ul><li>boolean newBoolean() 随机生成boolean类型的随机数</li><li>double nextDouble() 随机生成double类型的随机数</li><li>int nextInt() 随机生成int类型的随机数</li><li>int nextInt(int n ) 随机生成 0 ~ n之间的int类型的随机数（<strong>包括0，不包括n</strong>）</li></ul></li></ul></li></ul></li></ul><h2 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h2><ul><li><p>Arrays中包含了一系列静态方法，用于管理或操作数组（比如排序和搜索）</p><ul><li><p>toString()返回数组的字符串形式</p><ul><li>Arrays.toString(arr);</li></ul></li><li><p>sort()排序 （自然排序和定制排序）</p><ul><li><p>因为数组是引用类型，通过数组排序后会直接影响到实参</p></li><li><p>sort是重载的，可以通过传入接口Comparator实现定制排序</p></li><li><p>自然排序：</p><ul><li><p>若是调用Arrays.sort()没有传入Comparator对象指定排序方法，就会调用其内部的自然排序方法</p></li><li><p>源码实现</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NaturalOrder</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Object&gt; &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object first, Object second)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((Comparable&lt;Object&gt;)first).compareTo(second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">NaturalOrder</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NaturalOrder</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>分析源码，</p><ul><li><p>这里在Arrays类内部创建了一个NaturalOrder内部类，实现了Comparator接口，重写compare函数，并在内部提供了一个返回NaturalOrder对象的静态方法</p></li><li><p>注意这里会将传入的Object对象first强转为Comparable类对象,并会动态调用first的运行类型的CompareTo()方法，若是传入的是自定义的类，这个类若是没有实现Comparable接口则会发生.ClassCastException</p></li><li><p>例：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="type">int</span> num ;<span class="comment">//为了简化代码这里设置为public</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.num = num ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main中：</span></span><br><span class="line">Car[] cars = <span class="keyword">new</span> <span class="title class_">Car</span>[<span class="number">3</span>];</span><br><span class="line">cars[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="number">1</span>) ;</span><br><span class="line">cars[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="number">2</span>) ;</span><br><span class="line">cars[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="number">3</span>) ;</span><br><span class="line">Arrays.sort(cars);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>可定制排序方法，传入实例化的Comparator接口的匿名对象&#x2F;&#x2F;482节,484</p><ul><li><p>public static <T> void sort(T[] a, Comparator&lt;? super T&gt; c)</p></li><li><p>涉及接口编程，匿名内部类，动态绑定&#x2F;&#x2F;具体在hspjava481节</p></li><li><p>注意compare方法返回值是int类型</p></li><li><p>例：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr , Comparator c)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; arr.length ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; arr.length - i - <span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c.compare(arr[j] , arr[ j + <span class="number">1</span> ]) &gt; <span class="number">0</span> )&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j] ;</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>] ;</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main中：</span></span><br><span class="line">Integer[] arr = &#123; <span class="number">1</span> , <span class="number">3</span> , <span class="number">2</span> , <span class="number">4</span> &#125;;</span><br><span class="line">bubbleSort(arr, <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((Integer) o1) - ((Integer) o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//或直接利用Arrays.sort(),但只能接受Obeject类的数组</span></span><br><span class="line">Arrays.sort(arr, <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((Integer) o1) - ((Integer) o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(Arrays.toString( arr ) );</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>binarySearch 通过二分搜索进行查找，要求必须排好序</p><ul><li>如果数组中不存在该元素会返回 (-1)*（ 该元素应该在的位置下标 + 1 ）</li><li>细节查看源码，或查看483节</li></ul></li><li><p>copyof(&lt;&gt;[] array , int length) 数组元素的复制</p><ul><li>复制数组array从数组开头长度为length的内容</li><li>如果length &gt; array.length ,会以null&#x2F;空&#x2F;0等补齐，</li><li>如果length &lt; 0 抛出异常</li></ul></li><li><p>fill 数组元素的填充</p></li><li><p>equals 比较两个数组的元素内容是否完全一致，包括内容和顺序</p></li><li><p>asList 将一组值转换成为List</p><ul><li>List是一个接口，此处返回的List的运行类型是Arrays#ArrayList<ul><li>此处 # 表示ArrayList是Arrays的一个内部类</li></ul></li><li>例：List <Integer> aslist &#x3D; Arrays.asList(2,3,4,5);</li></ul></li></ul></li></ul><h2 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h2><ul><li><p>System常见方法</p><ul><li><p>exit(int status) 退出当前程序</p><ul><li>一般status为0 ， 表示正常退出</li></ul></li><li><p>arraycopy(Object src, int srcPos, Object dest, int destPos,int length) 复制数组元素，比较适合底层调用，一般使用Arrays.copy()完成数组复制</p></li><li><p>currentTimeMillens() 返回当前时间距离 1970 - 1 - 1 的毫秒数</p></li><li><p>gc() 运行垃圾回收机制</p></li></ul></li></ul><h2 id="BigInteger和BigDecimal类"><a href="#BigInteger和BigDecimal类" class="headerlink" title="BigInteger和BigDecimal类"></a>BigInteger和BigDecimal类</h2><ul><li><p>BigInteger</p><ul><li><p>用于大数据处理，保存很大的整形</p></li><li><p>在对BigInteger惊醒加减乘除的时候要使用对应的方法不能直接加减，要创建一个需要操作的BigInteger调用相关方法</p></li><li><p>创建： new BigInteger(“”);</p><ul><li>传入参数要为字符串，底层是当做字符串来处理</li></ul></li><li><p>常见方法</p><ul><li>add 加</li><li>subtract 减</li><li>multiply 乘</li><li>divide 除</li></ul></li></ul></li><li><p>BigDecimal</p><ul><li><p>用于保存处理一个精度很高的浮点型</p></li><li><p>在对BigDecimal惊醒加减乘除的时候要使用对应的方法不能直接加减，要创建一个 BigDecimal 对象，调用相关方法</p></li><li><p>创建； 同样要传入字符串作为构造函数的参数</p></li><li><p>常见方法同上</p><ul><li>但注意在divide时可能产生无限循环小数，抛出ArithmeticException</li><li>解决方法：在调用divide方法时指定精度即可<ul><li>System.out.pritln(bigdecimal.divide(bigdecimal2 , BigDecimal.ROUND_CEILING));</li><li>表示在结果为无限不循环小数时，保留到分子的精度</li></ul></li></ul></li></ul></li></ul><h2 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h2><p> 了解知道即可</p><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><ul><li><p>Date： 精确到毫秒，代表特定的2023年10月4日17:12:17</p></li><li><p>SimpleFormat：格式和解析日期的具体类，它允许进行格式化（日期-&gt;文本），解析（文本-&gt;日期）和规范化</p></li><li><p>具体内容看示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();<span class="comment">//获取当前系统时间</span></span><br><span class="line">System.out.println(<span class="string">&quot;当前日期是:&quot;</span> + d1);<span class="comment">//这是默认日期输出格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建SimpleFormat对象可以指定日期输出格式</span></span><br><span class="line"><span class="comment">//这里的格式是规定好的，具体格式要求在API文档的SimpleFormat类中</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 hh:mm:ss E&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> simpleDateFormat.format(d1) ;<span class="comment">//将日期转换为指定格式字符串</span></span><br><span class="line">System.out.println(<span class="string">&quot;当前日期是:&quot;</span> + format);</span><br><span class="line"><span class="comment">//也可把一个格式化的String转成对应的Date,得到的Date输出还是按照默认模式，如果希望指定格式需要转换</span></span><br><span class="line"><span class="comment">//在String-&gt;Date时，String内容格式要和自定义格式完全匹配，否则抛出异常</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;1996年01月01日 10:20:30 星期一&quot;</span>;</span><br><span class="line"><span class="type">Date</span> <span class="variable">parse</span> <span class="operator">=</span> simpleDateFormat.parse(s) ;</span><br><span class="line">System.out.println(simplrDateFormat(parse.format(parse)));</span><br></pre></td></tr></table></figure></li></ul><h3 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h3><ul><li><p>第二代日期类，Calendar类（日历）</p></li><li><p>Calendar是一个抽象类，它为特定瞬间与一组诸如YEAR，MONTH，DAY_OF_MONTH，HOUR等日期字段之间的转换提供了一些方法，并未操作日历字段提供了一些方法</p></li><li><p>Calendar的构造器是私有的，要使用Calendar.getInstance()函数获取实例，类似于单例设计模式的理念</p></li><li><p>具体使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">cld</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        </span><br><span class="line">System.out.println(cld.get(Calendar.YEAR));<span class="comment">//获取年份</span></span><br><span class="line">System.out.println(cld.get(Calendar.DAY_OF_YEAR));<span class="comment">//当年的第__天</span></span><br><span class="line">System.out.println(cld.get(Calendar.MONTH) + <span class="number">1</span> );<span class="comment">//要加一，因为MONTH从零开始编号</span></span><br><span class="line">System.out.println(cld.get(Calendar.DAY_OF_MONTH));<span class="comment">//该月的第__天</span></span><br><span class="line">System.out.println(cld.get(Calendar.HOUR));</span><br><span class="line"><span class="comment">//Calendar没有专门的格式化方法，要自己组合</span></span><br><span class="line">System.out.println(<span class="string">&quot;今天是&quot;</span> + cld.get(Calendar.YEAR) + <span class="string">&quot;年&quot;</span> + cld.get(Calendar.MONTH) </span><br><span class="line">+<span class="string">&quot;月&quot;</span> + cld.get(Calendar.DAY_OF_MONTH) + <span class="string">&quot;日&quot;</span>);</span><br><span class="line"><span class="comment">//默认是12小时制，若要使用24小时制，将Calendar.HOUR -&gt; Calendar.HOUR_OF_DAY 即可</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="第三代日期类"><a href="#第三代日期类" class="headerlink" title="第三代日期类"></a>第三代日期类</h3><p>因前两代日期类的不足，在JDK8中创建新的日期类</p><ul><li><p>第三代日期类</p><ul><li><p>LocalDate （日期&#x2F;年月日）</p><ul><li>只包含日期，可以获得日期字段</li></ul></li><li><p>LocalTime （时间&#x2F;时分秒）</p><ul><li>只包含时间，可以获取时间字段</li></ul></li><li><p>LocaleDateTime（日期时间&#x2F;年月日时分秒）</p><ul><li>包含时间+日期，可以获得日期和时间字段</li></ul></li></ul></li><li><p>DateTimeFormate格式日期类</p><ul><li>类似于SimpleDateFormat</li><li>DateTimeFormat dtf &#x3D; DateTimeFormatter.ofPattern(格式);</li></ul></li><li><p>Instant 时间戳</p></li><li><p>第三代日期还有很多方法，按需查询即可，不用都记住</p></li><li><p>具体示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="comment">//使用now()返回表示当前日期时间的对象，可以获取年月日时分秒</span></span><br><span class="line">System.out.println(ldt);<span class="comment">//直接输出具体日期时间</span></span><br><span class="line">ldt.getYear();<span class="comment">//获取ldt的年份字段</span></span><br><span class="line">ldt.getMonth();</span><br><span class="line">ldt.getMonthValue();</span><br><span class="line">ldt.getDayOfMonth();</span><br><span class="line"><span class="comment">//关于DateTimeFormatter的格式参数要查看jdk8及以后JDK版本的文档</span></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日 HH小时mm分钟ss秒&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">strDate</span> <span class="operator">=</span> dtf.format(ldt);</span><br><span class="line">System.out.println(strDate);</span><br></pre></td></tr></table></figure></li></ul><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><ul><li><p>保存多个数据用数组有许多不便之处</p><ul><li>长度必须提前指定，且一旦指定无法更改</li><li>保存的必须为同一类型的元素</li><li>使用数组进行元素增加的代码比较复杂</li></ul></li><li><p>引入集合，<a href="https://www.cnblogs.com/xiaoxi/p/6089984.html">相关内容</a></p></li><li><p>集合</p><ul><li>可以动态保存任意多个对象，使用方便</li><li>提供了一系列方便的 操作对象的方法：add ， remove，set，get等</li><li>使用集合添加删除新元素的代码简洁明了</li></ul></li></ul><h2 id="集合的框架体系"><a href="#集合的框架体系" class="headerlink" title="集合的框架体系"></a>集合的框架体系</h2><ul><li><p>java集合框架图</p><ul><li><img src="/images/java_base3_06.png" alt="img"></li></ul></li><li><p>java集合主要分为两大类（单列和双列集合），如图</p><ul><li>Collection类<ul><li><p>Collection接口有两个重要子接口List 和Set，他们的实现子类都是单列集合</p></li><li><p><img src="/images/java_base3_07.png" alt="img"></p></li></ul></li><li>Map类<ul><li>Map的接口的实现子类是双列集合，存放<em>K-V数据</em></li><li><img src="/images/java_base3_08.png" alt="img"></li></ul></li></ul></li></ul><h2 id="Collection-接口"><a href="#Collection-接口" class="headerlink" title="Collection 接口"></a>Collection 接口</h2><ul><li><p>Collection: 单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要子接口List和Set</p></li><li><p>Collection简介      </p><ul><li><p>public interface Collection<E> extends Iterable<E>{}</p></li><li><p>Collection实现子类可以存放多个元素，每个元素可以是Object</p></li><li><p><strong>Collection接口没有直接的实现子类，是通过它的子接口Set和List来实现的</strong></p><ul><li>List的特点是元素有序，可重复</li><li>Set的特点是元素无序，且不可重复</li></ul></li></ul></li><li><p>Collection常用方法（以实现子类ArrayList为例）</p><ul><li><p>add 添加单个元素</p></li><li><p>remove 删除指定元素</p></li><li><p>contains 查找元素是否存在</p></li><li><p>size 获取元素的个数</p></li><li><p>isEmpty 判断是否为空</p></li><li><p>clear 清空</p></li><li><p>addAll 添加多个元素</p></li><li><p>containsAll 查找多个元素是否都存在</p></li><li><p>removeAll 删除多个元素</p></li><li><p>例：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>() ;</span><br><span class="line">list.add(<span class="string">&quot;hello &quot;</span>);</span><br><span class="line">list.add(<span class="number">1</span>) ; <span class="comment">//本质上是发生了list.add(Integer.valueOf(1))</span></span><br><span class="line">System.out.println(list);</span><br><span class="line">System.out.println(list.contains(<span class="number">1</span>)); <span class="comment">//参数是一个Object对象</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><blockquote><ul><li>迭代器Iterator</li><li>迭代器基本介绍<ul><li>Iterator对象成为迭代器，主要用于遍历Collection集合中的元素</li><li>所有实现了Collection接口的集合类都有一个Iterator()方法，用以返回一个实现了Iterator接口的对象，即可以返回一个迭代器<ul><li>因为Collection继承了Iterable接口，也继承其中的iterator()抽象方法，用于返回一个迭代器对象</li></ul></li><li>Iterator仅用于遍历集合，Iterator本身并不存放对象</li></ul></li><li>Iterator 结构<ul><li>Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素</li><li><img src="/images/java_base3_10.png" alt="img"></li></ul></li><li>Itertor接口的方法：<ul><li><img src="/images/java_base3_09.png" alt="img"></li><li>在调用Iterator方法前，迭代器索引位于第一个元素之前，不指向任何元素</li><li>每一次调用next()方法，迭代器会指向下一个数据所在区域并返回该位置的数据</li><li>注意： 在调用Iterator.next()方法前必须要先调用Iterator.hasNext()进行检测，若不调用，且下一条记录无效，直接调用.next()会抛出NoSuchElementException异常</li></ul></li><li>迭代器对象获取集合中的元素时，都会将这些元素当做Object类型来看待，如果想要得到特定类型的元素需要进行强制类型转换</li></ul></blockquote><ul><li><p>Colection接口实现子类的遍历元素方式 ：</p><ol><li><p>使用Iterator(迭代器)遍历</p><ul><li><p>代码示例：（可快捷键“ itit ”直接生成，Ctrl+J显示所有模板快捷键）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//希望遍历上诉代码演示中的list集合</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> list.iterator();<span class="comment">//得到list对应的迭代器</span></span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;<span class="comment">//判断是否还有数据</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    System.out.println(<span class="string">&quot;obj = &quot;</span> + obj );</span><br><span class="line">    <span class="comment">//默认调用toString方法，根据动态绑定机制会找到obj运行类型重写的toString方法</span></span><br><span class="line">&#125;<span class="comment">//当退出while循环时，iterator迭代器指向最后一个元素，若是此时调用iterator.next()会抛出异常</span></span><br><span class="line"><span class="comment">//如果希望再次遍历则需要重置迭代器list。调用list.iterator();</span></span><br></pre></td></tr></table></figure></li><li><p>补充：在使用Iterator迭代器对集合中的元素惊醒迭代时，如果调用了集合对象的remove方法删除元素后，继续使用迭代器遍历元素可能会出现异常</p><ul><li>发生了并发修改异常ConcurrentModificationException，这个异常迭代器对象抛出的，出现异常的原因是集合中删除了元素会导致迭代器预期的迭代次数发生改变，导致迭代器的结果不准确</li><li>解决方式：在集合迭代期间删除集合中的元素，可以使用迭代器本身的删除方法：it.remove();<ul><li>例：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> list.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;jack&quot;</span>.equals(obj))</span><br><span class="line">        it.remove();</span><br><span class="line">&#125;<span class="comment">//调用迭代器对象的remove方法删除元素导致的迭代次数变化对于迭代器对象本身来说是可预知的</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li><li><p>使用增强for循环</p><ul><li><p>基本介绍</p><ul><li>增强for循环，可以代替iterator迭代器，特点：增强for就是简化版的iterator，本质一样，只能用于遍历集合或是<u>数组</u></li></ul></li><li><p>基本语法：</p><ul><li><p>for(元素类型 元素名 ： 集合名或数组名){    </p><p> &#x2F;&#x2F;访问元素操作</p></li></ul><p>  }   </p></li><li><p>案例演示：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Object obj : list)&#123;<span class="comment">//上述演示中的list集合</span></span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当使用foreach循环遍历集合和数组时，只能访问集合中的元素，而不能对集合中的元素进行修改</p></li></ul></li></ol><ul><li>3 使用普通for循环</li></ul></li></ul><h3 id="List-接口"><a href="#List-接口" class="headerlink" title="List 接口"></a>List 接口</h3><ul><li><p>List接口基本介绍</p><ul><li><p>List是Collection的子接口</p></li><li><p><strong>List集合类中元素有序</strong>（即添加顺序和取出顺序一致），且List内元素可重复</p></li><li><p>List集合中每个元素都有其对应的顺序索引，即支持索引</p><ul><li>索引从零开始</li><li>使用list的get(int index)方法取出</li></ul></li><li><p>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素</p></li><li><p>实现List接口的常用类有：</p><ul><li>ArrayList</li><li>LinkedList</li><li>Vector</li><li>Stack ，等</li></ul></li></ul></li><li><p>List接口常用方法(以ArrayList为例)</p><ul><li><p>void add(int index,Object ele):在index位置插入ele元素，若不加index，则默认插入在List的最后</p></li><li><p>boolean addAll(int index,Collection eles):从index位置开始将eles中的所有元素添加进来</p></li><li><p>boolean remove(Object o)：在ArrayList中查找并删除该对象，如果删除成功（ArrayList中的elementData数组后面的元素后自动前移补充空位）</p></li><li><p>Object get(int index): 获取指定index位置的元素</p><ul><li>取出的数据编译类型是Object，根据需要强转</li></ul></li><li><p>int indexOf(Object obj):返回obj在集合中首次出现的位置</p></li><li><p>int lastIndexOf(Object obj):返回obj在当前集合中最后一次出现的位置</p></li><li><p>Object set(int index , Object ele): 设置指定index位置的元素为ele，替换</p></li><li><p>List subList(int fromIndex , int toIndex):返回从fromIndex到toIndex位置的集合，包括formIndex位置，不包括toIndex位置</p></li></ul></li><li><p>List 的三种遍历方式</p><ul><li><p>List继承Collection接口，其实现子类ArrayList ， LinkedList , Vector等遍历方式与上述Collection实现子类遍历方式相同</p></li><li><p>例：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="comment">//List的实现子类都可以采用已下遍历方式</span></span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;__&quot;</span>);</span><br><span class="line">list.add( <span class="number">1</span> );</span><br><span class="line"><span class="comment">//Iterator迭代器遍历</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> list.iterator() ;</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//增强for循环遍历</span></span><br><span class="line"><span class="keyword">for</span> (Object ele : list)&#123;</span><br><span class="line">    System.out.println(ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通for循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="ArrayList底层结构和源码分析"><a href="#ArrayList底层结构和源码分析" class="headerlink" title="ArrayList底层结构和源码分析"></a>ArrayList底层结构和源码分析</h4><ul><li><p>ArrayList注意事项</p><ul><li><p>permits all elements ,including null,ArrayList可以加入null，并且可以放入多个空值</p></li><li><p>ArrayList是由数组来实现数据储存的</p></li><li><p>ArrayList基本等同于Vector，但ArrayList是线程不安全的（但执行效率高），看源码，多线程情况下不建议使用ArrayList</p><ul><li>ArrayList是线程不安全的，源码里，ArrayList方法等没有synchronized修饰</li></ul></li></ul></li><li><p>ArrayList 底层结构和源码分析</p><ul><li><p>ArrayList中维护了一个Object类型的数组elementData</p><ul><li>源码  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"><span class="comment">//transient 表示瞬间，短暂的，表示是该属性不会被序列化</span></span><br><span class="line"><span class="comment">//设置为非私有以简化嵌套类访问</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>当创建ArrayList对象时，如果使用的是无参构造器，则初始elementData容量为0，第一次添加，则扩容elementData为10，如需再次扩容，则扩容elementData为1.5倍</p><ul><li>无参构造器返回一个静态为空的Object数组</li><li>源码：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">//默认无参构造器：</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//add函数中:先判断容量是否够继续增加元素，若是list为空则增加一个最小容量的Object数组,size为10</span></span><br><span class="line"><span class="comment">//ensureExplictCapacity()方法中的modCount++ 是用于记录当前集合被修改次数，防止多线程操作发生异常</span></span><br><span class="line"><span class="comment">//内部若是容量不够则执行grow()方法扩容</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数组增长扩容函数grow()部分内容：</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line"><span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//第二次及以后扩容为1.5倍</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)<span class="comment">//若newCpacity小于10,则赋值为10 ，第一次扩容为10</span></span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line"><span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line"><span class="comment">//使用Arrays.copyOf()执行数组扩容，可以保留原集合元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>如果使用的是自定义大小的构造器，则初始化elementData容量为自定义大小，如果需要扩容则直接扩容elementData为1.5倍</p></li><li><p>使用<strong>Arrays.copyof()函数扩容</strong></p></li><li><p>具体内容可查看510节</p></li></ul></li></ul><h4 id="Vector-底层结构和源码剖析"><a href="#Vector-底层结构和源码剖析" class="headerlink" title="Vector 底层结构和源码剖析"></a>Vector 底层结构和源码剖析</h4><ul><li><p>Vector类基本介绍</p><ul><li><p>定义说明：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vector</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure></li><li><p>Vector底层也是一个对象数组，protected Object[] elementData ;</p></li><li><p>Vector是线程同步的，即线程安全的，Vector类的操作方法带有<strong>synchronized</strong></p></li><li><p>在开发中，需要线程同步安全时，考虑使用Vector</p></li></ul></li><li><p>Vector底层结构</p><ul><li>Vector和ArrayList的比较：</li></ul><table><thead><tr><th></th><th>底层结构</th><th>线程安全（同步），效率</th><th>扩容倍数</th></tr></thead><tbody><tr><td>ArrayList</td><td>可变数组</td><td>不安全，效率高</td><td>如果是有参构造，扩容1.5倍.无参构造第一次为10，从第二次开始1.5倍扩容</td></tr><tr><td>Vector</td><td>可变数组Object[]</td><td>安全，效率不高</td><td>有参构造，扩容2倍。如果是无参，默认为10，之后每次按两倍扩容</td></tr></tbody></table><ul><li><p>源码分析与ArrayList相似，具体可debug追踪</p><ul><li>注意Vector的扩容机制：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line"><span class="comment">// overflow-conscious code</span></span><br><span class="line"><span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                 capacityIncrement : oldCapacity);<span class="comment">//此处为主要扩容操作  </span></span><br><span class="line"><span class="comment">//capacityIncrement默认是0，可以在构造器中传入，指定每次扩容增加量，否则默认扩双倍</span></span><br><span class="line"><span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = minCapacity;</span><br><span class="line"><span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h4 id="LinkedList-底层结构和源码剖析"><a href="#LinkedList-底层结构和源码剖析" class="headerlink" title="LinkedList 底层结构和源码剖析"></a>LinkedList 底层结构和源码剖析</h4><ul><li><p>LinkedList全面说明</p><ul><li>LinkedList底层实现了双向循环链表</li><li>可以添加任意元素（元素可以重复），包括null</li><li>线程不安全，没有实现同步</li></ul></li><li><p>LinkedList的底层操作机制</p><ul><li>LinkedList底层维护了一个双向链表</li><li>LinkedList中维护了两个属性first和last分别指向首节点和为节点</li><li>每个节点（Node对象），里又维护了prev，next，item三个属性其中通过prev指向前一个，通过next指向后一个节点，最终实现双向链表</li><li>故LinkedList的元素添加和删除通过修改节点之间引用关系即可，相对来说效率较高</li></ul></li><li><p>源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;<span class="comment">//LinkedList维护了一个名为Node的成员内部类，该内部类作为双向链表的节点类</span></span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//LinkedList内部属性：用于储存双向链表的相关属性</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;<span class="comment">//指向双向链表第一个节点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;<span class="comment">//指向双向链表最后一个节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;<span class="comment">//添加链表元素</span></span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;<span class="comment">//添加节点功能实现的主要代码</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line">E <span class="title function_">unlink</span><span class="params">(Node&lt;E&gt; x)</span> &#123;<span class="comment">//实现节点删除功能的主要代码</span></span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="literal">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类似的可多debug跟踪，多注意其中的异常处理内容</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="ArrayList和LinkedList比较"><a href="#ArrayList和LinkedList比较" class="headerlink" title="ArrayList和LinkedList比较"></a>ArrayList和LinkedList比较</h4><table><thead><tr><th></th><th>底层结构</th><th>增删效率</th><th>查改效率</th></tr></thead><tbody><tr><td>ArrayList</td><td>可变数组</td><td>较低，在增加节点过程中发生数组扩容</td><td>较高</td></tr><tr><td>LinkedList</td><td>双向链表</td><td>较高，通过在链表追加节点</td><td>较低</td></tr></tbody></table><ul><li>总结：<ul><li>如果查改操作较多，选择ArrayList</li><li>如果增删操作多，选择LinkedList</li><li>一般来说在程序中大部分都是查询，因此大部分情况下选择ArrayList</li><li>在一个项目中，根据业务灵活选择，不同模块可采用不同的结构</li></ul></li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ul><li><p>Set接口基本介绍</p><ul><li><p><strong>无序</strong>（添加和取出的顺序不能保证一致），没有索引，取出的顺序虽然不同于添加的顺序，但是仍是按某固定的算法控制输出的顺序，不会相同内容每次输出的顺序都不同</p></li><li><p><strong>不允许重复元素</strong>，故最多包含一个null，实现Set接口类的类的实例对象不允许存放重复的元素</p></li><li><p>实现类常用的有：</p><ul><li>HashSet</li><li>TreeSet</li><li>其他可查看API文档</li></ul></li></ul></li><li><p>Set接口的常用方法     </p><ul><li>和List接口一样，Set接口也是Collection的子接口因此，常用方法和Collection接口相同</li><li>因Set的无序性，Set中没有get(int index)方法，也不存在索引值一说</li></ul></li><li><p>Set接口的遍历方式</p><ul><li>同Collection的变能力方式相同，因为Set接口时Collection接口的子接口可以使用迭代器</li><li>增强for</li><li>不能通过索引的方式实现普通for循环遍历</li></ul></li></ul><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><ul><li>HashSet简介<ul><li><p>HashSet实现了Set接口</p></li><li><p>HashSet实际上是HashMap：源码：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;<span class="comment">//HashSet默认构造器</span></span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//Constructs a new, empty set; the backing HashMap instance </span></span><br><span class="line">    <span class="comment">//has default initial capacity (16) and load factor (0.75)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以存放null值，但是只能有一个null</p></li><li><p>HashSet不保证元素是有序的，元素的顺序取决于求hash值后再确定索引的结果</p></li><li><p><strong>不能有重复的元素&#x2F;对象</strong></p><ul><li>例1：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HashSet</span> <span class="variable">hashSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">hashSet.add(<span class="string">&quot;hello&quot;</span>) ;</span><br><span class="line">hashSet.add(<span class="literal">null</span>);</span><br><span class="line">System.out.println(hashSet.add(<span class="string">&quot;hello&quot;</span>));<span class="comment">//此处会输出false</span></span><br><span class="line">System.out.println(hashSet);<span class="comment">//输出结果中只有一个hello </span></span><br></pre></td></tr></table></figure></li><li>例2：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Book</span><span class="params">(String name )</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main中：</span></span><br><span class="line"><span class="type">HashSet</span> <span class="variable">hashSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">hashSet.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;百年孤独&quot;</span>)) ;</span><br><span class="line">System.out.println(hashSet.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;百年孤独&quot;</span>)));<span class="comment">//此处输出true</span></span><br><span class="line">System.out.println(hashSet);<span class="comment">//此处打印出了两个Book对象</span></span><br></pre></td></tr></table></figure></li><li>例3：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HashSet</span> <span class="variable">hashSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">hashSet.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>)) ;</span><br><span class="line">hashSet.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>));<span class="comment">//此处会？</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>  如何理解HashSet不能添加相同的元素&#x2F;对象（跟踪源码）</p><ul><li><p>HashSet底层是HashMap，HashMap底层是数组+链表+红黑树</p></li><li><p>HashMap结构示例图：<br><img src="/images/java_base3_11.png" alt="img">  </p></li><li><p>模拟一个简易的MyHashSet（也就是HashMap），拉链法实现散列表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line"> Object item ;<span class="comment">//存放数据</span></span><br><span class="line"> Node next ;<span class="comment">//存放下一个节点</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Object item, Node next)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.item = item;</span><br><span class="line">      <span class="built_in">this</span>.next = next;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//main中模拟HashMap加入节点的过程</span></span><br><span class="line"> Node[] table = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">16</span>];</span><br><span class="line"> <span class="type">Node</span> <span class="variable">node1</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;hello&quot;</span> , <span class="literal">null</span>) ;</span><br><span class="line"> table[<span class="number">1</span>] = node1 ;<span class="comment">//table的索引为 1 处指向节点node1</span></span><br><span class="line"> <span class="type">Node</span> <span class="variable">node2</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;hi&quot;</span> , <span class="literal">null</span>) ;</span><br><span class="line"> node1.next = node2 ;<span class="comment">//将hi节点挂载在hello节点</span></span><br><span class="line"> <span class="comment">//此时table[1]处便连接一个链表</span></span><br></pre></td></tr></table></figure></li></ul><p>HashSet 的添加元素判断机制：<strong>（hash() + equals()）</strong></p><ul><li>HashSet底层是HashMap</li><li>添加一个元素时，先得到hash()值，会经过运算转化成索引值<ul><li><strong>此处的hash值不完全等于该元素的hashcode()，而是经过一定处理得到</strong>       </li><li>hash算法：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;<span class="comment">//key就是添加的对象</span></span><br><span class="line">    <span class="type">int</span> h;   </span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);  </span><br><span class="line">&#125;<span class="comment">//该算法的作用在于尽量让不同的key得到不同的hash值，尽量避免hash碰撞</span></span><br></pre></td></tr></table></figure></li></ul></li><li>在存储数据表table中看这个索引位置是否已经有存放的元素</li><li>如果没有直接加入</li><li>如果有，调用equals()比较  (此处程序员可通过重写equals方法来控制比较标准) ，如果相同就放弃添加，如果不同则添加到该索引处链表最后</li><li>在java8中，<strong>当如果一条链表长度达到8（TREEIFY_THRESHOLD），且table大小达到64（MIN_TREEIFY_CAPACITY），就会树化（红黑树）</strong></li></ul></blockquote><ul><li>判断新节点是否能加入的代码HashMap的putVal()方法分析：</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">           <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    n = (tab = resize()).length;<span class="comment">//如果table数组为空则创建table数组，并由tab临时变量指向table数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line"><span class="comment">//此处计算要插入的key在table数组中下标索引并赋给临时变量i: i = (n - 1) &amp; hash，同一索引值的节点连接在一个数组后形成链表</span></span><br><span class="line"><span class="comment">//此处中p是putVal方法中定义的临时辅助变量，p指向table数组中key的索引位置后</span></span><br><span class="line"><span class="comment">//如果p指向位置为空，即table[i]后续没有节点，则直接将该key对象加入table[i]后</span></span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//若p的指向table数组的位置后不为空，即table数组该索引位置后有节点</span></span><br><span class="line">    Node&lt;K,V&gt; e; K k;</span><br><span class="line">    <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">        ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">        <span class="comment">//这个判断条件用于确保在 HashMap 中没有重复的键。如果存在重复键，则需要进行覆盖操作，如果不存在则进行插入操作。</span></span><br><span class="line">        e = p;<span class="comment">//辅助变量e指向要传入的节点对应索引位置第一个节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">        e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">    <span class="comment">//判断要key插入的位置后的链表是不是已经被红黑树化，其中调用大量红黑树相关方法</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;<span class="comment">//死循环逐个判断要传入的节点与该索引后链表中节点是否“相同”</span></span><br><span class="line">            <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;<span class="comment">//发现链表中没有“相同”节点，则将该节点加入到链表最后</span></span><br><span class="line">                p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                <span class="comment">//添加节点后立刻判断当前链表是否已经达到8个节点，达到则调用treeifyBin函数，其中还会判断该table数组大小是否超过64</span></span><br><span class="line">                    treeifyBin(tab, hash);</span><br><span class="line">                <span class="comment">// if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span></span><br><span class="line">                <span class="comment">//只有当上述判断条件不成立时才进行树化，否则只是扩容</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//如果发现该链表中有节点和要传入的节点“相同”，则key不能加入，直接跳出循环</span></span><br><span class="line">            p = e;<span class="comment">//节点后移操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">        <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;<span class="comment">//这里的value就是HashSet中的静态成员PRESENT，所有HashSet中节点的Value值都相同</span></span><br><span class="line">        <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">            e.value = value;</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">        <span class="comment">//返回null，表示已经添加成功，在HashSet的add函数中还有一层返回语句如下：</span></span><br><span class="line">        <span class="comment">//return map.put(e, PRESENT)==null;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">++modCount;</span><br><span class="line"><span class="keyword">if</span> (++size &gt; threshold)<span class="comment">//size是HashMap类的属性，如果size大于阈值就扩容</span></span><br><span class="line">    resize();</span><br><span class="line">afterNodeInsertion(evict);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 源码解读看521 - 524节 ，仔细分析HashSet添加元素时调用的HashMap的putVal()方法，</span></span><br></pre></td></tr></table></figure><ul><li><p>补充：</p><ul><li><p>hash值的计算</p><ul><li>此处的hash值不完全等于该元素的hashcode()值，而是经过一定处理得到</li><li>自定义类hashcode方法可由程序员控制，一般重写Object类的hashCode方法用如下形式：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hash();<span class="comment">//Objects.hash()中是可变参数列表</span></span><br><span class="line">&#125;<span class="comment">//利用Objects工具类中的hash函数，参数列表为类中的属性，根据对象中的属性值求出hash值，</span></span><br></pre></td></tr></table></figure><ul><li>利用这种方式重写hashCode()可以保证根据不同的属性内容，计算出的hashCode值也不相同</li></ul></li></ul></li><li><p>i &#x3D; (n - 1) &amp; hash</p><ul><li>这是根据hash值计算key在table数组下标的算法</li><li>在这个表达式中，n 是 HashMap 的容量，而 hash 是键的散列码。&amp; 是位运算符中的按位与运算符。</li><li>由于 n 是HashMap的容量，通常会选择一个2的幂作为容量值（比如16、32、64等），这样可以确保 n - 1 的二进制表示最后m位全是1，其他位都是0。这是为了确保对任何数进行 (n - 1) &amp; hash 操作时，得到的结果都在 0 到 n - 1 的范围内。</li><li>即：（n-1）&amp;hash &#x3D; hash % n</li></ul></li><li><p>if (p.hash &#x3D;&#x3D; hash &amp;&amp;<br>  ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</p><ul><li>p.hash &#x3D;&#x3D; hash 检查当前节点 p 的 hash 值是否与待插入节点的 hash 值相等。这是为了确保hash值相同的对象被散列到相同的桶中</li><li>由于HashMap采用了数组+链表&#x2F;红黑树的存储方式来处理哈希冲突，当发生哈希碰撞时，会将具有相同散列码的键值对放入同一个链表或红黑树中。因此，为了检查待插入的键值对是否需要放入已有的链表或红黑树中，就需要通过比较散列码来确认它们是否应该放在同一个桶中。</li><li>如果 p.hash 和 hash 不相等，那么说明待插入的键值对与已有的键值对散列码不同，它们不应该放在同一个桶中，因此就不需要执行后续的键相等性检查。</li><li>((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))) 则是用来检查键是否已经存在。在这里，首先将当前节点 p 的键存储在临时变量 k 中，然后与待插入键 key 进行比较。</li><li>k &#x3D;&#x3D; key 检查两个键是否是同一对象的引用。如果是，则说明键已经存在于 HashMap 中。</li><li>(key !&#x3D; null &amp;&amp; key.equals(k)) 是更一般化的检查。首先确保待插入键不为 null，然后调用待插入键的 equals 方法来检查是否与当前节点 p 的键相等。这是因为即使两个键不是同一对象的引用，但如果它们在逻辑上相等，则也应视为键已存在于 HashMap 中，会动态绑定调用要比较对象类内的equals方法</li></ul></li></ul></li><li><p>HashSet扩容机制：523-524节</p><ul><li><p>HashSet底层是HashMap，扩容机制主要在HashMap的resize方法中。- 第一次添加时，table数组扩容到16，临界值（threshold）&#x3D; 16 * 加载因子</p><ul><li>static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4; &#x2F;&#x2F; aka 16</li><li>static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;</li></ul></li><li><p>如果<strong>table中加入节点总元素个数</strong>，到了临界值12，就会扩容到16 * 2 &#x3D; 32，新的临界值就是32 * 0.75 &#x3D; 24， 以此类推</p></li><li><p>在添加节点的过程中，若是某个链表长度达到了8，则进入treeifyBin函数，判断<strong>table数组长度</strong>是否大于64，若否，则将该数组扩容两倍，若是则将该链表树化</p></li></ul></li></ul></li><li><p>上述三个HashSet添加元素例子分析：  </p><ul><li>判断标准：if (p.hash &#x3D;&#x3D; hash &amp;&amp;<br>  ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</li></ul><ol><li><p>两次加入的”hello”字符串都是存放在常量池中的同一对象，</p><ul><li>判断1 ：两次加入是同一对象，hash一定相同，为true</li><li>判断2 ：两次加入对象实际就是同一个对象，为true，故上诉判断语句结果为true，无法加入</li></ul></li><li><p>两次加入的是属性name相同的不同的Book对象，</p><ul><li>Book类没有重写hashCode方法，Object中hashCode方法是根据对象的地址来运算得到的，这里是不同对象，hash值不同，故求出的对应索引位置也不同，两个Book对象会加入table数组的不同索引位置后</li></ul></li><li><p>两次加入的是储存字符序列相同的String对象</p><ul><li><p>判断1 ：此处会动态绑定调用String重写的hashCode方法，内容完全相同的字符串返回的hashCode值一定相同，结果为true</p></li><li><p>判断2 ：两次加入的String对象是存放在堆中的不同对象，结果为false</p></li><li><p>判断3：两个String对象进行equals判断，这里会动态调用要判断对象类型的equals函数，String类中重写了Object中的equals函数，判断标准是两个String的内容是否完全相同，结果为true</p></li><li><p>结果为（true&amp;&amp;（false||true）） &#x3D; （true&amp;&amp;true） &#x3D; true，在函数最终结果是不能加入</p></li></ul></li></ol></li><li><p>总结：</p><ul><li><p>调用hashCode()方法来计算对象的哈希值从而确定元素的储存位置，重写hashcode()保证内容相同的对象的hashcode值一定相同，在插入HashMap时会被插入到同一索引位置后以进行后续判断</p></li><li><p>重写equals()保证会根据对象的内容进行判断，防止内容重复对象再次加入HashMap</p></li><li><p>equals函数和hashCode函数都要重写才能确保能按程序员希望的需求进行正确的判断去重，<a href="https://blog.csdn.net/qq_45427600/article/details/113484445">相关解析文章1</a>,<a href="https://cloud.tencent.com/developer/article/1910930">相关解析文章2</a></p></li></ul></li><li><p>例题分析：看551节例题分析：分析如下程序输出结果：</p><ul><li>这个题还挺恶心的，可以帮助更好了解底层  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//已知Person类按照id和name重写了hashCode和equals方法</span></span><br><span class="line"><span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;AA&quot;</span>) ;</span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1002</span>,<span class="string">&quot;BB&quot;</span>) ;</span><br><span class="line">set.add(p1);</span><br><span class="line">set.add(p2);</span><br><span class="line">p1.name = <span class="string">&quot;CC&quot;</span> ;</span><br><span class="line">set.remove(p1) ;</span><br><span class="line">System.out.println(set);</span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;CC&quot;</span>));</span><br><span class="line">System.out.println(set) ;</span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;AA&quot;</span>));</span><br><span class="line">System.out.println(set) ;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>提示：注意p1的hashcode值的变化</p></li><li><p>若是没有重写hashCode和equal结果是什么样的？</p></li><li><p>补充：HashMap的table为什么是transient的：</p><ul><li><a href="https://www.cnblogs.com/xrq730/p/5030920.html">相关内容</a>-懒</li><li>public native int hashCode();</li></ul></li></ul></li></ul><h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><ul><li><p>LinkedHashSet基本介绍：</p><ul><li>LinkedHashSet是 HashSet 的子类</li><li>LinkedHashSet底层是一个LinkedHashMap，底层维护了一个 <strong>数组 + 双向链表</strong></li><li>LinkedHashSet 根据元素的hashCode值来决定元素的储存位置，同时<u>使用双向链表维护元素的次序，这使得元素看起是以插入顺序保存的</u></li><li>LinkedHashSet 不允许添加重复元素</li><li>LinkedHashSet示例结构图：<br>  <img src="/images/java_base3_12.png" alt="img"></li></ul></li><li><p>源码解读：</p><ul><li><p>在LinkedHashMap中维护了一个hash表和双向链表（LinkedHashMap有head和tail）</p></li><li><p>每一个节点有before和after属性，这样可以形成双向链表</p></li><li><p>在添加一个元素时，先求hash值，再求索引，确定该元素在table的位置，若是成功将该元素添加如table，再将添加的元素加入到双向链表（如果该元素已经存在，不添加，添加原则和hashSet一样）    </p><ul><li>因为LinkedHashSet是HashSet的子类，在调用add函数添加元素时直接调用父类的add函数，但在其中创建新节点时动态绑定调用了在LinkedHashSet中重写的newNode函数</li><li>将新插入hash表节点加入双向链表的代码：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tail.next = newElement;</span><br><span class="line">newElement.pre = tali ;</span><br><span class="line">tail = newElement ;</span><br></pre></td></tr></table></figure></li><li>实际添加过程很复杂，自己再debug一边，写的很NB</li></ul></li><li><p>在第一次添加节点时，直接将数组table扩容到16，tabe是HashMap$Node类型数组，存放的节点是 LinkedHashMap$Entry类型对象</p><ul><li>LinkedHashMap$Entry 是LinkedHashMap类中的一个静态内部类</li><li>LinkedHashMap$Entry 继承了HashMap$Node 类,</li><li>LinkedHashMap将传入的数据保存在LinkedHashMap.Entry类对象中</li><li>LinkedHashMap.Entry定义源码：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Node&lt;K,V&gt; &#123;</span><br><span class="line">Entry&lt;K,V&gt; before, after;</span><br><span class="line">Entry(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    <span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>这样遍历LinkedHashSet也能确保插入顺序和遍历顺序一致</p></li></ul></li></ul><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><ul><li><p>TreeSet底层是TreeMap</p><ul><li><strong>Set的value使用一个常量PRSENT占位，所有set是单列，但底层都是Map</strong></li><li>传入Set的对象传入了Map的Key，而Key不能重复，故Set不能加入重复元素<ul><li>TreeSet添加元素源码：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m.put(e, PRESENT)==<span class="literal">null</span>;<span class="comment">//这里的m是TreeSet中定义的Map的一个子类的实例对象</span></span><br><span class="line">    <span class="comment">//PERSENT定义：private static final Object PRESENT = new Object();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>当使用TreeSet的无参构造器创建TreeSet时，TreeSet看起来好像仍是无序的</p></li><li><p>使用TreeSet 提供的一个构造器，传入一个比较器（匿名内部类），Comparator指定排序规则</p><ul><li><p>例：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TreeSet</span> <span class="variable">treeSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>(<span class="keyword">new</span> <span class="title class_">Comparator</span>()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1 , Object o2)</span>&#123;</span><br><span class="line">        <span class="comment">//按需设置返回值，比如设置按字符串长度排序</span></span><br><span class="line">        <span class="keyword">return</span>  ((String)o1).length - ((String)o2)。length ;</span><br><span class="line">    &#125;<span class="comment">//如之前在Comparator部分说明，这个compare函数会被用作内部排序规则</span></span><br><span class="line">&#125;);</span><br><span class="line">treeSet.add(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">treeSet.add(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">System.out.println(treeSet);<span class="comment">//此处只会输出abcd,因为它把长度相同的字符串都认为是同一个key</span></span><br></pre></td></tr></table></figure></li><li><p>在TreeMap源码中 ， 如果加入的Key用传入Comparator的compare方法比较后发现与已有的Key值相同，则return t.setValue(value); </p><ul><li>从TreeSet加入TreeMap中所有节点的value都相同，相当于没有进行任何操作，该新节点也没有被加入</li><li>若是直接用TreeMap类，两次加入节点的Key值相同，return t.setValue(value); 则会使新加入节点的value值替换原有的value值<ul><li>例：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TreeMap</span>  <span class="variable">treeMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>(<span class="keyword">new</span> <span class="title class_">Comparator</span>()&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1 , Object o2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  ((String)o1).length() - ((String)o2).length() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">treeMap.put(<span class="string">&quot;hah&quot;</span>,<span class="string">&quot;123&quot;</span>);</span><br><span class="line">treeMap.put(<span class="string">&quot;hii&quot;</span> , <span class="string">&quot;234&quot;</span>);<span class="comment">//比较器认为两个对象Key相同，value被新的value替换</span></span><br><span class="line">System.out.println(treeMap);<span class="comment">//此处会输出&#123;hah=234&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>跟踪代码，发现用TreeSet默认构造器构造器TreeSet时，Comparator置为NULL，若Comparator为NULL，进行排序判断时会动态绑定使用 Key 对象类的compareTo方法进行元素的排序，而并不是完全的无序</p></li><li><p>下列代码，出现异常，分析原因</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TreeSet</span> <span class="variable">treeSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>() ;</span><br><span class="line">treeSet.put(<span class="keyword">new</span> <span class="title class_">Person</span>());</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体情况可查看543，544节，或跟踪TreeSet 的源码</p></li><li><p>前面在Arrays.sort()中有类似例子，问题在于Person类没有实现Comparable接口</p></li></ul></li></ul><h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><ul><li><p>Map类基本简介</p><ul><li><p>Map是双列集合的根接口， 它的每个元素都包含一个键对象(key)和值对象(Value),键和值对象之间存在一种对应关系，称为映射，从Map集合中访问元素时，可以通过指定的key找到对应的value。</p></li><li><p>Map接口的主要实现类有HashMap，TreeMap等</p></li></ul></li><li><p>Map接口特点：</p><ul><li><p>Map用于保存具有映射关系的数据：Key——Value ，Key和value之间存在<strong>单向一对一</strong>关系，即通过指定的key总能找到对应的value</p><ul><li>key 可以看做时value的“身份证号”，根据key就一定可以找到它对应的唯一的value（姓名）</li><li>但不同的key可以有相同的value值</li></ul></li><li><p>Map中<u>key和value可以是任何引用类型的数据</u>，<strong>会封装到HashMap$Node对象中</strong></p></li><li><p>Map中的<strong>Key是唯一的</strong>，可以为null,，不允许重复，原因如上在HashSet中的分析</p><ul><li>但是当有相同的key，不同value的节点加入时，会以新加入的节点(value)替换原节点(value)</li><li>即键相同，值覆盖；</li></ul></li><li><p>Map中的value可以为null，可以重复</p><ul><li>例如在HashSet底层是HashMap，就利用该特点，在向HashMap中加入节点时，传入的Key为要插入的对象，value为HashSet中的静态Object变量PRESENT</li><li>HashSet的add函数：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;<span class="comment">//所有加入节点都是PRESENT，即所有节点value值都相同</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//PRESENT定义：</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure></li></ul></li><li><p>HashMap为了方便遍历还会创建EntrySet集合，该集合存放元素类型为Entry,而HashMap$Node实现了Entry接口，故Entry类集合可以存放Node类型节点</p><ul><li><p>final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt;</p></li><li><p>Entry接口</p><ul><li>Entry 是一个Map接口中的内部接口类</li><li>把HashMap$Node对象存放在entrySet中。 EntrySet中存放了Entry类的引用，这些引用指向HashMap中的Node节点</li><li>Entry接口提供了getKey()和getValue()方法</li></ul></li><li><p><strong>Map接口没有迭代器，无法直接遍历Node，这时需要通过转变为Set集合，获取到Iterator对象才能方便遍历</strong></p></li></ul></li><li><p>结构图：（真难画（；——_——））<br>   <img src="/images/java_base3_13.png" alt="img"></p></li><li><p><a href="https://blog.csdn.net/qq_39736597/article/details/113762355">Entry相关</a>,或重新看531-534节</p></li></ul></li><li><p>Map接口常用方法</p><ul><li>put:添加</li><li>remove：根据键值删除映射关系</li><li>get：根据key获取value</li><li>size : 获取元素的个数</li><li>isEmpty：判断元素个数是否为0</li><li>clear：清除</li><li>containsKey：查看键是否存在</li></ul></li><li><p>Map接口遍历方法</p><ul><li><p>相关方法：</p><ul><li>containskey():查找键是否存在</li><li>keySet(): 获取所有的键</li><li>values():获取所有的值</li><li>entrySet()：获取储存在Map中所有映射的set集合<ul><li>Entry是Map接口的内部接口</li></ul></li></ul></li><li><p>方式一 ：取出所有Key，通过Key取出对应的Value</p><ul><li>增强for  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Set</span> <span class="variable">keySet</span> <span class="operator">=</span> map.keySet();</span><br><span class="line"><span class="keyword">for</span>(Object key : keySet)&#123;</span><br><span class="line">    System.out.println(key + <span class="string">&quot;-&quot;</span> + map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>迭代器  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> keyset.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next() ;</span><br><span class="line">    System.out.println(key + <span class="string">&quot;-&quot;</span> + map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>方式二：把所有的value取出</p><ul><li>增强for  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">values</span> <span class="operator">=</span> map.values();</span><br><span class="line"><span class="keyword">for</span>(Object value : values)&#123;</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>迭代器  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> values.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>方式三：<strong>通过EntrySet来获取k-v</strong></p><ul><li>通过Map。Entry的setValue来改变value值</li><li>增强for  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> map.entrySet() ;</span><br><span class="line"><span class="keyword">for</span>(Object entry : entrySet)&#123;</span><br><span class="line">    Map.<span class="type">Entry</span> <span class="variable">temp</span> <span class="operator">=</span> (Map.Entry)entry;</span><br><span class="line">    temp.getKey();</span><br><span class="line">    temp.getValue();</span><br><span class="line">    System.out.println(temp.getClass());<span class="comment">//运行类型是HashMap$Node-&gt;实现Map.Entry(getValue(),getKey())</span></span><br><span class="line">    <span class="comment">//但HashMap$Node是default访问权限，无法访问到，故将其从Object类型强转为Map.Entry类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>迭代器原理同上</li></ul></li></ul></li></ul><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><ul><li><p>HashMap小结：</p><ul><li>Map接口的常用实现类：HashMap，Hashtable和Properties</li><li>HashMap是Map接口使用频率最高的实现类</li><li>HashMap是以key-value对的方式来储存数据<ul><li>（k-v）是一个HashMap$Node，实现了Map.Entry，</li></ul></li><li>key不能重复，但是值可以重复，允许使用null键和null值</li><li>如果添加相同的key，会覆盖原来的key-value，修改value值</li><li>与HashSet一样，不保证顺序，底层是以hash表的方式来储存的<ul><li>jdk8 ， HashMap底层 数组 + 链表 + 红黑树</li></ul></li><li>HashMap没有实现同步，因此是线程不安全的，方法没有做同步互斥的操作，即没有synchronized</li></ul></li><li><p>源码解析</p><ul><li><p>绝大部分同上述在HashSet中分析的：<br>   <img src="/images/java_base3_14.png" alt="img"></p></li><li><p>添加机制</p></li><li><p>扩容机制</p></li><li><p>debug追踪，看537节</p></li></ul></li></ul><h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><ul><li><p>基本介绍：</p><ul><li>Hashtable实现了Map接口</li><li>存放的元素的键值对：K-V</li><li><u>Hashtable的键和值都不能为null</u>,发生NullPointerException</li><li>Hashtable使用方法基本上和HashMap一样</li><li>Hashtable是线程安全的（synchronized），HashMap是线程不安全的</li><li>Hashtable效率太低，存取元素时速度很慢，基本不使用，常用HashMap</li></ul></li><li><p>源码解读 - 看539  </p><ul><li>扩容机制：<br>  int newCapacity &#x3D; (oldCapacity &lt;&lt; 1) + 1;</li></ul></li></ul><h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><ul><li>基本介绍：<ul><li>Properties类继承自Hashtable类并且实现了Map接口，也是使用键值对的形式来保存数据</li><li>使用特点和Hashtable类似</li><li>Properties还可以从 xxx.properties 文件中加载数据到Properties类对象，并进行读取和修改</li><li>说明：xxx.properties 文件常作为配置文件，与IO流相关内容相关，<a href="https://www.cnblogs.com/xudong-bupt/p/3758136.html">相关文章</a></li></ul></li></ul><h2 id="集合总结"><a href="#集合总结" class="headerlink" title="集合总结"></a>集合总结</h2><ul><li><p>在开发中根据实际业务需求和集合实现类特性选择要使用的集合实现类</p></li><li><p>分析：</p><ul><li><p>先判断储存的数据类型</p></li><li><p>若存储一组对象：Collection接口</p><ul><li><p>允许重复：List</p><ul><li>增删多：LinkedList（底层维护了一个双向链表）</li><li>改查多：ArrayList（底层维护了一个Object类型的可变数组，线程不安全）</li></ul></li><li><p>不允许重复：Set</p><ul><li>无序：HashSet（底层是HashMap，维护了一个哈希表，即数组加链表加红黑树）</li><li>排序：TreeSet（底层是TreeMap）</li><li>插入和取出顺序一致 ： LinkedHashSet（底层是LinkedHashMap，维护了数组+双向链表）</li></ul></li></ul></li><li><p>若存储一组键值对： Map</p><ul><li>键无序： HashMap</li><li>键排序：TreeMap</li><li>键插入和取出顺序一致：LinkedHashMap</li><li>读取文件：Properties</li></ul></li></ul></li></ul><h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h2><ul><li><p>Collections是一个操作Set ，List和Map等集合的工具类</p></li><li><p>Collection是中提供了一系列的静态方法对集合元素进行排序，查询和修改等操作</p><ul><li><p>reverse(List):反转List中元素的顺序</p></li><li><p>shuffle(List):对List集合进行随机排序</p></li><li><p>sort(List)：根据元素的自然顺序对List集合元素按升序排序</p></li><li><p>sort(List ,Comparator)：根据指定的Comparator产生的顺序对List集合元素进行排序</p></li><li><p>swap(List , int i , int j)：将指定list集合中i处元素和j处元素进行交换</p></li><li><p>Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素</p></li><li><p>Object max(Collection , Comparator):根据Comparator执行的顺序，返回给定集合中的最大元素</p><ul><li>类似的还有min方法</li></ul></li><li><p>int frequency(Collection ,Object):返回指定集合中指定元素的出现次数</p></li><li><p>void copy(List dest,List src):将src中的内容复制到dest中</p></li><li><p>boolean replaceAll(List list,Object oldVal,Object newVal):使用新值替换List对象的所有旧值</p></li></ul></li></ul><h1 id="特殊类"><a href="#特殊类" class="headerlink" title="特殊类"></a>特殊类</h1><h2 id="泛型容器类"><a href="#泛型容器类" class="headerlink" title="泛型容器类"></a>泛型容器类</h2><blockquote><p>例：ArrayList&lt;*Stirng*&gt; notes &#x3D; new ArrayList&lt;*String*&gt;;</p></blockquote><ul><li>容器有两个类型：<ul><li>容器的类型：例如ArrayList</li><li>元素的类型：例如String      <br></li></ul></li><li>ArrayList</li></ul><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><ul><li>定义在别的类的内部，函数内部的类<ul><li>内部类能直接访问外部的全部资源</li><li>外部是函数时，只能访问那个函数里final的变量</li></ul></li></ul><h2 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h2><ul><li>在new对象时给出类的定义形成了匿名类</li><li>匿名类可以继承某类，也可以实现某接口</li><li>Swing的消息机制广泛使用匿名类<ul><li>注入反转</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;枚举和注解&quot;&gt;&lt;a href=&quot;#枚举和注解&quot; class=&quot;headerlink&quot; title=&quot;枚举和注解&quot;&gt;&lt;/a&gt;枚举和注解&lt;/h1&gt;&lt;h2 id=&quot;枚举&quot;&gt;&lt;a href=&quot;#枚举&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    
    <category term="java" scheme="https://pengzhanyi.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java基础——面向对象基础</title>
    <link href="https://pengzhanyi.github.io/2023/09/19/java_base2/"/>
    <id>https://pengzhanyi.github.io/2023/09/19/java_base2/</id>
    <published>2023-09-19T13:37:20.000Z</published>
    <updated>2023-10-15T11:24:56.003Z</updated>
    
    <content type="html"><![CDATA[<p>java-面向对象基础</p><p>[toc]</p><h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2><ul><li>类是规范，类是定义了这个类所有对象的属性和操作，可以根据类的定义来创建对象</li></ul><h3 id="类的基本内容"><a href="#类的基本内容" class="headerlink" title="类的基本内容"></a>类的基本内容</h3><ul><li>成员变量</li><li>成员函数</li><li>代码块</li></ul><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><ul><li><p>类定义了对象所具有的变量，这些变量就是成员变量（属性）    </p><ul><li>属性定义： 访问修饰符 + 属性类型 + 属性名<ul><li>类的成员变量一般设置为private属性</li></ul></li><li>成员变量的生存期是对象的生存期，作用域是类内部的成员函数</li><li>定义子啊函数内部的变量是本地变量，生存期也作用域都是函数内部</li></ul><blockquote><p>注意在类中成员变量有对象数组时，<strong>使用对象数组前先将其数组成员指向实例化化对象，因为创建的对象数组只是对象引用，对象数组中成员全是null，并无实例，使用时会发生Nonepointerexception</strong></p></blockquote></li></ul><h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><ul><li>成员函数是类对外提供操纵属性的接口  <ul><li>成员函数定义： <ul><li>public 返回数据类型 方法名 （参数表）{函数体}；</li></ul></li><li>可在成员函数内部直接调用自己的其他函数</li><li>在成员函数的外部要通过对象的名字+.来调用该函数</li><li>this是成员函数的一个特殊的固有的本地变量，它表达了调用这个函数的那个对象</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showprice</span><span class="params">(<span class="type">int</span> price)</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">this</span>.price = price;<span class="comment">//利用this来访问被本地变量覆盖的成员变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><ul><li><p>代码块又称为<strong>初始化块</strong>，属于类中的成员，类似于成员函数</p><ul><li>将逻辑语句封装在方法体中，通过{}包围起来，但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显示调用，而是加载类时，或创建对象时隐式调用。</li></ul></li><li><p>基本语法</p><ul><li><p>[修饰符]{<br>  代码块<br>  };</p></li><li><p>注意：</p><ul><li>修饰符可选，要写也只能写static</li><li>代码块分为静态代码块和普通代码块</li><li>逻辑语句可以为任何逻辑语句</li><li>;可以省略</li></ul></li></ul></li><li><p>作用</p><ul><li>相当于另外一种形式的构造器（对于构造器的补充机制），可以做初始化操作</li><li>若多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的复用性</li><li>当不管调用那哪个构造器创建对象都会先调用代码块中的内容<ul><li>代码块调用顺序先于构造器</li></ul></li></ul></li><li><p>注意事项和细节讨论</p><ul><li><p>static代码块也叫<strong>静态代码块</strong>，作用就是<strong>对类进行初始化</strong>，而且它<strong>在类的加载时执行</strong>，<strong>且只会执行一次</strong></p></li><li><p>如果是<strong>普通代码块</strong>，<strong>每创建一个对象就执行一次</strong>，与类加载无关。</p></li><li><p><strong>类什么时候加载</strong></p><ul><li>1 创建对象实例的时候</li><li>2 创建子类对象实例，父类 也会被加载</li><li>3 使用类的静态成员时（静态方法，静态属性）</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span><span class="comment">//例</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类静态代码块调用，父类加载&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类普通代码块调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subclass</span> <span class="keyword">extends</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类静态代码块调用，子类加载&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类普通代码块调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若是 new Subclass() 会输出什么,顺序是什么样的？</span></span><br></pre></td></tr></table></figure><h3 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h3><p> static 修饰符表示静态的，静止的<br><br></p><ul><li><p>类变量</p><ul><li>在类中定义的成员变量加上static关键字就成为类变量（静态变量）</li><li>类变量属于类，    <ul><li>可以通过类名.变量名直接访问</li><li>也可通过该类的实例对象.变量访问</li><li>或在类内的函数中直接用变量名（没有变量名覆盖的情况下）</li></ul></li><li>该类创造的所有对象都可以访问这个类变量，但是都是同一个，这个<strong>类变量不属于任何对象，它属于这个类</strong>，被该类的所有对象共享   <br></li></ul></li><li><p>类函数</p><ul><li>static修饰成员函数表示这个函数只属于这个类</li><li>类函数调用方法<ul><li>对象.函数名 </li><li>类名.函数名  </li><li>也可以在非静态方法中通过this指针来调用类函数和类变量</li></ul></li><li><strong>static函数只能调用static函数，只能访问static的成员变量</strong>，他们都可以通过类名访问，也可以通过对象访问</li><li>static方法中不能使用this关键字</li><li>不能通过static函数获得具体的对象内的信息</li><li>static变量只会在类进入到程序中的时候（程序装载）被初始化，与具体对象的初始化无关</li></ul></li><li><p>类方法和类变量使用场景</p><ul><li>当方法中不涉及任何和相关对象的成员，则可以将方法设计成静态方法，提高开发效率<ul><li>比如，工具类utils中的Math类，Arrays类等</li></ul></li><li>实际开发自己的工具类时，将一些通用的方法设计成静态方法，这样不需要创建对象就可以使用该方法，如打印数组，排序等，</li></ul></li><li><p>静态代码块</p><ul><li>用static修饰的代码块称为静态代码块</li><li>当类被加载时静态代码块会执行，由于类只加载一次，因此静态代码块只执行一次，在程序中通常会使用静态代码块来对类的成员静态变量进行初始化</li></ul></li><li><p>注意事项</p><ul><li>static关键字只能用于修饰成员变量，不能用于修饰局部变量</li><li>在一个静态方法中只能访问用static修饰的成员，因为非静态成员在为必须要创建对象后的实例化才能访问，而静态成员在被调用时可以不创建对象<ul><li><strong>静态方法只能调用静态成员</strong></li><li><strong>非静态方法可以访问所有成员</strong></li></ul></li></ul></li></ul><p>补充<br>main方法语法分析</p><ul><li>解释main方法的形式：<br> public static void main(String[] args){}  <ul><li>1.jvm需要调用类中的main方法，故该方法的访问权限必须是public</li><li>2.jvm在执行main方法时不必创建对象，所以该方法必须是static  </li><li>3.该方法接受String类型的数组参数，该数组中保存执行java命令时传递给所运行类的参数  </li><li>4.java 执行程序 参数1 参数2 参数3<br> 在命令行中 传入参数后，可以在程序中从args中取出这些参数</li></ul></li><li>java执行class文件对package的路径是强依赖的。<br> 它在执行的时候会严格以当前用户路径为基础，按照package指定的包路径转化为文件路径去搜索class文件。所需要返回package指定的包路径的上一层路径去执行，就不会报错了<br> - 例如执行work包内的Test.class文件则需要返回到上一层路径：输入<br> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java work.Test</span><br></pre></td></tr></table></figure></li></ul><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="对象含义"><a href="#对象含义" class="headerlink" title="对象含义"></a>对象含义</h3><ul><li><p>对象 &#x3D; 数据 + 服务（提供的待使用函数）</p></li><li><p><strong>对象变量只是对象的管理者</strong>，对象变量的赋值在默认情况下是引用传递，赋的值是地址，赋值方式为引用传递</p></li><li><p><strong>对象内部的数据应该被保护起来不对外公开，把数据和对数据的操作放在一起，隐藏方法实现法细节，对外提供操作该对象的接口。这就是封装</strong>。</p></li></ul><h3 id="对象的初始化"><a href="#对象的初始化" class="headerlink" title="对象的初始化"></a>对象的初始化</h3><h4 id="成员变量定义初始化"><a href="#成员变量定义初始化" class="headerlink" title="成员变量定义初始化"></a>成员变量定义初始化</h4><ul><li>成员变量在定义的地方就可给出初始值</li><li>没有给出初始值的成员变量会自动获得零值<ul><li>对象的零值表示没有管理任何对象，也可主动给NULL值</li></ul></li><li>定义初始化可以调用函数甚至可以使用已经定义的成员变量<ul><li>例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> f1();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f1</span><span class="params">()</span>&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><ul><li>基本语法<ul><li>[修饰符] + 方法名 （参数表）{函数体}    <br></li></ul></li><li>构造器特点 <ul><li><strong>这个函数没有返回值类型</strong></li><li><strong>这个函数名字和类的名字完全相同</strong></li><li>在创建这个类的每一个对象的时候会自动调用这个函数</li><li>可通过构造器在创建对象的时候就直接完成对象属性初始化<blockquote><p>构造器的最前面<strong>默认情况下隐含了super函数和调用普通代码块</strong>。</p><ul><li>即构造函数（）<br>{<br>super();<br>调用本类的普通代码块;<br>&#x2F;&#x2F;程序员添加的操作<br>}</li><li>故实际上创建对象时先调用构造函数，后调用普通代码块。  </li><li>但执行其中自己添加的语句的顺序是普通代码块先于构造函数</li><li>debug跟踪发现 在创建对象时先进入构造函数，然后再跳转到普通代码块内（无继承发生的情况下）</li></ul></blockquote></li></ul></li></ul><br>  <ul><li>构造器重载<ul><li>构造函数可以<strong>重载（overload）</strong>，可以由多个构造函数，只需要函数的参数表不同</li><li><u>若程序员没有定义构造器，系统会自动给类生成一个默认的空实现的无参构造器。</u><br>  但一旦为该类提供了构造器，系统就不在提供默认的构造器了。</li><li><strong>如果一个类中定义了有参的构造方法，最好再定义一个无参的构造方法</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">hello</span>&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    hello()&#123;</span><br><span class="line">        value = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    hello(<span class="type">int</span> value)&#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><blockquote><p>javap 是JDK提供的一个命令行工具，能对给定的class文件提供的字节码进行反编译，通过他可以对照源代码和字节码了解编译器的内部工作。<br>使用格式：javap <options> <classes> </p><ul><li>常用：javap -c &#x2F;-v 类名 (-c对代码反汇编，-v输出附加信息)</li></ul></blockquote><h3 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h3><ul><li><p>jvm给每个对象分配this，代表当前对象，用于在方法中访问对象中的其他成员。</p><ul><li><p>通过this可以明确地访问一个类的成员变量，解决与局部变量名称冲突问题</p></li><li><p>通过this调用成员方法</p></li><li><p>通过this可以访问构造器</p><ul><li>访问构造器语法： this（参数列表）; </li><li>但<strong>只能在构造器中调用其他构造器，且只能位于第一行，只能出现一次</strong>。</li></ul></li><li><p>this不能在类定义的外部使用，只能在类定义的方法中使用  </p></li><li><p>this访问属性的规则</p><ul><li>1 先找本类，如果有，则调用</li><li>2 如果没有，则找父类（如果父类有并且可以调用，则调用）</li><li>3 如果父类没有则可以继续找父类的父类直到Object类</li><li>注意:如果查找属性的过程中找到了该属性但没有访问权限，则会报错，cannot access ,并不会继续在父类的父类中继续查找该属性，若查找的过程中没有找到，则提示属性不存在。</li></ul></li></ul>  <br></li></ul><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><ul><li>java中的垃圾回收机制：java虚拟机会自动回收垃圾所占用的内存空间</li><li>也可以通过调用System.gc()方法来通知java虚拟机立即执行垃圾回收<ul><li>当一个对象在内存中被释放时，它的 <strong>finalize()</strong> 方法会被自动调用，故可以在类内定义 finalize()方法来观察对象何时被释放</li></ul></li></ul><h1 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h1><h2 id="public"><a href="#public" class="headerlink" title="public"></a>public</h2><ul><li>public表示被修饰的变量&#x2F;函数是开放的，可随意访问的。</li><li>在class关键字前加public表示任何人都可以用这个类来定义对象，如果类是public则要求该类必须处在一个文件名与类名相同的源代码文件中。</li></ul><h2 id="private"><a href="#private" class="headerlink" title="private"></a>private</h2><ul><li><p>private关键字只能用于成员变量和成员函数</p><ul><li>表示被修饰的变量&#x2F;函数是这个类私有的，<strong>只有在类内才能访问</strong>。</li><li><strong>这个限制是对于类的而不是对对象的。即同一个类的不同对象可以互相访问别人的私有成员</strong>，同一个类的对象共用类内函数，判断是否能被访问仅看作用域是否在定义该成员的类中。<a href="https://blog.csdn.net/fukaibo121/article/details/73611184">相关内容</a> </li><li>例：</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Outer</span> <span class="variable">outer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">    <span class="type">Outer</span> <span class="variable">outer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">    outer1.test(outer2);<span class="comment">//outer可以在自己的函数中直接访问到outer2的私有变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Outer tesOuter)</span>&#123;</span><br><span class="line">        System.out.println(tesOuter.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li><li><p>基本原则是所有的成员变量都设置为私有的，保护这些变量不能被外界随意使用，对外提供相应的函数接口让这个类按设计者意图去被使用。  </p></li><li><p><strong>当一个编译单元中有不止一个类的时候，只有一个类可以是public</strong>    </p></li><li><p>如果一个类前没有public，则这个类只能在当前所在的package中起作用，</p></li></ul><h2 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h2><ul><li>子类和同一个package的其他类可以访问。</li></ul><h2 id="friendly（默认）"><a href="#friendly（默认）" class="headerlink" title="friendly（默认）"></a>friendly（默认）</h2><ul><li><p>如果没有在一个成员前private或public修饰，就是friendly，意思是和该成员位于同一个package的其他类可以访问。</p></li><li><p>总结</p></li></ul><table><thead><tr><th>访问范围</th><th>private</th><th>default</th><th>protected</th><th>public</th></tr></thead><tbody><tr><td>同一类中</td><td>可</td><td>可</td><td>可</td><td>可</td></tr><tr><td>同一包中</td><td></td><td>可</td><td>可</td><td>可</td></tr><tr><td>子类中</td><td></td><td></td><td>可</td><td>可</td></tr><tr><td>全局范围</td><td></td><td></td><td></td><td>可</td></tr></tbody></table><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li>封装就是把数据和对数据的操作放在一起，对象内部的数据应该被保护起来不对外公开，对外提供操作该对象的接口。这就是封装。</li></ul><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li><p>可以对数据进行验证，保证安全合理  </p><br></li><li><p>利用接口和实现聚合</p><ul><li>把实现类内成员变量操作的方法在类内实现，对外隐藏细节</li><li>有效利用容器，提升灵活性</li><li>后面代码如何发展与外部无关，提升代码的可拓展性</li><li>以框架 + 数据来提高可拓展性     <br></li></ul></li><li><p>利用封装来降低耦合</p><ul><li>类和类之间的关系成为耦合</li><li>耦合程度越低越好，保持距离，保证代码的可拓展性是形成良好代码的关键</li><li>最好不要在一个类中直接操作，输出另一个类中的成员变量<blockquote><p>建议：一段代码最好只完成一个最小的功能，降低代码之间的耦合性</p></blockquote></li></ul></li></ul><h3 id="封装的实现"><a href="#封装的实现" class="headerlink" title="封装的实现"></a>封装的实现</h3><ul><li>1  将属性进行私有化，保证外部不可随意修改查看属性</li><li>2  提供public的get 和 set方法用于获得和修改属性的值（一般get方法要有返回值，set可以设置为boolean的返回类型）<ul><li>把数据验证和权限判断的代码封装在成员函数内部</li><li>将构造器与set函数结合起来，set方法放入构造器中</li></ul></li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="继承语法"><a href="#继承语法" class="headerlink" title="继承语法"></a>继承语法</h2><ul><li>class 子类 extends 父类{}<ul><li>子类就会自动拥有父类定义的属性和方法</li><li>父类也叫超类 ， 基类</li><li>子类也叫派生类</li></ul></li></ul><h2 id="继承作用"><a href="#继承作用" class="headerlink" title="继承作用"></a>继承作用</h2><ul><li>通过继承可以解决代码复用，</li><li>当多个类中存在相同的属性和方法是，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有子类只需通过<strong>extends</strong>来声明继承父类即可，而不需要子类重新定义这些属性和方法。</li></ul><h2 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h2><ul><li>1 子类继承了父类所有的属性和方法，但private的属性和方法不能在子类直接访问，要通过父类提供的public的方法访问</li><li>2  java继承只支持单继承，一个类只能有一个直接父类</li><li>3 子类可以<strong>重写override</strong>并覆盖父类的同名方法（必须和父类方法名称，参数表相同，子类返回两类型要和父类返回类型一样或者是父类返回类型的子类）</li></ul><h2 id="继承的细节"><a href="#继承的细节" class="headerlink" title="继承的细节"></a>继承的细节</h2><ul><li><p>重写的子类方法权限不能小于父类方法的访问权限  </p><br></li><li><p>访问子类构造方法之前会访问父类构造方法，完成父类的初始化  </p><br></li><li><p>当创建子类对象时，不管子类使用哪个构造器，默认情况下总会去调用父类的无参构造器，<strong>若父类没有提供无参构造器，则必须在子类的构造器中用super去制定使用父类的哪个构造器完成对父类的初始化</strong></p><ul><li>故定义一个类时，无特殊需求时，最好在类中定义一个无参构造器。  <br></li></ul></li><li><p>java所有的类都是Object类的子类    </p><br></li><li><p>父类构造器的调用不限于直接父类，而是一直向上追溯到Object类（顶级父类）</p></li></ul><h3 id="super-函数"><a href="#super-函数" class="headerlink" title="super()函数"></a>super()函数</h3><ul><li><a href="https://blog.csdn.net/pipizhen_/article/details/107165618">super函数相关内容</a></li><li>作用是能够帮助子类初始化从父类继承下来的成员,从而简化代码     <br></li><li>当子类和父类中有重名成员时必须借用super来访问父类成员<ul><li>super的访问不限于直接父类，包括更高级的类也可以用super去访问，若多个基类中都有同名成员，用super访问必须遵循就近原则。A-&gt;B-&gt;C</li><li><strong>但不可跳跃访问，若父类同名变量私有，则不会继续向上查找爷爷类是否还有可访问的同名变量</strong>    <br></li></ul></li><li>super不能出现在静态方法中，static上下文不能够出现 this super。    <br></li><li>super()和this()在使用时，<strong>必须放在构造器第一行</strong><ul><li><strong>this 和 super 访问构造方法不能同时存在</strong></li><li>这里super()的作用是制定调用父类的哪个构造方法</li><li><strong>若没有自己写super函数调用，在实例化子类对象时会自动调用父类无参构造器，效果等同于super（）</strong>;</li></ul></li></ul><h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><ul><li>final关键字用于修饰类，属性，方法和局部变量</li><li>使用final修饰的情况<ul><li>1 当类不希望被继承时，可以用final修饰这个类</li><li>2 当不希望父类的某个方法被子类override时，可以用final修饰这个方法</li><li>3 当不希望某个类的某个属性的值被修改，可以用final修饰这个属性</li><li>4 当不希望某个局部变量的值被修改，可以用final修饰这个局部变量</li></ul></li><li>使用细节<ul><li>final修饰的属性也叫常量，一般用XX_XX（大写字母加下划线）来命名</li><li>final变量是不可改变的，但它的值可以在运行时刻初始化，也可以在编译时刻初始化，甚至可以放在构造函数和代码块中初始化，而不必在声明的时候初始化，所以下面的语句均合法<ul><li>final inti&#x3D;1;&#x2F;&#x2F;编译时刻</li><li>final int i2&#x3D; (int) (Math.Random①* 10)；&#x2F;&#x2F;运行时刻 </li><li>final int i3: &#x2F;&#x2F;构造函数或代码块里再初始化</li></ul></li><li>若final修饰的属性是静态的，则初始化的位置只能是<ul><li>定义时</li><li>在静态代码块中</li><li>（此时不能在构造器中赋值）</li></ul></li><li>final类不能继承但可以实例化对象</li><li>如果类不是final类，但含有final方法，则该方法虽然不能重写但可以被继承 </li><li>若是一个类已经是final类了，则没必要再将其中的方法修饰为final</li><li>final不能修饰构造方法</li><li>final和static搭配使用效率更高，不会导致类加载，底层编译器做了优化<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span> ;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Test类加载&quot;</span>);</span><br><span class="line">    &#125;<span class="comment">//在main中直接输出Test.num,是否会出现类加载的情况？若是去掉static呢？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>包装类如Integer，Double，等都是final类，String也是final类，不可被继承</li></ul></li></ul><h2 id="对象创建具体流程"><a href="#对象创建具体流程" class="headerlink" title="对象创建具体流程"></a>对象创建具体流程</h2><ul><li><p>1，加载类信息，只加载一次</p></li><li><p>2，在堆中分配空间（地址）</p></li><li><p>3，完成对象初始化</p><ul><li>1 默认初始化 （实例化对象时jvm会将成员变量自动初始化为0，null等）</li><li>2 显式初始化 </li><li>3 构造器初始化<blockquote><ul><li>先完成类加载再加载实例对象的相关属性和方法</li><li>注意普通代码块是在构造函数中调用的，构造函数调用先于普通代码块调用<ul><li>子类的初始化依赖于父类的初始化，通常通过调用super()来完成父类的初始化。因此，父类的构造函数调用应该在子类构造函数内的任何其他操作之前，包括子类的实例初始化块和构造函数中的其他代码。</li></ul></li><li>若是普通代码块在构造函数前执行，岂不是意味着普通代码块构造先于构造函数中的super（）初始化父类，父类还没初始化怎么可能用代码块初始化子类对象呢</li><li>调用静态代码块和静态变量的初始化时，他们的优先级相同，若有多个静态代码块和多个非态变量初始化，则按定义顺序调用</li><li>调用普通代码块和非静态变量的初始化时，他们的优先级相同，若有多个普通代码块和多个非静态变量初始化，则按定义顺序调用</li><li>java中实例化对象时调用顺序（debug时程序的调用顺序）：父类静态变量 -&gt;父类静态代码块 -&gt; 本类静态变量 -&gt; 本类静态代码块 -&gt; 本类构造函数 -&gt; 父类构造函数 -&gt; 父类普通变量  -&gt; 父类代码块 -&gt; 本类普通变量 -&gt; 本类代码块 </li><li>java中实例化对象时初始化顺序（指代码执行时程序员自己添加的代码执行顺序）：父类静态变量 -&gt;父类静态代码块 -&gt; 本类静态变量 -&gt; 本类静态代码块  -&gt; 父类普通变量  -&gt; 父类代码块 -&gt; 父类构造函数 -&gt; 本类普通变量 -&gt; 本类代码块 -&gt; 本类构造函数</li></ul></blockquote></li></ul></li><li><p>代码示例：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;<span class="comment">//可debug跟踪查看程序具体执行流程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> getN1();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> getN2();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类静态代码块调用&quot;</span>);</span><br><span class="line">    &#125;;A()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类构造函数调用&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getN1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类静态变量加载&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    &#125;<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getN2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类普通变量加载&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    &#125;&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类普通代码块调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num3</span> <span class="operator">=</span> getN3();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num4</span> <span class="operator">=</span> getN4();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类静态代码块调用&quot;</span>);</span><br><span class="line">    &#125;B()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类构造函数调用&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getN3</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类静态变量加载&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    &#125;<span class="keyword">public</span>  <span class="type">int</span> <span class="title function_">getN4</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类普通变量加载&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    &#125;&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类普通代码块调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//当主类new B时会输出什么结果，为什么会输出这种结果？若是将静态变量定义位置与静态代码块位置交换结果会有不同吗？</span></span><br></pre></td></tr></table></figure><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h2 id="多态基本介绍"><a href="#多态基本介绍" class="headerlink" title="多态基本介绍"></a>多态基本介绍</h2><ul><li>Polymorphic   <br></li><li>为了解决传统代码的复用性不高，不利于代码维护的缺点引入多态    <br></li><li>多态是指<strong>方法或者对象</strong>拥有多种形态，是面向对象的第三大特征，多态是建立在封装和继承的基础上的    <br></li></ul><h2 id="多态的具体体现"><a href="#多态的具体体现" class="headerlink" title="多态的具体体现"></a>多态的具体体现</h2><h3 id="1-方法的多态"><a href="#1-方法的多态" class="headerlink" title="1  方法的多态"></a>1  方法的多态</h3><ul><li>重写和重载体现多态，因参数不同同名函数实际调用方法却不同</li></ul><h4 id="函数调用的绑定"><a href="#函数调用的绑定" class="headerlink" title="函数调用的绑定"></a>函数调用的绑定</h4><ul><li>当通过对象变量调用函数时，调用那个函数这件事叫绑定<ul><li>静态绑定：根据变量的声明类型来决定，<strong>在编译时就确定了调用的函数</strong></li><li><strong>动态绑定</strong>：根据变量的动态类型来决定，<strong>在运行时才能确定调用的函数</strong></li></ul></li></ul><h3 id="2-对象的多态"><a href="#2-对象的多态" class="headerlink" title="2  对象的多态"></a>2  对象的多态</h3><ul><li>一个对象的编译类型和运行类型可以不一致</li><li>编译类型在定义对象时就确定了</li><li>运行类型却是根据实际运行时情况决定</li><li>编译类型看定义时 &#x3D; 左边 ， 运行类型看 &#x3D; 右边<ul><li>编译类型就是这个对象变量的属性且不可修改<ul><li>编译类型是由声明该变量时使用的类型决定的</li></ul></li><li>运行类型是实际赋给该变量的内存空间的模板的类型<ul><li>运行类型是由变量指向的具体对象的类型决定</li><li>可以用getClass函数来获得该变量的运行类型</li></ul></li></ul></li></ul><h4 id="向上造型"><a href="#向上造型" class="headerlink" title="向上造型"></a>向上造型</h4><ul><li><p><strong>子类的对象被当做父类对象来使用</strong>    </p><ul><li><p>子类对象赋值给父类变量</p><ul><li><strong>此时不能通过该变量直接调用子类的特有成员</strong>，只有在子类重写父类方法时才能调用子类重写的方法</li><li>此时调用函数时<strong>先在运行类型（子类）中<em>重写父类的函数</em> 中查找</strong>，若没有再去父类中寻找</li></ul></li><li><p>子类对象可以传递给需要父类对象的函数</p></li><li><p>子类对象可以存放在父类对象的容器中</p></li></ul></li><li><p><strong>通过父类变量调用存在覆盖关系的函数时，会调用变量当时的管理的对象运行类型的函数，这时就会发生多态</strong></p></li></ul><h4 id="向下造型"><a href="#向下造型" class="headerlink" title="向下造型"></a>向下造型</h4><ul><li><p>语法：子类类型 引用名 &#x3D; （子类类型） 父类引用     </p></li><li><p><strong>只能强转父类的引用，不能强转父类对象</strong>      </p></li><li><p>要求父类的引用必须指向的是当前目标类型的对象</p><ul><li>即只能将被向上造型的对象的引用向下强转（即只能往回转，并不能在一个父类对象中创造父类中本没有的子类的成员）</li></ul></li><li><p><strong>可以调用子类类型中所有的成员</strong></p></li></ul><h4 id="动态绑定-DynamicBonding"><a href="#动态绑定-DynamicBonding" class="headerlink" title="动态绑定(DynamicBonding)"></a>动态绑定(DynamicBonding)</h4><ul><li>java的动态绑定机制<ul><li><p><strong>调用对象方法时，该方法会与对象的内存地址&#x2F;运行类型绑定</strong> </p><ul><li>即会首先在运行类型重写方法中寻找该方法 </li><li>具体调用哪个方法在运行时才能解析确定</li></ul></li><li><p>当调用对象属性时，<strong>属性没有动态绑定机制</strong>，哪里声明哪里使用</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span> ;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getI</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i +<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>  <span class="title function_">showI</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getI();<span class="comment">//此处会动态绑定调用B中getI()函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">20</span> ;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getI</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicBoding</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        sout(a.showI());<span class="comment">//运行结果是40</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="多态的细节和注意事项"><a href="#多态的细节和注意事项" class="headerlink" title="多态的细节和注意事项"></a>多态的细节和注意事项</h2><ul><li>属性没有重写一说，属性的值看编译类型  <br></li><li>instanceOf比较操作符，用于判断<strong>对象的运行类型</strong>是否为某运行类型或某类型的子类（就是看该对象的实际内存模型）<ul><li>语法： 对象名 instanceof  类名</li></ul></li></ul><h2 id="多态的应用"><a href="#多态的应用" class="headerlink" title="多态的应用"></a>多态的应用</h2><ul><li>多态数组：数组定义类型为父类类型，里面实际保存类型为子类类型<ul><li>在多态数组循环遍历时可以利用instanceof关键字来判断数组内变量的运行类型，并做出相应类型的操作    <br></li></ul></li><li>多态参数：方法定义的形参为父类类型，实参允许为子类类型</li></ul><h1 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h1><h2 id="抽象类和抽象"><a href="#抽象类和抽象" class="headerlink" title="抽象类和抽象"></a>抽象类和抽象</h2><ul><li><p>当父类的某些方法需要声明，但又不确定如何实现时，可以将该方法声明为抽象（abstract）方法，那么这个类就必须要声明为抽象类</p><ul><li>abstact关键字只能用于修饰类和函数</li></ul></li><li><p>抽象函数——表达概念而无法实现具体代码的函数</p><ul><li>用 abstract关键字修饰一个函数，那么这个函数就是抽象函数</li><li>抽象函数特点<ul><li>抽象函数没有方法体</li><li><strong>抽象函数不能用private，final和static来修饰，因为这些关键字都是与重写相违背的</strong></li><li>如果一个类中抽象函数，那么需要将这个类声明为抽象类</li><li><strong>继承自抽象类的非抽象子类必须覆盖父类中的抽象函数</strong></li></ul></li></ul></li><li><p>抽象类——表达概念而无法构造出实体的类</p><ul><li>用 abstract关键字修饰一个类，那么这个类就是抽象类</li><li>抽象类一般只是作为几个类的公共概念，并为作为父类其提供共有属性</li><li>抽象类特点<ul><li>抽象类不能实例化产生对象</li><li>抽象类仍是类，可以有任意成员</li><li>抽象类中不一定要有抽象函数，但抽象函数必须要在抽象类中</li><li><strong>如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法</strong>，除非他自己也声明为abstract类  </li><li>抽象类的价值在于设计，由设计者设计好之后，让子类继承并实现抽象类</li></ul></li></ul></li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul><li><p>概念</p><ul><li>Java接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）</li><li>接口可以理解为一种特殊的类，里面全部是由全局常量和公共的抽象方法所组成。接口是<strong>解决Java无法使用多继承的一种手段</strong>，但是接口在实际中更多的作用是<strong>制定标准</strong>的。或者我们可以直接把接口理解为100%的抽象类，既接口中的方法必须全部是抽象方法。（JDK1.8之前可以这样理解）</li></ul></li><li><p>基本介绍</p><ul><li>interface 接口</li><li>是一种特殊的class，与class地位相同</li><li>用implements表示类实现接口，在实现接口的类中要实现接口中的所有的抽象函数</li><li>类可以实现多个接口</li><li>接口可以继承接口，但不能继承类</li><li>接口不能实现接口</li></ul></li><li><p>语法</p><ul><li>接口定义：<br>  interface 接口名{<br>  &#x2F;&#x2F;属性方法等<br>  }  <blockquote><p>在jdk7.0之前接口里的所有方法都没有方法体<br>  jdk8.0后接口类中可以有静态函数，默认函数，也就是说接口中可以有方法法具体实现，要用默认函数default关键字修饰</p></blockquote></li><li>接口实现：<br>  class 类名 implements 接口{<br>  &#x2F;&#x2F;自己属性和函数，且必须实现接口的抽象函数<br>  }</li></ul></li><li><p>接口细节 </p><ul><li><p>接口特点</p><ul><li>接口是纯抽象类</li><li>所有的成员函数默认是public的抽象函数,可以不用abstract修饰</li><li><strong>所有的成员变量都默认是public static final</strong> </li><li>接口的修饰符只能是public和默认  </li><li>接口只是规定了长什么样子，但是不管里面有什么<ul><li>例  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//就是public static final int a = 1 ;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="comment">//主方法中创建B实例对象b,是否可以输出 b.a , B.a , A.a ?</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>接口实现细节 </p><ul><li>当一个类实现接口时，如果这个类是抽象类，则可以只实现接口中的部分方法，否则要实现接口的所有抽象函数</li><li>一个类可以同时实现多个接口，接口之间用逗号， 隔开</li><li><strong>任何实现了接口的类都可以传递给需要接口类对象的函数</strong><ul><li>此时可以在该函数中调用接口中的函数。</li></ul></li></ul></li><li><p>接口继承细节</p><ul><li>接口不能继承类但接口可以继承接口，用extends关键字，且可以继承多个接口，用逗号，隔开</li><li>一个类在基础恒另一个类的同时还可以实现接口，此时extends关键字必须位于implements关键字之前</li></ul></li></ul></li><li><p>实现接口与继承类的比较</p><ul><li>接口与继承解决的问题不同<ul><li>继承的价值在于：提升代码的复用性和可维护性</li><li>接口的价值在于：设计，设计好各种规范和方法，让其他类去实现这些方法，更加灵活</li></ul></li><li>接口再一定程度上实现代码解耦[即：接口规范性 + 动态绑定]</li></ul></li><li><p>接口的多态</p><ul><li>多态参数<ul><li>接口类型的变量可以指向实现了该接口的类的对象</li></ul></li><li>多态数组<ul><li>可以创建接口类型的数组，其中的引用指向实现了该接口的类的对象</li><li>在调用数组中变量的被实现的接口类的抽象函数时，会动态绑定调用该对象运行类型类中实现的接口中的抽象函数</li></ul></li><li>接口多态传递</li></ul></li></ul><br>- 一个简单的运用接口的例子：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComputerRun</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        <span class="type">Mouse</span> <span class="variable">mouse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mouse</span>();</span><br><span class="line">        <span class="type">Keyboard</span> <span class="variable">keyboard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Keyboard</span>();</span><br><span class="line">        computer.addNewDevice(mouse);</span><br><span class="line">        computer.addNewDevice(keyboard);</span><br><span class="line">        computer.toolOn();</span><br><span class="line">        computer.toolOff();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Usb</span>&#123;<span class="comment">//接口相当于提供一种规范,要求实现接口的类必须实现某些函数</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">toolOn</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">toolOff</span><span class="params">()</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Usb2</span> <span class="keyword">extends</span> <span class="title class_">Usb</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span> <span class="keyword">implements</span> <span class="title class_">Usb</span>&#123;<span class="comment">//实现接口</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//private Usb he = new Usb();错误！不能将接口类实例化</span></span><br><span class="line">    <span class="comment">//但可以实现接口的数组，因为这里只是创建了接口类的引用，并没有创建接口实例，引用可以指向实现了接口的其他类的对象实例</span></span><br><span class="line">    <span class="keyword">private</span> Usb[] devices = <span class="keyword">new</span> <span class="title class_">Usb</span>[<span class="number">2</span>]; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//在这里接口类参数相当于一种规范，只有实现了Usb接口的对象才能传入这个函数，并且不管这个对象内部有什么</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNewDevice</span><span class="params">(Usb device)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//只是将用接口类引用指向传入的对象，类似于向上造型</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; devices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(devices[i] != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">continue</span> ;</span><br><span class="line">            </span><br><span class="line">            devices[i] = device;</span><br><span class="line">            <span class="keyword">if</span>(devices[i] <span class="keyword">instanceof</span> Keyboard)&#123;</span><br><span class="line">                <span class="type">Keyboard</span> <span class="variable">test</span> <span class="operator">=</span> (Keyboard) devices[i];<span class="comment">//向下造型</span></span><br><span class="line">                System.out.println(<span class="string">&quot;鼠标名是&quot;</span> + test.name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toolOn</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; devices.length; i++) &#123;</span><br><span class="line">            devices[i].toolOn();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;电脑启动&quot;</span>);</span><br><span class="line">        <span class="comment">//传入的对象都是实现了接口的，这里会发生多态，调用其运行类型的类内实现的接口抽象函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toolOff</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; devices.length; i++) &#123;</span><br><span class="line">            devices[i].toolOn();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;电脑关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mouse</span> <span class="keyword">implements</span> <span class="title class_">Usb</span>&#123;<span class="comment">//</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toolOn</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鼠标启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toolOff</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鼠标关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Keyboard</span> <span class="keyword">implements</span> <span class="title class_">Usb2</span>&#123;<span class="comment">//实现Usb2，而Usb2继承了Usb，故相当于keyboard类也实现了Usb接口，可以传递给Usb类的引用，这就是接口多态传递</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;罗技&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toolOn</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;键盘启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toolOff</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;键盘关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>面向接口的编程方式<ul><li>设计程序时先定义接口，再实现类</li><li>任何需要在函数间传入传出的一定是接口而不是具体的类（可扩展性高）</li><li>是java成功的关键，适合写大型程序，也导致程序代码量膨胀极快      <br></li></ul></li><li>两种抽象<ul><li>与具体相对<ul><li>表达一种概念而非实体</li></ul></li><li>与细节相对<ul><li>表示在一定程度上忽略细节关注大局</li></ul></li></ul></li></ul><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><ul><li>基本介绍<ul><li>一个类内部有完整的潜逃了另一个类结构，被奇纳陶瓷的类称为内部类（inner class），</li><li>嵌套其他类的类称为外部类（outer class）。</li><li>内部类是类的第五大成员。<ul><li>类的五大成员：<ul><li>属性</li><li>方法</li><li>构造器</li><li>代码块</li><li>内部类</li></ul></li></ul></li><li>内部类的最大特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系</li></ul></li><li>基本语法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- <span class="keyword">class</span> <span class="title class_">Outer</span>&#123;<span class="comment">//外部类  </span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;<span class="comment">//内部类  </span></span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">other</span>&#123;<span class="comment">//外部其他类</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>分类<ul><li>定义在外部类局部位置上：<ul><li>局部内部类（有类名）</li><li><strong>匿名内部类</strong>（没有类名）【重要！】</li></ul></li><li>定义在外部类的成员位置上：<ul><li>成员内部类（没用static修饰）</li><li>静态内部类（使用static修饰）</li></ul></li></ul></li></ul><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><ul><li><p>定义</p><ul><li>局部内部类是 <strong>定义在外部类的局部位置（方法和块中）</strong>，并且有类名</li><li>本质仍然是一个类</li></ul></li><li><p>特点</p><ul><li>可以直接访问外部类所有成员，包含私有的</li><li>不能添加访问修饰符，因为它的地位就是一个局部变量<ul><li>局部变量不能使用修饰符，但可以使用final修饰</li><li>加final修饰后就不可被继承</li></ul></li></ul></li><li><p>作用域：<strong>仅仅在定义它的方法或代码块中</strong></p></li><li><p>访问权限</p><ul><li>局部内部类访问外部类的成员<ul><li>直接访问</li></ul></li><li>外部类访问局部内部类成员<ul><li>先创建对象，再访问（注意，必须在作用域内创建对象）</li></ul></li><li>外部其他类不能访问局部内部类，因为局部内部类地位是一个局部变量</li></ul></li><li><p>如果外部类和局部内部类重名时，默认遵循就近原则</p><ul><li>如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClassTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        outer.function();</span><br><span class="line">        System.out.println(<span class="string">&quot;调用内部类函数的对象的哈希值 = &quot;</span> + outer.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">3</span> ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;外部类方法调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">function</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//局部内部类是定义在外部类的局部位置，通常在方法中</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;<span class="comment">//作用域仅仅在定义它的方法和代码块中</span></span><br><span class="line">            <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">2</span> ;</span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">printinfo</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//访问外部类重名属性使用（外部类名.this.成员）格式</span></span><br><span class="line">                <span class="comment">//这里Outer.this本质就是外部类的对象，即那个对象调用了printinfo函数，</span></span><br><span class="line">                <span class="comment">//Outer.this就是哪个对象,可以通过比较Outer.this和调用该函数的对象的哈希值</span></span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;外部类私有属性num = &quot;</span> + Outer.<span class="built_in">this</span>.num);</span><br><span class="line">                System.out.println(<span class="string">&quot;内部类属性    num = &quot;</span> + <span class="built_in">this</span>.num);</span><br><span class="line">                System.out.println(<span class="string">&quot;就近访问的    num = &quot;</span> + num);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;Outer.this的对象的hashcode值 = &quot;</span> + Outer.<span class="built_in">this</span>.hashCode());</span><br><span class="line"></span><br><span class="line">                method();<span class="comment">//可以直接访问外部类的所有的成员和方法</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在定义这个内部类的方法中创建内部类实例对象，直接调用方法即可</span></span><br><span class="line">        <span class="type">Inner</span> <span class="variable">doPrint</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        doPrint.printinfo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//private Inner doPrint2 ;//错误，在定义局部内部类的函数之外无法访问到这个类</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="匿名内部类-重要"><a href="#匿名内部类-重要" class="headerlink" title="匿名内部类(重要)"></a>匿名内部类(重要)</h2><p>AnonymousInnerClass</p><ul><li>定义<ul><li>匿名内部类是定义在外部类的局部位置，比如方法中，并且没有类名的内部类</li></ul></li><li>本质<ul><li>本质是类</li><li>内部类</li><li>该类没有名字</li><li>同时还是一个对象</li></ul></li><li>基本语法<ul><li>new 类或接口(参数列表){<br>  类体<br>  };</li></ul></li><li>产生原因<ul><li>基于需求，当需要创建一个类实现一个接口，创建对象，但<strong>仅使用一次</strong>后面不在使用</li><li>为了简化开发</li></ul></li></ul><h3 id="实现接口的匿名内部类"><a href="#实现接口的匿名内部类" class="headerlink" title="实现接口的匿名内部类"></a>实现接口的匿名内部类</h3><ul><li>分析下列实例<ul><li>keyboard引用就是指向实现的匿名对象</li><li>keyboard的编译类型是Usb</li><li><strong>keyboard的运行类型就是该匿名内部类</strong></li><li>底层就相当于  <ul><li>class XXXX implements Usb{<br>public void deviceRun(){}<br>  }</li><li><strong>即创建出一个实现了USb接口的类</strong></li><li>这里的XXXX是由系统分配的，如果用getClass函数输出，一般匿名内部类的class输出会包含一个$字符</li></ul></li><li><strong>基于接口的匿名内部类必须要实现对应接口的抽象函数</strong></li><li>匿名内部类使用一次后就无法再使用，即只能创建一个实例对象</li><li>匿名内部类内部可以添加实现其他接口中没有的属性和方法<ul><li>但创建实例后无法访问，因为其运行类型是匿名类，无法向下造型</li><li>但可以但可以在重写的方法中调用新添加的方法</li></ul></li></ul></li><li>例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Usb</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deviceRun</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Keyboard</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Usb</span> <span class="variable">keyboard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Usb</span>&#123;</span><br><span class="line">            <span class="comment">//实现对应接口的抽象函数</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deviceRun</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;键盘启动&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        keyborad.deviceRun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="基于类的匿名内部类"><a href="#基于类的匿名内部类" class="headerlink" title="基于类的匿名内部类"></a>基于类的匿名内部类</h3><ul><li>分析下列实例代码<ul><li>base是Base类型的引用指向创建的匿名内部类对象</li><li>base的编译类型是Base</li><li><strong>base的运行类型就是该匿名内部类</strong></li><li><strong>底层就相当于</strong>  <ul><li>Base base&#x3D; new XXXX();<br>  class XXXX extends Base{<br>  &#x2F;&#x2F;故即使方法块中没有任何语句，XXXX仍是一个新的区别于Base的类<br>  }</li><li>即<strong>创建了一个继承base的子类XXXX</strong></li></ul></li><li>匿名内部类创建时的参数列表会传递给匿名内部类基类的构造器</li><li>匿名内部类内部可以重写类中的方法</li><li>匿名内部类使用一次后就无法再使用，即只能创建一个实例对象</li><li>匿名内部类内部可以添加实现类中本没有的属性和方法<ul><li>但创建实例后无法直接访问，因为其运行类型是匿名类，无法向下造型</li><li>但可以在重写的父类的方法中调用新自己添加的方法</li></ul></li></ul></li><li>例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHi</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;, Hi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getname</span><span class="params">()</span>&#123;<span class="keyword">return</span> <span class="built_in">this</span>.name;&#125;;</span><br><span class="line">    Base(String name)&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">testClass</span>&#123;</span><br><span class="line">    <span class="comment">//这里的参数列表会传递给匿名内部类基类的构造器</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Base</span> <span class="variable">base</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Base</span>(<span class="string">&quot;Tom&quot;</span>)&#123;</span><br><span class="line">        <span class="comment">//在方法体重可以重写对应类的函数</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        base.sayHi();</span><br><span class="line">        base.sayHello();<span class="comment">//无法访问到，且因为是匿名内部类无法向下造型访问</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//更常用的是直接创建匿名对象调用，一次使用</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Base</span>(<span class="string">&quot;Tom&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;jack&quot;</span> ;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHi</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="comment">//此处没有权限直接调用父类的name，与继承的语法关系相同</span></span><br><span class="line">                System.out.println(getname() + <span class="string">&quot;你好&quot;</span>);</span><br><span class="line">                System.out.println(name + <span class="string">&quot;你好&quot;</span>);</span><br><span class="line">                <span class="comment">//变量调用符合就近原则</span></span><br><span class="line">                <span class="built_in">this</span>.sayHello();</span><br><span class="line">                <span class="comment">//只能在匿名内部类内调用匿名类中添加的父类中本没有的新的方法</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.sayHi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="匿名内部类细节"><a href="#匿名内部类细节" class="headerlink" title="匿名内部类细节"></a>匿名内部类细节</h3><ul><li>匿名内部类即使一个类的定义，它本身也是一个对象</li><li>匿名内部类的语法中既有 <em>定义类的特征</em> 也有 <em>创建对象的特征</em></li><li>其他特点与局部内部类相同</li></ul><h3 id="匿名内部类实践"><a href="#匿名内部类实践" class="headerlink" title="匿名内部类实践"></a>匿名内部类实践</h3><ul><li><em><strong>匿名内部类当做实参直接传递</strong></em>,简洁高效<ul><li>因为匿名内部类本身也是一个对象，故可以作为参数传递给函数</li><li>例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//匿名对象方法，创建匿名内部类的匿名对象作为接口类的实参传递给函数</span></span><br><span class="line">    Cat.thisCatWantFly(<span class="keyword">new</span> <span class="title class_">Fly</span>()&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">iCanFly</span><span class="params">()</span>&#123;<span class="comment">//不能减小重写的接口方法的范围</span></span><br><span class="line">        <span class="comment">//接口方法只能是默认和public，故此处最好写上public</span></span><br><span class="line">            System.out.println(<span class="string">&quot;i am a cat , i can fly&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//传统方法，创建一个新的类FlyCat实现Fly接口，实例化后传参</span></span><br><span class="line">    <span class="type">FlyCat</span> <span class="variable">flyCat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FlyCat</span>();</span><br><span class="line">    Cat.thisCatWantFly(flyCat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Fly</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">iCanFly</span><span class="params">()</span>;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line"><span class="comment">//静态方法，参数类型为接口类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">thisCatWantFly</span><span class="params">(Fly cat)</span>&#123;</span><br><span class="line">    cat.iCanFly();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlyCat</span> <span class="keyword">implements</span> <span class="title class_">Fly</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">iCanFly</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;i am a cat , i can fly&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><ul><li><p>成员内部类是定义在外部类的成员位置，并且没有static修饰</p></li><li><p>特点</p><ul><li>可以直接访问外部类的所有成员，包含私有的</li><li>可以添加任意修饰符，因为它的地位就是一个成员</li><li>作用域和其他外部类成员一样，为整个类体</li><li>成员内部类访问外部类<ul><li>直接访问</li></ul></li><li>外部类访问成员内部类  <ul><li>先创建对象，再访问</li></ul></li><li>外部其他类访问成员内部类<ul><li><p>用外部类.内部类 方式直接创建对象</p><ul><li>例：Outer.Inner inner &#x3D; <strong>Outer.new Inner();</strong></li></ul></li><li><p>在外部类中编写方法返回一个成员内部类对象</p></li></ul></li><li>访问外部类成员规则与其他内部类相同</li></ul></li><li><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>  <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;num = &quot;</span> + num);</span><br><span class="line">            System.out.println(<span class="string">&quot;num = &quot;</span> + Outer.<span class="built_in">this</span>.num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useInner</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        inner.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><ul><li>静态内部类是定义在外部类的成员位置，并且有static修饰</li><li>特点<ul><li>可以直接访问外部类的所静态有成员，包含私有的，但不能直接访问非静态成员</li><li>可以添加任意修饰符，因为它的地位就是一个成员</li><li>作用域和其他外部类成员一样，为整个类体</li><li>外部类访问静态内部类<ul><li>要先创建对象再访问</li><li>Outer,Inner inner &#x3D; <strong>new Outer.Inner()</strong>;</li><li>因为是静态成员可以通过类名加 . 直接访问</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>  <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;num = &quot;</span> + num);</span><br><span class="line">            System.out.println(<span class="string">&quot;num = &quot;</span> + Outer.num);<span class="comment">//此处与普通成员内部类不同</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useStaticInner</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        inner.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Object函数"><a href="#Object函数" class="headerlink" title="Object函数"></a>Object函数</h1><h2 id="equals函数"><a href="#equals函数" class="headerlink" title="equals函数"></a>equals函数</h2><ul><li><p>equals()是Object类中的方法，只能判断引用类型变量所指对象与当前对象是否“相等”</p></li><li><p><strong>equals()在Object中函数默认是判断地址是否相等</strong>，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">    &#125;<span class="comment">//Object类中法equals()方法实现</span></span><br></pre></td></tr></table></figure></li><li><p>equals方法在非null对象引用上实现了等价关系；</p></li><li><p>equals函数公约 ：</p><ul><li>自反性 ：对于任何非空的参考值x ， x.equals(x)应该返回true 。 </li><li>对称性 ：对于任何非空引用值x和y ， x.equals(y)应该返回true当且仅当y.equals(x)返回true 。 </li><li>传递性 ：对于任何非空引用值x ， y和z ，如果x.equals(y)返回true，equals(z)返回true ，然后x.equals(z)应该返回true 。 </li><li>一致性 ：对于任何非null引用值x和y，如果不修改对象上的equals比较中使用的信息，则多次调用x.equals（y）会一致地返回true或一致地返回false。。 </li><li>对于任何非空的参考值x ， x.equals(null)应该返回false 。</li></ul></li><li><p>注意，无论何时覆盖该方法，通常需要覆盖hashCode方法，以便维护hashCode方法的公约，该方法规定相等的对象必须具有相等的哈希码。</p></li></ul><h3 id="重写equals-函数"><a href="#重写equals-函数" class="headerlink" title="重写equals()函数"></a>重写equals()函数</h3><ul><li><p>在声明定义一个类时，若直接调用类的equals()函数，使用的是继承自Object类的equals，作用是判断两个对象变量是否管理同一个对象。</p></li><li><p>若要想要比较字符串的内容而不是引用，应该重写一个属于该类的equals()函数</p></li><li><p>重写步骤</p><ul><li>1 判断传入的Obj是否与当前对象地址相同<ul><li>若是，则可直接返回true</li></ul></li><li>2 判断传入的obj的运行类型是否与当前对象类型相同<ul><li>若否，则可直接返回false</li></ul></li><li>3 <strong>将传入的obj向下造型，赋给一个当前对象类型的变量</strong><ul><li><strong>以获得访问该类特有属性的权限</strong></li></ul></li><li>4 比较属性内容是否相同<ul><li>全为真方可返回为true</li></ul></li></ul></li><li><p><strong>在Object子类中，如String，Integer，会重写该方法，用于判断内容是否相同</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == anObject) &#123;<span class="comment">//String中重写的equals方法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">anotherString</span> <span class="operator">=</span> (String)anObject;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> value.length;</span><br><span class="line">            <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">                <span class="type">char</span> v1[] = value;</span><br><span class="line">                <span class="type">char</span> v2[] = anotherString.value;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>学习： 多阅读源码</li></ul><h2 id="hashCode-函数"><a href="#hashCode-函数" class="headerlink" title="hashCode()函数"></a>hashCode()函数</h2><ul><li><p>简介 </p><ul><li>hashcode()的作用主要是提高具有哈希结构的容器的效率</li><li>两个引用如果指向同一个对象则哈希值一定相同</li><li>两个引用如果指向不同对象则哈希值最好要不同</li><li>哈希值是根据地址号经过特殊算法运算得来的</li><li>如果需要也会要重写hashcode()</li></ul></li><li><p>hashCode函数返回对象的哈希码值。 支持这种方法是为了散列表，如HashMap。</p></li><li><p>hashCode()的要求是：</p><ul><li><p>在Java应用程序的执行过程中，每当对同一对象多次调用hashCode方法时，只要不修改对象上的equals比较中使用的信息，hashCode方法就必须始终返回相同的整数。从一个应用程序的一次执行到同一应用程序的另一次执行，该整数不需要保持一致。 </p></li><li><p>如果根据equals（Object）方法，两个对象相等，那么对这两个对象中的每一个调用hashCode方法必须产生相同的整数结果。</p></li><li><p>如果根据equals（Object）方法，两个对象不相等，那么对这两个对象中的每一个调用hashCode方法必须产生不同的整数结果，这是不必要的。然而，程序员应该意识到，为不相等的对象生成不同的整数结果可能会提高哈希表的性能</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;<span class="comment">//String 的hashcode方法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">                h = <span class="number">31</span> * h + val[i];</span><br><span class="line">            &#125;</span><br><span class="line">            hash = h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>总结<ul><li><p>hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的；</p></li><li><p>如果两个对象相同，就是适用于equals(java.lang.Object) 方法，那么这两个对象的hashCode一定要相同；</p></li><li><p>如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致，否则就会违反上面提到的第2点；</p></li><li><p>两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中，如Hashtable，他们“存放在同一个篮子里”</p></li></ul></li></ul><h2 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h2><ul><li>基本介绍<ul><li>默认返回：全类名 + @ + 哈希值的十六进制，<blockquote><p>return getClass().getName() + “@” + Integer.toHexString(hashCode());  </p></blockquote></li><li>实际开发中通常希望对象的toString()方法返回一些特有属性信息等，故子类往往会重写toString()方法</li><li>重写toString方法，打印或拼接对象时，都会自动调用该对象的toString形式</li><li>当直接输出一个对象时，toString方法会被默认调用</li></ul></li></ul><h2 id="clone-函数"><a href="#clone-函数" class="headerlink" title="clone()函数"></a>clone()函数</h2><h3 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h3><ul><li>浅拷贝：默认情况下，clone()方法执行的是浅拷贝（shallow copy），它只会复制对象的字段引用，而不是字段的内容。这意味着如果对象包含其他对象的引用，那么复制的对象和原始对象将共享这些引用，可能导致意外的副作用。</li><li>隐式类型转换：clone()方法返回的是Object类型，需要进行显式的类型转换才能得到正确的类型。这可能导致类型转换错误和运行时异常。</li><li>不适用于不可变对象：对于不可变对象（如String），通常没有必要使用clone()方法，因为它们本身就是不可变的，可以直接共享。</li></ul><h3 id="clone-函数的重写"><a href="#clone-函数的重写" class="headerlink" title="clone()函数的重写"></a>clone()函数的重写</h3><h2 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h2><ul><li>当对象被回收时，系统自动调用该对象的finalize方法，子类可以重写该方法，根据需要做一些<strong>释放资源</strong>的操作等</li><li>何时被回收，当某个对象没有任何引用时，则jvm就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁前会调用finalize方法（类似于CPP中的析构函数）</li><li>垃圾回收机制的调用，是由系统来决定<ul><li>并不是对象不被引用后立刻就回收，而是系统有专门算法控制回收时机</li><li>可以通过System.gc()主动触发垃圾回收机制</li></ul></li><li>若未重写该方法，则会调用Object类中finalize方法，即默认处理</li></ul><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><ul><li>设计模式是静态方法和属性的经典使用</li><li>设计模式是在大量的实践中总结和理论化之后优选的代码结果，编程风格，以及解决问题的思考方式。设计模式就像是被经典的棋谱，免得我们再去摸索</li></ul><h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><ul><li>单例设计模式就是采取一定的方法保证在整个软件系统中，某个类只能存在一个实例对象，并且只提供一个取得其对象实例的方法</li><li>单例模式有两种方式<ul><li>饿汉式</li><li>懒汉式</li></ul></li></ul><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><ul><li>实现方式<ul><li>1 构造器私有化-&gt;防止类外将该类实例化</li><li>2 类的内部创建对象</li><li>3 向外提供一个公共的静态方法返回该实例对象<ul><li>饿汉式是指在类加载时就直接创建这个对象</li><li>故饿汉式可能创建了对象但是没有被使用</li></ul></li></ul></li><li>代码演示 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleClass</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleClass</span> <span class="params">()</span>&#123;&#125;;<span class="comment">//构造器私有化保证只有一个实例化对象   </span></span><br><span class="line">    <span class="comment">//在类内创建好改对象实例，为了能在静态方法中返回该实例对象，需要将其修饰为static</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SingleClass</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleClass</span>();</span><br><span class="line">    <span class="comment">//提供对外返回该实例的公共的static接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingleClass <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><ul><li>实现方式与饿汉式相近<ul><li>区别在于懒汉式是在用户调用该getInstance方法时才会创建实例对象</li><li>且再次调用getInstance方法时会返回之前创建的对象</li></ul></li><li>代码演示<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleClass</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleClass</span> <span class="params">()</span>&#123;&#125;;<span class="comment">//构造器私有化保证只有一个实例化对象   </span></span><br><span class="line">    <span class="comment">//在类内创建对象变量但并不实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleClass instance ;</span><br><span class="line">    <span class="comment">//提供对外返回该实例的公共的static接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingleClass <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)<span class="comment">//如果instance为null则创建实例对象，若部位null则返回之前已经创建好的对象</span></span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">SingleClass</span>();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>二者最大区别在于创建对象的时机不同，饿汉式是在类加载时就创建了对象实例，而懒汉式时在使用时才创建</li><li>饿汉式不存在线程安全为题，懒汉式存在线程安全问题</li><li>饿汉式存在资源浪费的可能。</li><li>在javaSE的标准类中，java.lang.Runtime就是经典的单例模式</li></ul><h2 id="模板设计模式"><a href="#模板设计模式" class="headerlink" title="模板设计模式"></a>模板设计模式</h2><p>例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Template&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doJob</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calculateTime</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        dojob();<span class="comment">//在父类模板中调用抽象方法，子类调用该方法会动态绑定调用自己重写的doJob()</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Subclass1 <span class="keyword">extends</span> <span class="title class_">Template</span>&#123;</span><br><span class="line">    <span class="meta">@override</span><span class="comment">//重写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doJob</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="comment">//执行任务代码，例如计算1加到一百万</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;java-面向对象基础&lt;/p&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;类和对象&quot;&gt;&lt;a href=&quot;#类和对象&quot; class=&quot;headerlink&quot; title=&quot;类和对象&quot;&gt;&lt;/a&gt;类和对象&lt;/h1&gt;&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="java" scheme="https://pengzhanyi.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>个人blog建设</title>
    <link href="https://pengzhanyi.github.io/2023/09/17/%E4%B8%AA%E4%BA%BAblog%E5%BB%BA%E8%AE%BE/"/>
    <id>https://pengzhanyi.github.io/2023/09/17/%E4%B8%AA%E4%BA%BAblog%E5%BB%BA%E8%AE%BE/</id>
    <published>2023-09-17T12:19:01.000Z</published>
    <updated>2023-09-27T16:31:30.526Z</updated>
    
    <content type="html"><![CDATA[<h1 id="记录关于在Github的Pages上用hexo的模板建设个人网站过程中用到的教程和走的一些坑（windows）"><a href="#记录关于在Github的Pages上用hexo的模板建设个人网站过程中用到的教程和走的一些坑（windows）" class="headerlink" title="记录关于在Github的Pages上用hexo的模板建设个人网站过程中用到的教程和走的一些坑（windows）"></a>记录关于在Github的Pages上用hexo的模板建设个人网站过程中用到的教程和走的一些坑（windows）</h1><ul><li><p>1 安装配置Node.js,<a href="https://blog.csdn.net/weixin_52799373/article/details/123840137">教程</a></p></li><li><p>2 <a href="https://zhuanlan.zhihu.com/p/392994381">安装Git ，并生成SSH密钥</a></p></li><li><p>3 下载hexo，（注意必须在管理员权限下的gitbash或powershell中下载）</p></li><li><p>4 <a href="https://zhuanlan.zhihu.com/p/78467553">部署网站</a></p></li><li><p>5 下载并应用butterfly主题时的<a href="https://zhuanlan.zhihu.com/p/137946156">坑</a></p></li></ul><p>补充</p><ul><li><p>6 <a href="https://hexo.io/zh-cn/docs/configuration.html">hexo官方文档</a></p><ul><li>hexo 命令要命令行在blog文件位置才有效 </li><li>hexo new “name’      &#x2F;&#x2F;新建文章</li><li>hexo new page “name” &#x2F;&#x2F;新建页面</li><li>hexo clean &#x2F;&#x2F;清除缓存文件</li><li>hexo g   &#x2F;&#x2F;生成页面</li><li>hexo s  &#x2F;&#x2F;启动预览</li><li>hexo d  &#x2F;&#x2F;部署到Github</li></ul></li><li><p>7 <a href="https://butterfly.js.org/">Butterfly主题官方文档</a></p></li></ul><p>补充1：</p><ul><li><p>Markdown代码块关闭标签</p><ul><li>在Markdown文件中插入代码块时，在代码块结束时切记不要在 &#96;&#96;&#96; 后加空格，否则该标签未关闭。关闭则直接回车换两行即可。该问题在编译器里是看不出异常的，编译器里预览效果都是正常的包括直接用浏览器预览也是正常的，但实际并不是这样的，当你生成hexo博客后就会发现异常。痛苦啊~~~</li></ul></li><li><p>博客中插入图片，看了很多教程，再次深刻体会到了为什么jyy老师强调不要用百度和CSDN的原因，话说发现一个国内看起来很老的博客网站，博客园，感觉还不错，这次也是在这上面找到的<a href="https://www.cnblogs.com/hugochen1024/p/12570656.html">解决方法</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;记录关于在Github的Pages上用hexo的模板建设个人网站过程中用到的教程和走的一些坑（windows）&quot;&gt;&lt;a href=&quot;#记录关于在Github的Pages上用hexo的模板建设个人网站过程中用到的教程和走的一些坑（windows）&quot; class=&quot;h</summary>
      
    
    
    
    
    <category term="blog bulid" scheme="https://pengzhanyi.github.io/tags/blog-bulid/"/>
    
  </entry>
  
  <entry>
    <title>java基础语法</title>
    <link href="https://pengzhanyi.github.io/2023/09/17/java-base/"/>
    <id>https://pengzhanyi.github.io/2023/09/17/java-base/</id>
    <published>2023-09-17T11:25:52.000Z</published>
    <updated>2023-10-13T10:50:58.307Z</updated>
    
    <content type="html"><![CDATA[<ul><li><h2 id="JAVA基础1"><a href="#JAVA基础1" class="headerlink" title="JAVA基础1"></a>JAVA基础1</h2></li></ul><h1 id="一-java的重要特点"><a href="#一-java的重要特点" class="headerlink" title="一.java的重要特点"></a>一.java的重要特点</h1><ul><li>1.面向对象(oop)</li><li>2.健壮性。Java的强类型机制，异常处理，垃圾的自动回收是Java程序健壮性的重要保证。</li><li>3.跨平台可移植</li><li>4.解释性语言<blockquote><p>解释性语言如javascript,PHP。编译性语言：C&#x2F;Cpp<br>区别是：解释性语言编译后的代码不能直接被机器执行，需要解释器执行。编译性语言，编译后的代码，可以直接被机器执行。</p></blockquote></li></ul><h1 id="二-第一个java程序"><a href="#二-第一个java程序" class="headerlink" title="二.第一个java程序"></a>二.第一个java程序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">helloworld</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>java程序的生成<ul><li>javac test.java -&gt; 编译java文件生成test.class字节码文件</li><li>java test 本质就是把.class文件加载到jvm运行该文件</li></ul></li></ul><h1 id="三-java基本数据类型"><a href="#三-java基本数据类型" class="headerlink" title="三.java基本数据类型"></a>三.java基本数据类型</h1><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><ul><li>Java对于方法的局部变量，Java以编译时错误来保证变量在使用前都能得到恰当的初始化，而c是不会报错  <ul><li>但是Java对于<strong>方法内</strong>的单个变量<strong>不会赋予初始值</strong>，对于数组会赋予默认的值</li></ul></li></ul><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><ul><li>整数类型 <ul><li>byte</li><li>short</li><li>int <ul><li>二进制以0b开头</li><li>八进制以0开头</li><li>十六进制以0X开头</li></ul></li><li>long <blockquote><p>补充：位运算符<br>位运算符： &gt;&gt;，&lt;&lt;，&gt;&gt;&gt;是对数据的二进制进行左移右移操作<br>其中 &gt;&gt; 表示向右移动后以1补上空位<br> 而&gt;&gt;&gt;则表示以0补上空位</p></blockquote></li></ul></li></ul><h4 id="数据的类型转换"><a href="#数据的类型转换" class="headerlink" title="数据的类型转换"></a>数据的类型转换</h4><ul><li>整型,实型,字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算，转换从低级到高级</li><li>short类型和byte类型只要参与运算，结果就会被自动转化成int类型数据<blockquote><p>例：byte num &#x3D; 1 ;<br>  short num2 &#x3D;2 ;<br>  short sum &#x3D; num + num2 ;&#x2F;&#x2F;编译会报错</p></blockquote></li></ul><h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><ul><li>float<ul><li>float类型数据必须在数据后加f或F</li></ul></li><li>double</li></ul><h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><ul><li>java使用Unicode来表示字符，可以表示汉字在内的多种文字<blockquote><p>例 ： char a &#x3D; “\u0041”;  \u表示是Unicode编码,0041是指16进制数<br>     System.out.println(a);<br>     输出结果为：a</p></blockquote></li></ul><h2 id="boolean类："><a href="#boolean类：" class="headerlink" title="boolean类："></a>boolean类：</h2><ul><li>只有true和false两个值，且不能与int值作比较</li><li><u>boolean类型默认值为 false</u></li><li>布尔类型boolean占有一个字节，由于其本身所代码的特殊含义，<strong>boolean类型与其他基本类型不能进行类型的转换</strong>（既不能进行自动类型的提升，也不能强制类型转换）， 否则，将编译出错。</li></ul><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>每个引用占据32位的内存空间，其值指向对象实际所在的内存中的位置</p><h3 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h3><h4 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h4><ul><li>数组的创建  </li><li>java中用new创建的int数组有初始零值。</li><li>数组的有一固定属性length，为数组长度</li><li>java中的数组变量只是new出的一块连续地址的“管理者”，即只是获得该数组所在地址，而变量之间的赋值是管理权限的赋予，数组变量的比较是判断是否管理同一个数组。   <blockquote><p><strong>数组的赋值在默认情况下是引用传递，赋的值是地址，赋值方式为引用传递</strong></p></blockquote></li><li>复制数组只能将原数组每个元素逐一拷贝给目的数组,<strong>clone函数</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">System.out.println(array.length);</span><br><span class="line"><span class="type">int</span>[] array2 = array;</span><br><span class="line">array2[<span class="number">0</span>]=<span class="number">10</span>;</span><br><span class="line">System.out.println(array[<span class="number">0</span>],array2[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure></li></ul><h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><ul><li>数组的创建 ： int[][] array &#x3D; new int[3][5];<br>  (必须要给出第一个括号中的参数)</li><li>二维数组array.length 是指该二维数组有多少行，array[1].length表示有几列</li></ul><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><ul><li>String是一个类，<strong>String的变量是对象的管理者而非所有者</strong><ul><li>类似数组变量是数组的管理者而非所有者<ul><li>故字符串创建要用new创建一个String对象，用字符串变量来管理这个这个对象<ul><li>String s &#x3D; new String(“helloworld”);</li></ul></li><li>故字符串对象变量的赋值只是让两个字符串变量管理同一个字符串对象</li></ul></li><li>String是不可变字符串<ul><li>指的是变量一旦被赋值，其值不能被改变，如果想改变变量的值，只能将变量引向另一个字符串</li></ul></li></ul></li></ul><h4 id="equals-与-的区别"><a href="#equals-与-的区别" class="headerlink" title="equals 与 &#x3D;&#x3D; 的区别"></a>equals 与 &#x3D;&#x3D; 的区别</h4><ul><li><p>&#x3D;&#x3D; 是比较运算符，而equals是Object类的方法，Java类都可以使用该方法</p></li><li><p>&#x3D;&#x3D; 既可以比较基本类型也可以比较引用类型，但equals()是Object类中的方法，只能判断引用类型</p></li><li><p>变量的 “&#x3D;&#x3D;”引用类型比较，只是判断两个变量是否管理同一个对象（字符串），即判断地址是否相同</p></li><li><p><strong>比较两个String内容是否相等要用String变量的equals()函数比较</strong></p></li><li><p>下面这段代码输出为true是因为Java中有一个字符串常量池（String Pool）的概念，它使得相同的字符串字面量在内存中只会被存储一次，而多个引用都指向同一个字符串对象。在你的代码中，a和b都被初始化为字符串字面量 “hello”，因为它们的内容相同，所以它们实际上引用了同一个字符串对象，而不是创建了两个相同内容的不同字符串对象。因此，使用”&#x3D;&#x3D;”运算符比较它们会返回true，因为它们引用的是同一个对象。这是字符串常量池的优化机制，它可以减少内存使用，并提高字符串比较的效率。如果你想要比较字符串的内容而不是引用，应该使用equals()方法，而不是”&#x3D;&#x3D;运算符  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="type">String</span> <span class="variable">string1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">string2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">System.out.println(string1 == string2);</span><br></pre></td></tr></table></figure></li><li><p>字符串连接</p><ul><li>用 + 可以连接两个字符串<ul><li>“hello”+”world”&#x3D;”helloworld”</li></ul></li><li>当这个 + 的一边是字符串一边不是时，会将另一边表达为字符串然后做连接<ul><li>“age” + 1 + 2 -&gt; “age12”</li></ul></li></ul></li><li><p>字符串输入</p><ul><li>in.next()读入一个单词，单词的标志是空格<ul><li>空格包括空格，tab和换行</li></ul></li><li>in.nextLine() 读入一整行<blockquote><p>访问字符串里的字符<br>用s.charAT(index)函数，返回该字符串上下标为index的字符，不可用FOR-EACH循环来遍历数组变量</p></blockquote></li></ul></li><li><p>当需要对一个字符串做复杂操作时一般用<strong>StringBuffer</strong>类型，<strong>String类型无法对字符串做修改,是不可变的！！！ String类型只是字符串常量</strong></p><ul><li>StringBuffer.append()</li><li>**StringBuffer.toString()**将该类型转化为String类型;</li></ul></li></ul><h1 id="四-java基本语法"><a href="#四-java基本语法" class="headerlink" title="四.java基本语法"></a>四.java基本语法</h1><h2 id="数据的输入："><a href="#数据的输入：" class="headerlink" title="数据的输入："></a>数据的输入：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, World!&quot;</span>);<span class="comment">//println是指在输出结束后加上换行符</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span> (System.in);<span class="comment">//声明了名为in的数据输入扫描仪（Scanner）</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> in.nextInt();<span class="comment">//将输入的下一个int值赋给value变量</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">amount</span> <span class="operator">=</span> <span class="number">0</span>；<span class="comment">//常量定义</span></span><br><span class="line">        System.out.println(<span class="string">&quot;20+&quot;</span> + value + <span class="string">&quot;=&quot;</span> + (<span class="number">20</span>+ + value) );</span><br><span class="line">in.close();<span class="comment">//结束数据流，释放内存</span></span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure><ul><li>也可以Integer i &#x3D; Integer.parseInt(in.next());输入数据<ul><li>in.next()接收的字符串类型</li><li>parseInt()是Integer类型的函数，将字符串识别转化为int<ul><li>与之相对的有<strong>toString()函数</strong>，将其他类型识别为转化为字符串类型</li></ul></li></ul></li></ul><h2 id="循环："><a href="#循环：" class="headerlink" title="循环："></a>循环：</h2><ul><li>while循环</li><li>do-while循环</li><li>for循环</li></ul><h3 id="FOR-EACH循环"><a href="#FOR-EACH循环" class="headerlink" title="FOR-EACH循环"></a>FOR-EACH循环</h3><pre><code>形式：for(&lt;类型&gt; &lt;变量名&gt; ，&lt;数组&gt;)&#123;&#125;</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="type">int</span> k : array)</span><br><span class="line"><span class="comment">/*解读：对于array数组里的每一个元素，循环的一轮依次拿出作为k的值,  </span></span><br><span class="line"><span class="comment">适合用于遍历数组的情况*/</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( k == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;find!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="包裹类型"><a href="#包裹类型" class="headerlink" title="包裹类型"></a>包裹类型</h2><ul><li>每种基础类型都有相对应的包裹类型</li></ul><table><thead><tr><th>基础类型</th><th>包裹类型</th></tr></thead><tbody><tr><td>boolean</td><td>Boolean</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>double</td><td>Double</td></tr></tbody></table><ul><li><p>包装类与基本数据类型比较</p></li><li><p>包裹类型变量有一些特殊的函数   </p><ul><li>每个包裹类型都有toString方法，用于将该类型变量转化为字符串</li><li>每个包裹类型也有自己的parse方法，用于将字符串识别转化为该类型的变量<blockquote><p>例 ： Integer a &#x3D; 1;<br>System.out.println(a.MAX_VALUE);<br>输出结果为：2147483647<br>类似的还有Interger.parseInt( string, 10)，该函数将字符串作为有符号的十进制整数进行解析</p></blockquote></li></ul></li></ul><h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><ul><li>abs 求绝对值</li><li>pow 求幂</li><li>random 提供一个0-1的随机数<ul><li>random.nextInt(bound) 提供一个零到bound的随机int类型数据，包括零但不包括bound<ul><li>一般可以用random.nextInt(array.length)作为下标来做到随机访问数组中的成员</li></ul></li></ul></li><li>round 做四舍五入</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li>不能在一个块内定义块外定义过的变量。（与C语言会隐藏块外同名变量机制不同）</li></ul><h2 id="可变参数方法"><a href="#可变参数方法" class="headerlink" title="可变参数方法"></a>可变参数方法</h2><ul><li><img src="/images/java_base1_01.png" alt="img"></li></ul><h2 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h2><h3 id="IDEA快捷键"><a href="#IDEA快捷键" class="headerlink" title="IDEA快捷键"></a>IDEA快捷键</h3><ul><li>删除当前行， 自己配Ctrl + d</li><li>补全代码 alt + &#x2F;</li><li>导入该行所需的类 Alt + Enter</li><li>生成构造器等 <strong>alt + insert</strong></li><li><strong>查看一个类的层级关系 Ctrl + H</strong></li><li>生成当前类的继承关系图Ctrl + Alt + U</li><li>查看当前类的所有方法和属性 Ctrl + F12</li><li>将光标放在一个方法上，Ctrl + B可以选择定位到哪个类的方法</li><li>.var 可自动分配变量名</li><li>Ctrl + b 跳转到该函数实现处</li></ul><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><ul><li>sout模板快捷键</li><li>fori模板快捷键</li><li>file - 设置- 编辑器-实时模板 里查看java的模板，可以自定义模板增加开发效率</li></ul><h2 id="package"><a href="#package" class="headerlink" title="package"></a>package</h2><h3 id="包的基本语法"><a href="#包的基本语法" class="headerlink" title="包的基本语法"></a>包的基本语法</h3><ul><li>package 包名;</li></ul><h3 id="包的作用"><a href="#包的作用" class="headerlink" title="包的作用"></a>包的作用</h3><ul><li>包的本质就是创建不同的文件夹来保存管理类</li><li>包的名字里可以带有“.”,例如import java.util.Scanner;其中的.（包的名字中的.）实际上表达的就是文件系统中文件夹的层次，java正是同这样的手段来管理类，这就是java的package管理机制。</li><li>可用去区分相同名字的类</li><li><strong>若用到的类与当前所在文件不在一个package中则需要用import package名.类名  来引入这个类</strong>。</li></ul><h3 id="包的导入"><a href="#包的导入" class="headerlink" title="包的导入"></a>包的导入</h3><ul><li>语法： import + 完整包名<ul><li>例 ： import java.util.Scanner 只会引入Scanner</li></ul></li><li>import + 包名. + * <ul><li>引入该类下的所有的类（但不建议使用该方法，<strong>最好根据需求引用相应的类</strong>）</li></ul></li></ul><h3 id="常用包"><a href="#常用包" class="headerlink" title="常用包"></a>常用包</h3><ul><li>java.util&#x2F;&#x2F;系统提供的工具包，包括Scanner</li><li>java.lang &#x2F;&#x2F;lang是基本包，默认引入，不许要再引入</li><li>java.net &#x2F;&#x2F;网络包，做网络开发</li><li>java.awt &#x2F;&#x2F;做java界面开发，GUI</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>package的作用是声明当前类所在的包，需要放在类的最上面，一个类中最多只有一句package</li><li>import指令放在package指令下，在类定义前</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;h2 id=&quot;JAVA基础1&quot;&gt;&lt;a href=&quot;#JAVA基础1&quot; class=&quot;headerlink&quot; title=&quot;JAVA基础1&quot;&gt;&lt;/a&gt;JAVA基础1&lt;/h2&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;一-java的重要特点&quot;&gt;&lt;a href=&quot;#一</summary>
      
    
    
    
    
    <category term="java" scheme="https://pengzhanyi.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>hello blog test</title>
    <link href="https://pengzhanyi.github.io/2023/09/17/hello-blog-test/"/>
    <id>https://pengzhanyi.github.io/2023/09/17/hello-blog-test/</id>
    <published>2023-09-17T01:03:36.000Z</published>
    <updated>2023-09-17T12:41:07.232Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://pengzhanyi.github.io/2023/09/17/hello-world/"/>
    <id>https://pengzhanyi.github.io/2023/09/17/hello-world/</id>
    <published>2023-09-17T00:13:16.062Z</published>
    <updated>2023-09-17T00:13:16.062Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
